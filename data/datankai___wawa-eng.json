{
  "repo_name": "wawa-eng",
  "repo_full_name": "datankai/wawa-eng",
  "repo_owner": "datankai",
  "repo_description": "Repor for wawa app",
  "repo_private": false,
  "repo_fork": false,
  "schemas": [
    {
      "name": "prisma.graphql",
      "path": "graph-endpoint/src/generated/prisma.graphql",
      "sha": "874c714b855840b0825a8634a0e96424ea49d25c",
      "url": "https://api.github.com/repositories/111743730/contents/graph-endpoint/src/generated/prisma.graphql?ref=0cf12259e3fa9a8d171024b0f8a11b684c732e2e",
      "git_url": "https://api.github.com/repositories/111743730/git/blobs/874c714b855840b0825a8634a0e96424ea49d25c",
      "html_url": "https://github.com/datankai/wawa-eng/blob/0cf12259e3fa9a8d171024b0f8a11b684c732e2e/graph-endpoint/src/generated/prisma.graphql",
      "content": "type AggregateArrivingTo {\n  count: Int!\n}\n\ntype AggregateAsignedRoute {\n  count: Int!\n}\n\ntype AggregateBus {\n  count: Int!\n}\n\ntype AggregateBusLocation {\n  count: Int!\n}\n\ntype AggregateLocation {\n  count: Int!\n}\n\ntype AggregatePlannedExit {\n  count: Int!\n}\n\ntype AggregatePoint {\n  count: Int!\n}\n\ntype AggregateRoute {\n  count: Int!\n}\n\ntype AggregateStop {\n  count: Int!\n}\n\ntype AggregateUser {\n  count: Int!\n}\n\ntype ArrivingTo {\n  id: UUID!\n  stop(where: StopWhereInput): Stop!\n  time: DateTime!\n  bus(where: BusWhereInput): Bus!\n}\n\n# A connection to a list of items.\ntype ArrivingToConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [ArrivingToEdge]!\n  aggregate: AggregateArrivingTo!\n}\n\ninput ArrivingToCreateInput {\n  time: DateTime!\n  stop: StopCreateOneWithoutOnComingInput!\n  bus: BusCreateOneWithoutArrivingToInput!\n}\n\ninput ArrivingToCreateManyInput {\n  create: [ArrivingToCreateInput!]\n  connect: [ArrivingToWhereUniqueInput!]\n}\n\ninput ArrivingToCreateManyWithoutBusInput {\n  create: [ArrivingToCreateWithoutBusInput!]\n  connect: [ArrivingToWhereUniqueInput!]\n}\n\ninput ArrivingToCreateManyWithoutStopInput {\n  create: [ArrivingToCreateWithoutStopInput!]\n  connect: [ArrivingToWhereUniqueInput!]\n}\n\ninput ArrivingToCreateWithoutBusInput {\n  time: DateTime!\n  stop: StopCreateOneWithoutOnComingInput!\n}\n\ninput ArrivingToCreateWithoutStopInput {\n  time: DateTime!\n  bus: BusCreateOneWithoutArrivingToInput!\n}\n\n# An edge in a connection.\ntype ArrivingToEdge {\n  # The item at the end of the edge.\n  node: ArrivingTo!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum ArrivingToOrderByInput {\n  id_ASC\n  id_DESC\n  time_ASC\n  time_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype ArrivingToPreviousValues {\n  id: UUID!\n  time: DateTime!\n}\n\ntype ArrivingToSubscriptionPayload {\n  mutation: MutationType!\n  node: ArrivingTo\n  updatedFields: [String!]\n  previousValues: ArrivingToPreviousValues\n}\n\ninput ArrivingToSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [ArrivingToSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [ArrivingToSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [ArrivingToSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: ArrivingToWhereInput\n}\n\ninput ArrivingToUpdateDataInput {\n  time: DateTime\n  stop: StopUpdateOneWithoutOnComingInput\n  bus: BusUpdateOneWithoutArrivingToInput\n}\n\ninput ArrivingToUpdateInput {\n  time: DateTime\n  stop: StopUpdateOneWithoutOnComingInput\n  bus: BusUpdateOneWithoutArrivingToInput\n}\n\ninput ArrivingToUpdateManyInput {\n  create: [ArrivingToCreateInput!]\n  connect: [ArrivingToWhereUniqueInput!]\n  disconnect: [ArrivingToWhereUniqueInput!]\n  delete: [ArrivingToWhereUniqueInput!]\n  update: [ArrivingToUpdateWithWhereUniqueNestedInput!]\n  upsert: [ArrivingToUpsertWithWhereUniqueNestedInput!]\n}\n\ninput ArrivingToUpdateManyWithoutBusInput {\n  create: [ArrivingToCreateWithoutBusInput!]\n  connect: [ArrivingToWhereUniqueInput!]\n  disconnect: [ArrivingToWhereUniqueInput!]\n  delete: [ArrivingToWhereUniqueInput!]\n  update: [ArrivingToUpdateWithWhereUniqueWithoutBusInput!]\n  upsert: [ArrivingToUpsertWithWhereUniqueWithoutBusInput!]\n}\n\ninput ArrivingToUpdateManyWithoutStopInput {\n  create: [ArrivingToCreateWithoutStopInput!]\n  connect: [ArrivingToWhereUniqueInput!]\n  disconnect: [ArrivingToWhereUniqueInput!]\n  delete: [ArrivingToWhereUniqueInput!]\n  update: [ArrivingToUpdateWithWhereUniqueWithoutStopInput!]\n  upsert: [ArrivingToUpsertWithWhereUniqueWithoutStopInput!]\n}\n\ninput ArrivingToUpdateWithoutBusDataInput {\n  time: DateTime\n  stop: StopUpdateOneWithoutOnComingInput\n}\n\ninput ArrivingToUpdateWithoutStopDataInput {\n  time: DateTime\n  bus: BusUpdateOneWithoutArrivingToInput\n}\n\ninput ArrivingToUpdateWithWhereUniqueNestedInput {\n  where: ArrivingToWhereUniqueInput!\n  data: ArrivingToUpdateDataInput!\n}\n\ninput ArrivingToUpdateWithWhereUniqueWithoutBusInput {\n  where: ArrivingToWhereUniqueInput!\n  data: ArrivingToUpdateWithoutBusDataInput!\n}\n\ninput ArrivingToUpdateWithWhereUniqueWithoutStopInput {\n  where: ArrivingToWhereUniqueInput!\n  data: ArrivingToUpdateWithoutStopDataInput!\n}\n\ninput ArrivingToUpsertWithWhereUniqueNestedInput {\n  where: ArrivingToWhereUniqueInput!\n  update: ArrivingToUpdateDataInput!\n  create: ArrivingToCreateInput!\n}\n\ninput ArrivingToUpsertWithWhereUniqueWithoutBusInput {\n  where: ArrivingToWhereUniqueInput!\n  update: ArrivingToUpdateWithoutBusDataInput!\n  create: ArrivingToCreateWithoutBusInput!\n}\n\ninput ArrivingToUpsertWithWhereUniqueWithoutStopInput {\n  where: ArrivingToWhereUniqueInput!\n  update: ArrivingToUpdateWithoutStopDataInput!\n  create: ArrivingToCreateWithoutStopInput!\n}\n\ninput ArrivingToWhereInput {\n  # Logical AND on all given filters.\n  AND: [ArrivingToWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [ArrivingToWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [ArrivingToWhereInput!]\n  time: DateTime\n\n  # All values that are not equal to given value.\n  time_not: DateTime\n\n  # All values that are contained in given list.\n  time_in: [DateTime!]\n\n  # All values that are not contained in given list.\n  time_not_in: [DateTime!]\n\n  # All values less than the given value.\n  time_lt: DateTime\n\n  # All values less than or equal the given value.\n  time_lte: DateTime\n\n  # All values greater than the given value.\n  time_gt: DateTime\n\n  # All values greater than or equal the given value.\n  time_gte: DateTime\n  stop: StopWhereInput\n  bus: BusWhereInput\n}\n\ninput ArrivingToWhereUniqueInput {\n  id: UUID\n}\n\ntype AsignedRoute {\n  m1ID: String!\n  displayName: String\n  buses: [String!]!\n}\n\n# A connection to a list of items.\ntype AsignedRouteConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [AsignedRouteEdge]!\n  aggregate: AggregateAsignedRoute!\n}\n\ninput AsignedRouteCreatebusesInput {\n  set: [String!]\n}\n\ninput AsignedRouteCreateInput {\n  m1ID: String!\n  displayName: String\n  buses: AsignedRouteCreatebusesInput\n}\n\n# An edge in a connection.\ntype AsignedRouteEdge {\n  # The item at the end of the edge.\n  node: AsignedRoute!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum AsignedRouteOrderByInput {\n  m1ID_ASC\n  m1ID_DESC\n  displayName_ASC\n  displayName_DESC\n  id_ASC\n  id_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype AsignedRoutePreviousValues {\n  m1ID: String!\n  displayName: String\n  buses: [String!]!\n}\n\ntype AsignedRouteSubscriptionPayload {\n  mutation: MutationType!\n  node: AsignedRoute\n  updatedFields: [String!]\n  previousValues: AsignedRoutePreviousValues\n}\n\ninput AsignedRouteSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [AsignedRouteSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [AsignedRouteSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [AsignedRouteSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: AsignedRouteWhereInput\n}\n\ninput AsignedRouteUpdatebusesInput {\n  set: [String!]\n}\n\ninput AsignedRouteUpdateInput {\n  m1ID: String\n  displayName: String\n  buses: AsignedRouteUpdatebusesInput\n}\n\ninput AsignedRouteWhereInput {\n  # Logical AND on all given filters.\n  AND: [AsignedRouteWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [AsignedRouteWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [AsignedRouteWhereInput!]\n  m1ID: String\n\n  # All values that are not equal to given value.\n  m1ID_not: String\n\n  # All values that are contained in given list.\n  m1ID_in: [String!]\n\n  # All values that are not contained in given list.\n  m1ID_not_in: [String!]\n\n  # All values less than the given value.\n  m1ID_lt: String\n\n  # All values less than or equal the given value.\n  m1ID_lte: String\n\n  # All values greater than the given value.\n  m1ID_gt: String\n\n  # All values greater than or equal the given value.\n  m1ID_gte: String\n\n  # All values containing the given string.\n  m1ID_contains: String\n\n  # All values not containing the given string.\n  m1ID_not_contains: String\n\n  # All values starting with the given string.\n  m1ID_starts_with: String\n\n  # All values not starting with the given string.\n  m1ID_not_starts_with: String\n\n  # All values ending with the given string.\n  m1ID_ends_with: String\n\n  # All values not ending with the given string.\n  m1ID_not_ends_with: String\n  displayName: String\n\n  # All values that are not equal to given value.\n  displayName_not: String\n\n  # All values that are contained in given list.\n  displayName_in: [String!]\n\n  # All values that are not contained in given list.\n  displayName_not_in: [String!]\n\n  # All values less than the given value.\n  displayName_lt: String\n\n  # All values less than or equal the given value.\n  displayName_lte: String\n\n  # All values greater than the given value.\n  displayName_gt: String\n\n  # All values greater than or equal the given value.\n  displayName_gte: String\n\n  # All values containing the given string.\n  displayName_contains: String\n\n  # All values not containing the given string.\n  displayName_not_contains: String\n\n  # All values starting with the given string.\n  displayName_starts_with: String\n\n  # All values not starting with the given string.\n  displayName_not_starts_with: String\n\n  # All values ending with the given string.\n  displayName_ends_with: String\n\n  # All values not ending with the given string.\n  displayName_not_ends_with: String\n}\n\ninput AsignedRouteWhereUniqueInput {\n  m1ID: String\n}\n\ntype BatchPayload {\n  # The number of nodes that have been affected by the Batch operation.\n  count: Long!\n}\n\ntype Bus {\n  position(where: LocationWhereInput): Location!\n  id: UUID!\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String!\n  passangers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]\n  arrivingTo(where: ArrivingToWhereInput, orderBy: ArrivingToOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ArrivingTo!]\n  locations(where: BusLocationWhereInput, orderBy: BusLocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BusLocation!]\n  busType: String\n  maxCapacity: Float\n  direction: String\n}\n\n# A connection to a list of items.\ntype BusConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [BusEdge]!\n  aggregate: AggregateBus!\n}\n\ninput BusCreateInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String!\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationCreateOneInput!\n  passangers: UserCreateManyWithoutOnBusInput\n  arrivingTo: ArrivingToCreateManyWithoutBusInput\n  locations: BusLocationCreateManyWithoutOwnerInput\n}\n\ninput BusCreateOneWithoutArrivingToInput {\n  create: BusCreateWithoutArrivingToInput\n  connect: BusWhereUniqueInput\n}\n\ninput BusCreateOneWithoutLocationsInput {\n  create: BusCreateWithoutLocationsInput\n  connect: BusWhereUniqueInput\n}\n\ninput BusCreateOneWithoutPassangersInput {\n  create: BusCreateWithoutPassangersInput\n  connect: BusWhereUniqueInput\n}\n\ninput BusCreateWithoutArrivingToInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String!\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationCreateOneInput!\n  passangers: UserCreateManyWithoutOnBusInput\n  locations: BusLocationCreateManyWithoutOwnerInput\n}\n\ninput BusCreateWithoutLocationsInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String!\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationCreateOneInput!\n  passangers: UserCreateManyWithoutOnBusInput\n  arrivingTo: ArrivingToCreateManyWithoutBusInput\n}\n\ninput BusCreateWithoutPassangersInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String!\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationCreateOneInput!\n  arrivingTo: ArrivingToCreateManyWithoutBusInput\n  locations: BusLocationCreateManyWithoutOwnerInput\n}\n\n# An edge in a connection.\ntype BusEdge {\n  # The item at the end of the edge.\n  node: Bus!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\ntype BusLocation {\n  id: UUID!\n  position(where: LocationWhereInput): Location!\n  owner(where: BusWhereInput): Bus\n  timestamp: DateTime!\n}\n\n# A connection to a list of items.\ntype BusLocationConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [BusLocationEdge]!\n  aggregate: AggregateBusLocation!\n}\n\ninput BusLocationCreateInput {\n  timestamp: DateTime!\n  position: LocationCreateOneInput!\n  owner: BusCreateOneWithoutLocationsInput\n}\n\ninput BusLocationCreateManyWithoutOwnerInput {\n  create: [BusLocationCreateWithoutOwnerInput!]\n  connect: [BusLocationWhereUniqueInput!]\n}\n\ninput BusLocationCreateWithoutOwnerInput {\n  timestamp: DateTime!\n  position: LocationCreateOneInput!\n}\n\n# An edge in a connection.\ntype BusLocationEdge {\n  # The item at the end of the edge.\n  node: BusLocation!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum BusLocationOrderByInput {\n  id_ASC\n  id_DESC\n  timestamp_ASC\n  timestamp_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype BusLocationPreviousValues {\n  id: UUID!\n  timestamp: DateTime!\n}\n\ntype BusLocationSubscriptionPayload {\n  mutation: MutationType!\n  node: BusLocation\n  updatedFields: [String!]\n  previousValues: BusLocationPreviousValues\n}\n\ninput BusLocationSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [BusLocationSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [BusLocationSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [BusLocationSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: BusLocationWhereInput\n}\n\ninput BusLocationUpdateInput {\n  timestamp: DateTime\n  position: LocationUpdateOneInput\n  owner: BusUpdateOneWithoutLocationsInput\n}\n\ninput BusLocationUpdateManyWithoutOwnerInput {\n  create: [BusLocationCreateWithoutOwnerInput!]\n  connect: [BusLocationWhereUniqueInput!]\n  disconnect: [BusLocationWhereUniqueInput!]\n  delete: [BusLocationWhereUniqueInput!]\n  update: [BusLocationUpdateWithWhereUniqueWithoutOwnerInput!]\n  upsert: [BusLocationUpsertWithWhereUniqueWithoutOwnerInput!]\n}\n\ninput BusLocationUpdateWithoutOwnerDataInput {\n  timestamp: DateTime\n  position: LocationUpdateOneInput\n}\n\ninput BusLocationUpdateWithWhereUniqueWithoutOwnerInput {\n  where: BusLocationWhereUniqueInput!\n  data: BusLocationUpdateWithoutOwnerDataInput!\n}\n\ninput BusLocationUpsertWithWhereUniqueWithoutOwnerInput {\n  where: BusLocationWhereUniqueInput!\n  update: BusLocationUpdateWithoutOwnerDataInput!\n  create: BusLocationCreateWithoutOwnerInput!\n}\n\ninput BusLocationWhereInput {\n  # Logical AND on all given filters.\n  AND: [BusLocationWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [BusLocationWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [BusLocationWhereInput!]\n  timestamp: DateTime\n\n  # All values that are not equal to given value.\n  timestamp_not: DateTime\n\n  # All values that are contained in given list.\n  timestamp_in: [DateTime!]\n\n  # All values that are not contained in given list.\n  timestamp_not_in: [DateTime!]\n\n  # All values less than the given value.\n  timestamp_lt: DateTime\n\n  # All values less than or equal the given value.\n  timestamp_lte: DateTime\n\n  # All values greater than the given value.\n  timestamp_gt: DateTime\n\n  # All values greater than or equal the given value.\n  timestamp_gte: DateTime\n  position: LocationWhereInput\n  owner: BusWhereInput\n}\n\ninput BusLocationWhereUniqueInput {\n  id: UUID\n}\n\nenum BusOrderByInput {\n  id_ASC\n  id_DESC\n  status_ASC\n  status_DESC\n  speed_ASC\n  speed_DESC\n  heading_ASC\n  heading_DESC\n  m1ID_ASC\n  m1ID_DESC\n  busType_ASC\n  busType_DESC\n  maxCapacity_ASC\n  maxCapacity_DESC\n  direction_ASC\n  direction_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype BusPreviousValues {\n  id: UUID!\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String!\n  busType: String\n  maxCapacity: Float\n  direction: String\n}\n\ntype BusSubscriptionPayload {\n  mutation: MutationType!\n  node: Bus\n  updatedFields: [String!]\n  previousValues: BusPreviousValues\n}\n\ninput BusSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [BusSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [BusSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [BusSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: BusWhereInput\n}\n\ninput BusUpdateInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationUpdateOneInput\n  passangers: UserUpdateManyWithoutOnBusInput\n  arrivingTo: ArrivingToUpdateManyWithoutBusInput\n  locations: BusLocationUpdateManyWithoutOwnerInput\n}\n\ninput BusUpdateOneWithoutArrivingToInput {\n  create: BusCreateWithoutArrivingToInput\n  connect: BusWhereUniqueInput\n  delete: Boolean\n  update: BusUpdateWithoutArrivingToDataInput\n  upsert: BusUpsertWithoutArrivingToInput\n}\n\ninput BusUpdateOneWithoutLocationsInput {\n  create: BusCreateWithoutLocationsInput\n  connect: BusWhereUniqueInput\n  disconnect: Boolean\n  delete: Boolean\n  update: BusUpdateWithoutLocationsDataInput\n  upsert: BusUpsertWithoutLocationsInput\n}\n\ninput BusUpdateOneWithoutPassangersInput {\n  create: BusCreateWithoutPassangersInput\n  connect: BusWhereUniqueInput\n  disconnect: Boolean\n  delete: Boolean\n  update: BusUpdateWithoutPassangersDataInput\n  upsert: BusUpsertWithoutPassangersInput\n}\n\ninput BusUpdateWithoutArrivingToDataInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationUpdateOneInput\n  passangers: UserUpdateManyWithoutOnBusInput\n  locations: BusLocationUpdateManyWithoutOwnerInput\n}\n\ninput BusUpdateWithoutLocationsDataInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationUpdateOneInput\n  passangers: UserUpdateManyWithoutOnBusInput\n  arrivingTo: ArrivingToUpdateManyWithoutBusInput\n}\n\ninput BusUpdateWithoutPassangersDataInput {\n  status: String\n  speed: Float\n  heading: Float\n  m1ID: String\n  busType: String\n  maxCapacity: Float\n  direction: String\n  position: LocationUpdateOneInput\n  arrivingTo: ArrivingToUpdateManyWithoutBusInput\n  locations: BusLocationUpdateManyWithoutOwnerInput\n}\n\ninput BusUpsertWithoutArrivingToInput {\n  update: BusUpdateWithoutArrivingToDataInput!\n  create: BusCreateWithoutArrivingToInput!\n}\n\ninput BusUpsertWithoutLocationsInput {\n  update: BusUpdateWithoutLocationsDataInput!\n  create: BusCreateWithoutLocationsInput!\n}\n\ninput BusUpsertWithoutPassangersInput {\n  update: BusUpdateWithoutPassangersDataInput!\n  create: BusCreateWithoutPassangersInput!\n}\n\ninput BusWhereInput {\n  # Logical AND on all given filters.\n  AND: [BusWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [BusWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [BusWhereInput!]\n  status: String\n\n  # All values that are not equal to given value.\n  status_not: String\n\n  # All values that are contained in given list.\n  status_in: [String!]\n\n  # All values that are not contained in given list.\n  status_not_in: [String!]\n\n  # All values less than the given value.\n  status_lt: String\n\n  # All values less than or equal the given value.\n  status_lte: String\n\n  # All values greater than the given value.\n  status_gt: String\n\n  # All values greater than or equal the given value.\n  status_gte: String\n\n  # All values containing the given string.\n  status_contains: String\n\n  # All values not containing the given string.\n  status_not_contains: String\n\n  # All values starting with the given string.\n  status_starts_with: String\n\n  # All values not starting with the given string.\n  status_not_starts_with: String\n\n  # All values ending with the given string.\n  status_ends_with: String\n\n  # All values not ending with the given string.\n  status_not_ends_with: String\n  speed: Float\n\n  # All values that are not equal to given value.\n  speed_not: Float\n\n  # All values that are contained in given list.\n  speed_in: [Float!]\n\n  # All values that are not contained in given list.\n  speed_not_in: [Float!]\n\n  # All values less than the given value.\n  speed_lt: Float\n\n  # All values less than or equal the given value.\n  speed_lte: Float\n\n  # All values greater than the given value.\n  speed_gt: Float\n\n  # All values greater than or equal the given value.\n  speed_gte: Float\n  heading: Float\n\n  # All values that are not equal to given value.\n  heading_not: Float\n\n  # All values that are contained in given list.\n  heading_in: [Float!]\n\n  # All values that are not contained in given list.\n  heading_not_in: [Float!]\n\n  # All values less than the given value.\n  heading_lt: Float\n\n  # All values less than or equal the given value.\n  heading_lte: Float\n\n  # All values greater than the given value.\n  heading_gt: Float\n\n  # All values greater than or equal the given value.\n  heading_gte: Float\n  m1ID: String\n\n  # All values that are not equal to given value.\n  m1ID_not: String\n\n  # All values that are contained in given list.\n  m1ID_in: [String!]\n\n  # All values that are not contained in given list.\n  m1ID_not_in: [String!]\n\n  # All values less than the given value.\n  m1ID_lt: String\n\n  # All values less than or equal the given value.\n  m1ID_lte: String\n\n  # All values greater than the given value.\n  m1ID_gt: String\n\n  # All values greater than or equal the given value.\n  m1ID_gte: String\n\n  # All values containing the given string.\n  m1ID_contains: String\n\n  # All values not containing the given string.\n  m1ID_not_contains: String\n\n  # All values starting with the given string.\n  m1ID_starts_with: String\n\n  # All values not starting with the given string.\n  m1ID_not_starts_with: String\n\n  # All values ending with the given string.\n  m1ID_ends_with: String\n\n  # All values not ending with the given string.\n  m1ID_not_ends_with: String\n  busType: String\n\n  # All values that are not equal to given value.\n  busType_not: String\n\n  # All values that are contained in given list.\n  busType_in: [String!]\n\n  # All values that are not contained in given list.\n  busType_not_in: [String!]\n\n  # All values less than the given value.\n  busType_lt: String\n\n  # All values less than or equal the given value.\n  busType_lte: String\n\n  # All values greater than the given value.\n  busType_gt: String\n\n  # All values greater than or equal the given value.\n  busType_gte: String\n\n  # All values containing the given string.\n  busType_contains: String\n\n  # All values not containing the given string.\n  busType_not_contains: String\n\n  # All values starting with the given string.\n  busType_starts_with: String\n\n  # All values not starting with the given string.\n  busType_not_starts_with: String\n\n  # All values ending with the given string.\n  busType_ends_with: String\n\n  # All values not ending with the given string.\n  busType_not_ends_with: String\n  maxCapacity: Float\n\n  # All values that are not equal to given value.\n  maxCapacity_not: Float\n\n  # All values that are contained in given list.\n  maxCapacity_in: [Float!]\n\n  # All values that are not contained in given list.\n  maxCapacity_not_in: [Float!]\n\n  # All values less than the given value.\n  maxCapacity_lt: Float\n\n  # All values less than or equal the given value.\n  maxCapacity_lte: Float\n\n  # All values greater than the given value.\n  maxCapacity_gt: Float\n\n  # All values greater than or equal the given value.\n  maxCapacity_gte: Float\n  direction: String\n\n  # All values that are not equal to given value.\n  direction_not: String\n\n  # All values that are contained in given list.\n  direction_in: [String!]\n\n  # All values that are not contained in given list.\n  direction_not_in: [String!]\n\n  # All values less than the given value.\n  direction_lt: String\n\n  # All values less than or equal the given value.\n  direction_lte: String\n\n  # All values greater than the given value.\n  direction_gt: String\n\n  # All values greater than or equal the given value.\n  direction_gte: String\n\n  # All values containing the given string.\n  direction_contains: String\n\n  # All values not containing the given string.\n  direction_not_contains: String\n\n  # All values starting with the given string.\n  direction_starts_with: String\n\n  # All values not starting with the given string.\n  direction_not_starts_with: String\n\n  # All values ending with the given string.\n  direction_ends_with: String\n\n  # All values not ending with the given string.\n  direction_not_ends_with: String\n  position: LocationWhereInput\n  passangers_every: UserWhereInput\n  passangers_some: UserWhereInput\n  passangers_none: UserWhereInput\n  arrivingTo_every: ArrivingToWhereInput\n  arrivingTo_some: ArrivingToWhereInput\n  arrivingTo_none: ArrivingToWhereInput\n  locations_every: BusLocationWhereInput\n  locations_some: BusLocationWhereInput\n  locations_none: BusLocationWhereInput\n}\n\ninput BusWhereUniqueInput {\n  id: UUID\n  m1ID: String\n}\n\nscalar DateTime\n\ntype Location {\n  latitude: Float!\n  longitude: Float!\n}\n\n# A connection to a list of items.\ntype LocationConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [LocationEdge]!\n  aggregate: AggregateLocation!\n}\n\ninput LocationCreateInput {\n  latitude: Float!\n  longitude: Float!\n}\n\ninput LocationCreateOneInput {\n  create: LocationCreateInput\n}\n\n# An edge in a connection.\ntype LocationEdge {\n  # The item at the end of the edge.\n  node: Location!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum LocationOrderByInput {\n  latitude_ASC\n  latitude_DESC\n  longitude_ASC\n  longitude_DESC\n  id_ASC\n  id_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype LocationPreviousValues {\n  latitude: Float!\n  longitude: Float!\n}\n\ntype LocationSubscriptionPayload {\n  mutation: MutationType!\n  node: Location\n  updatedFields: [String!]\n  previousValues: LocationPreviousValues\n}\n\ninput LocationSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [LocationSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [LocationSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [LocationSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: LocationWhereInput\n}\n\ninput LocationUpdateDataInput {\n  latitude: Float\n  longitude: Float\n}\n\ninput LocationUpdateInput {\n  latitude: Float\n  longitude: Float\n}\n\ninput LocationUpdateOneInput {\n  create: LocationCreateInput\n  delete: Boolean\n  update: LocationUpdateDataInput\n  upsert: LocationUpsertNestedInput\n}\n\ninput LocationUpsertNestedInput {\n  update: LocationUpdateDataInput!\n  create: LocationCreateInput!\n}\n\ninput LocationWhereInput {\n  # Logical AND on all given filters.\n  AND: [LocationWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [LocationWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [LocationWhereInput!]\n  latitude: Float\n\n  # All values that are not equal to given value.\n  latitude_not: Float\n\n  # All values that are contained in given list.\n  latitude_in: [Float!]\n\n  # All values that are not contained in given list.\n  latitude_not_in: [Float!]\n\n  # All values less than the given value.\n  latitude_lt: Float\n\n  # All values less than or equal the given value.\n  latitude_lte: Float\n\n  # All values greater than the given value.\n  latitude_gt: Float\n\n  # All values greater than or equal the given value.\n  latitude_gte: Float\n  longitude: Float\n\n  # All values that are not equal to given value.\n  longitude_not: Float\n\n  # All values that are contained in given list.\n  longitude_in: [Float!]\n\n  # All values that are not contained in given list.\n  longitude_not_in: [Float!]\n\n  # All values less than the given value.\n  longitude_lt: Float\n\n  # All values less than or equal the given value.\n  longitude_lte: Float\n\n  # All values greater than the given value.\n  longitude_gt: Float\n\n  # All values greater than or equal the given value.\n  longitude_gte: Float\n}\n\n# The `Long` scalar type represents non-fractional signed whole numeric values.\n# Long can represent values between -(2^63) and 2^63 - 1.\nscalar Long\n\ntype Mutation {\n  createPoint(data: PointCreateInput!): Point!\n  createRoute(data: RouteCreateInput!): Route!\n  createUser(data: UserCreateInput!): User!\n  createBusLocation(data: BusLocationCreateInput!): BusLocation!\n  createBus(data: BusCreateInput!): Bus!\n  createAsignedRoute(data: AsignedRouteCreateInput!): AsignedRoute!\n  createPlannedExit(data: PlannedExitCreateInput!): PlannedExit!\n  createStop(data: StopCreateInput!): Stop!\n  createLocation(data: LocationCreateInput!): Location!\n  createArrivingTo(data: ArrivingToCreateInput!): ArrivingTo!\n  updatePoint(data: PointUpdateInput!, where: PointWhereUniqueInput!): Point\n  updateRoute(data: RouteUpdateInput!, where: RouteWhereUniqueInput!): Route\n  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User\n  updateBusLocation(data: BusLocationUpdateInput!, where: BusLocationWhereUniqueInput!): BusLocation\n  updateBus(data: BusUpdateInput!, where: BusWhereUniqueInput!): Bus\n  updateAsignedRoute(data: AsignedRouteUpdateInput!, where: AsignedRouteWhereUniqueInput!): AsignedRoute\n  updatePlannedExit(data: PlannedExitUpdateInput!, where: PlannedExitWhereUniqueInput!): PlannedExit\n  updateStop(data: StopUpdateInput!, where: StopWhereUniqueInput!): Stop\n  updateArrivingTo(data: ArrivingToUpdateInput!, where: ArrivingToWhereUniqueInput!): ArrivingTo\n  deletePoint(where: PointWhereUniqueInput!): Point\n  deleteRoute(where: RouteWhereUniqueInput!): Route\n  deleteUser(where: UserWhereUniqueInput!): User\n  deleteBusLocation(where: BusLocationWhereUniqueInput!): BusLocation\n  deleteBus(where: BusWhereUniqueInput!): Bus\n  deleteAsignedRoute(where: AsignedRouteWhereUniqueInput!): AsignedRoute\n  deletePlannedExit(where: PlannedExitWhereUniqueInput!): PlannedExit\n  deleteStop(where: StopWhereUniqueInput!): Stop\n  deleteArrivingTo(where: ArrivingToWhereUniqueInput!): ArrivingTo\n  upsertPoint(where: PointWhereUniqueInput!, create: PointCreateInput!, update: PointUpdateInput!): Point!\n  upsertRoute(where: RouteWhereUniqueInput!, create: RouteCreateInput!, update: RouteUpdateInput!): Route!\n  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!\n  upsertBusLocation(where: BusLocationWhereUniqueInput!, create: BusLocationCreateInput!, update: BusLocationUpdateInput!): BusLocation!\n  upsertBus(where: BusWhereUniqueInput!, create: BusCreateInput!, update: BusUpdateInput!): Bus!\n  upsertAsignedRoute(where: AsignedRouteWhereUniqueInput!, create: AsignedRouteCreateInput!, update: AsignedRouteUpdateInput!): AsignedRoute!\n  upsertPlannedExit(where: PlannedExitWhereUniqueInput!, create: PlannedExitCreateInput!, update: PlannedExitUpdateInput!): PlannedExit!\n  upsertStop(where: StopWhereUniqueInput!, create: StopCreateInput!, update: StopUpdateInput!): Stop!\n  upsertArrivingTo(where: ArrivingToWhereUniqueInput!, create: ArrivingToCreateInput!, update: ArrivingToUpdateInput!): ArrivingTo!\n  updateManyPoints(data: PointUpdateInput!, where: PointWhereInput): BatchPayload!\n  updateManyRoutes(data: RouteUpdateInput!, where: RouteWhereInput): BatchPayload!\n  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput): BatchPayload!\n  updateManyBusLocations(data: BusLocationUpdateInput!, where: BusLocationWhereInput): BatchPayload!\n  updateManyBuses(data: BusUpdateInput!, where: BusWhereInput): BatchPayload!\n  updateManyAsignedRoutes(data: AsignedRouteUpdateInput!, where: AsignedRouteWhereInput): BatchPayload!\n  updateManyPlannedExits(data: PlannedExitUpdateInput!, where: PlannedExitWhereInput): BatchPayload!\n  updateManyStops(data: StopUpdateInput!, where: StopWhereInput): BatchPayload!\n  updateManyLocations(data: LocationUpdateInput!, where: LocationWhereInput): BatchPayload!\n  updateManyArrivingToes(data: ArrivingToUpdateInput!, where: ArrivingToWhereInput): BatchPayload!\n  deleteManyPoints(where: PointWhereInput): BatchPayload!\n  deleteManyRoutes(where: RouteWhereInput): BatchPayload!\n  deleteManyUsers(where: UserWhereInput): BatchPayload!\n  deleteManyBusLocations(where: BusLocationWhereInput): BatchPayload!\n  deleteManyBuses(where: BusWhereInput): BatchPayload!\n  deleteManyAsignedRoutes(where: AsignedRouteWhereInput): BatchPayload!\n  deleteManyPlannedExits(where: PlannedExitWhereInput): BatchPayload!\n  deleteManyStops(where: StopWhereInput): BatchPayload!\n  deleteManyLocations(where: LocationWhereInput): BatchPayload!\n  deleteManyArrivingToes(where: ArrivingToWhereInput): BatchPayload!\n}\n\nenum MutationType {\n  CREATED\n  UPDATED\n  DELETED\n}\n\n# An object with an ID\ninterface Node {\n  # The id of the object.\n  id: ID!\n}\n\n# Information about pagination in a connection.\ntype PageInfo {\n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean!\n\n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean!\n\n  # When paginating backwards, the cursor to continue.\n  startCursor: String\n\n  # When paginating forwards, the cursor to continue.\n  endCursor: String\n}\n\ntype PlannedExit {\n  id: UUID!\n  time: DateTime!\n  operator: UUID!\n}\n\n# A connection to a list of items.\ntype PlannedExitConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [PlannedExitEdge]!\n  aggregate: AggregatePlannedExit!\n}\n\ninput PlannedExitCreateInput {\n  time: DateTime!\n  operator: UUID!\n}\n\n# An edge in a connection.\ntype PlannedExitEdge {\n  # The item at the end of the edge.\n  node: PlannedExit!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum PlannedExitOrderByInput {\n  id_ASC\n  id_DESC\n  time_ASC\n  time_DESC\n  operator_ASC\n  operator_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype PlannedExitPreviousValues {\n  id: UUID!\n  time: DateTime!\n  operator: UUID!\n}\n\ntype PlannedExitSubscriptionPayload {\n  mutation: MutationType!\n  node: PlannedExit\n  updatedFields: [String!]\n  previousValues: PlannedExitPreviousValues\n}\n\ninput PlannedExitSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [PlannedExitSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [PlannedExitSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [PlannedExitSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: PlannedExitWhereInput\n}\n\ninput PlannedExitUpdateInput {\n  time: DateTime\n  operator: UUID\n}\n\ninput PlannedExitWhereInput {\n  # Logical AND on all given filters.\n  AND: [PlannedExitWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [PlannedExitWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [PlannedExitWhereInput!]\n  time: DateTime\n\n  # All values that are not equal to given value.\n  time_not: DateTime\n\n  # All values that are contained in given list.\n  time_in: [DateTime!]\n\n  # All values that are not contained in given list.\n  time_not_in: [DateTime!]\n\n  # All values less than the given value.\n  time_lt: DateTime\n\n  # All values less than or equal the given value.\n  time_lte: DateTime\n\n  # All values greater than the given value.\n  time_gt: DateTime\n\n  # All values greater than or equal the given value.\n  time_gte: DateTime\n}\n\ninput PlannedExitWhereUniqueInput {\n  id: UUID\n}\n\ntype Point {\n  id: UUID!\n  position(where: RouteWhereInput): Route!\n}\n\n# A connection to a list of items.\ntype PointConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [PointEdge]!\n  aggregate: AggregatePoint!\n}\n\ninput PointCreateInput {\n  position: RouteCreateOneWithoutPointsInput!\n}\n\ninput PointCreateManyWithoutPositionInput {\n  connect: [PointWhereUniqueInput!]\n}\n\n# An edge in a connection.\ntype PointEdge {\n  # The item at the end of the edge.\n  node: Point!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum PointOrderByInput {\n  id_ASC\n  id_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype PointPreviousValues {\n  id: UUID!\n}\n\ntype PointSubscriptionPayload {\n  mutation: MutationType!\n  node: Point\n  updatedFields: [String!]\n  previousValues: PointPreviousValues\n}\n\ninput PointSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [PointSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [PointSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [PointSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: PointWhereInput\n}\n\ninput PointUpdateInput {\n  position: RouteUpdateOneWithoutPointsInput\n}\n\ninput PointUpdateManyWithoutPositionInput {\n  connect: [PointWhereUniqueInput!]\n  disconnect: [PointWhereUniqueInput!]\n  delete: [PointWhereUniqueInput!]\n}\n\ninput PointWhereInput {\n  # Logical AND on all given filters.\n  AND: [PointWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [PointWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [PointWhereInput!]\n  position: RouteWhereInput\n}\n\ninput PointWhereUniqueInput {\n  id: UUID\n}\n\ntype Query {\n  points(where: PointWhereInput, orderBy: PointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Point]!\n  routes(where: RouteWhereInput, orderBy: RouteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Route]!\n  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!\n  busLocations(where: BusLocationWhereInput, orderBy: BusLocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BusLocation]!\n  buses(where: BusWhereInput, orderBy: BusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bus]!\n  asignedRoutes(where: AsignedRouteWhereInput, orderBy: AsignedRouteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AsignedRoute]!\n  plannedExits(where: PlannedExitWhereInput, orderBy: PlannedExitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PlannedExit]!\n  stops(where: StopWhereInput, orderBy: StopOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stop]!\n  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!\n  arrivingToes(where: ArrivingToWhereInput, orderBy: ArrivingToOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ArrivingTo]!\n  point(where: PointWhereUniqueInput!): Point\n  route(where: RouteWhereUniqueInput!): Route\n  user(where: UserWhereUniqueInput!): User\n  busLocation(where: BusLocationWhereUniqueInput!): BusLocation\n  bus(where: BusWhereUniqueInput!): Bus\n  asignedRoute(where: AsignedRouteWhereUniqueInput!): AsignedRoute\n  plannedExit(where: PlannedExitWhereUniqueInput!): PlannedExit\n  stop(where: StopWhereUniqueInput!): Stop\n  arrivingTo(where: ArrivingToWhereUniqueInput!): ArrivingTo\n  pointsConnection(where: PointWhereInput, orderBy: PointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PointConnection!\n  routesConnection(where: RouteWhereInput, orderBy: RouteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RouteConnection!\n  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!\n  busLocationsConnection(where: BusLocationWhereInput, orderBy: BusLocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BusLocationConnection!\n  busesConnection(where: BusWhereInput, orderBy: BusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BusConnection!\n  asignedRoutesConnection(where: AsignedRouteWhereInput, orderBy: AsignedRouteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AsignedRouteConnection!\n  plannedExitsConnection(where: PlannedExitWhereInput, orderBy: PlannedExitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlannedExitConnection!\n  stopsConnection(where: StopWhereInput, orderBy: StopOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StopConnection!\n  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!\n  arrivingToesConnection(where: ArrivingToWhereInput, orderBy: ArrivingToOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ArrivingToConnection!\n\n  # Fetches an object given its ID\n  node(\n    # The ID of an object\n    id: ID!\n  ): Node\n}\n\ntype Route {\n  id: UUID!\n  m1ID: String!\n  points(where: PointWhereInput, orderBy: PointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Point!]\n  stops(where: StopWhereInput, orderBy: StopOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stop!]\n  buses(where: ArrivingToWhereInput, orderBy: ArrivingToOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ArrivingTo!]\n}\n\n# A connection to a list of items.\ntype RouteConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [RouteEdge]!\n  aggregate: AggregateRoute!\n}\n\ninput RouteCreateInput {\n  m1ID: String!\n  points: PointCreateManyWithoutPositionInput\n  stops: StopCreateManyWithoutRouteInput\n  buses: ArrivingToCreateManyInput\n}\n\ninput RouteCreateOneWithoutPointsInput {\n  create: RouteCreateWithoutPointsInput\n  connect: RouteWhereUniqueInput\n}\n\ninput RouteCreateOneWithoutStopsInput {\n  create: RouteCreateWithoutStopsInput\n  connect: RouteWhereUniqueInput\n}\n\ninput RouteCreateWithoutPointsInput {\n  m1ID: String!\n  stops: StopCreateManyWithoutRouteInput\n  buses: ArrivingToCreateManyInput\n}\n\ninput RouteCreateWithoutStopsInput {\n  m1ID: String!\n  points: PointCreateManyWithoutPositionInput\n  buses: ArrivingToCreateManyInput\n}\n\n# An edge in a connection.\ntype RouteEdge {\n  # The item at the end of the edge.\n  node: Route!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum RouteOrderByInput {\n  id_ASC\n  id_DESC\n  m1ID_ASC\n  m1ID_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype RoutePreviousValues {\n  id: UUID!\n  m1ID: String!\n}\n\ntype RouteSubscriptionPayload {\n  mutation: MutationType!\n  node: Route\n  updatedFields: [String!]\n  previousValues: RoutePreviousValues\n}\n\ninput RouteSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [RouteSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [RouteSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [RouteSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: RouteWhereInput\n}\n\ninput RouteUpdateInput {\n  m1ID: String\n  points: PointUpdateManyWithoutPositionInput\n  stops: StopUpdateManyWithoutRouteInput\n  buses: ArrivingToUpdateManyInput\n}\n\ninput RouteUpdateOneWithoutPointsInput {\n  create: RouteCreateWithoutPointsInput\n  connect: RouteWhereUniqueInput\n  delete: Boolean\n  update: RouteUpdateWithoutPointsDataInput\n  upsert: RouteUpsertWithoutPointsInput\n}\n\ninput RouteUpdateOneWithoutStopsInput {\n  create: RouteCreateWithoutStopsInput\n  connect: RouteWhereUniqueInput\n  delete: Boolean\n  update: RouteUpdateWithoutStopsDataInput\n  upsert: RouteUpsertWithoutStopsInput\n}\n\ninput RouteUpdateWithoutPointsDataInput {\n  m1ID: String\n  stops: StopUpdateManyWithoutRouteInput\n  buses: ArrivingToUpdateManyInput\n}\n\ninput RouteUpdateWithoutStopsDataInput {\n  m1ID: String\n  points: PointUpdateManyWithoutPositionInput\n  buses: ArrivingToUpdateManyInput\n}\n\ninput RouteUpsertWithoutPointsInput {\n  update: RouteUpdateWithoutPointsDataInput!\n  create: RouteCreateWithoutPointsInput!\n}\n\ninput RouteUpsertWithoutStopsInput {\n  update: RouteUpdateWithoutStopsDataInput!\n  create: RouteCreateWithoutStopsInput!\n}\n\ninput RouteWhereInput {\n  # Logical AND on all given filters.\n  AND: [RouteWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [RouteWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [RouteWhereInput!]\n  m1ID: String\n\n  # All values that are not equal to given value.\n  m1ID_not: String\n\n  # All values that are contained in given list.\n  m1ID_in: [String!]\n\n  # All values that are not contained in given list.\n  m1ID_not_in: [String!]\n\n  # All values less than the given value.\n  m1ID_lt: String\n\n  # All values less than or equal the given value.\n  m1ID_lte: String\n\n  # All values greater than the given value.\n  m1ID_gt: String\n\n  # All values greater than or equal the given value.\n  m1ID_gte: String\n\n  # All values containing the given string.\n  m1ID_contains: String\n\n  # All values not containing the given string.\n  m1ID_not_contains: String\n\n  # All values starting with the given string.\n  m1ID_starts_with: String\n\n  # All values not starting with the given string.\n  m1ID_not_starts_with: String\n\n  # All values ending with the given string.\n  m1ID_ends_with: String\n\n  # All values not ending with the given string.\n  m1ID_not_ends_with: String\n  points_every: PointWhereInput\n  points_some: PointWhereInput\n  points_none: PointWhereInput\n  stops_every: StopWhereInput\n  stops_some: StopWhereInput\n  stops_none: StopWhereInput\n  buses_every: ArrivingToWhereInput\n  buses_some: ArrivingToWhereInput\n  buses_none: ArrivingToWhereInput\n}\n\ninput RouteWhereUniqueInput {\n  id: UUID\n  m1ID: String\n}\n\ntype Stop {\n  id: UUID!\n  position(where: LocationWhereInput): Location!\n  m1ID: String!\n  onComing(where: ArrivingToWhereInput, orderBy: ArrivingToOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ArrivingTo!]\n  route(where: RouteWhereInput): Route!\n  displayName: String\n}\n\n# A connection to a list of items.\ntype StopConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [StopEdge]!\n  aggregate: AggregateStop!\n}\n\ninput StopCreateInput {\n  m1ID: String!\n  displayName: String\n  position: LocationCreateOneInput!\n  onComing: ArrivingToCreateManyWithoutStopInput\n  route: RouteCreateOneWithoutStopsInput!\n}\n\ninput StopCreateManyWithoutRouteInput {\n  create: [StopCreateWithoutRouteInput!]\n  connect: [StopWhereUniqueInput!]\n}\n\ninput StopCreateOneWithoutOnComingInput {\n  create: StopCreateWithoutOnComingInput\n  connect: StopWhereUniqueInput\n}\n\ninput StopCreateWithoutOnComingInput {\n  m1ID: String!\n  displayName: String\n  position: LocationCreateOneInput!\n  route: RouteCreateOneWithoutStopsInput!\n}\n\ninput StopCreateWithoutRouteInput {\n  m1ID: String!\n  displayName: String\n  position: LocationCreateOneInput!\n  onComing: ArrivingToCreateManyWithoutStopInput\n}\n\n# An edge in a connection.\ntype StopEdge {\n  # The item at the end of the edge.\n  node: Stop!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum StopOrderByInput {\n  id_ASC\n  id_DESC\n  m1ID_ASC\n  m1ID_DESC\n  displayName_ASC\n  displayName_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype StopPreviousValues {\n  id: UUID!\n  m1ID: String!\n  displayName: String\n}\n\ntype StopSubscriptionPayload {\n  mutation: MutationType!\n  node: Stop\n  updatedFields: [String!]\n  previousValues: StopPreviousValues\n}\n\ninput StopSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [StopSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [StopSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [StopSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: StopWhereInput\n}\n\ninput StopUpdateInput {\n  m1ID: String\n  displayName: String\n  position: LocationUpdateOneInput\n  onComing: ArrivingToUpdateManyWithoutStopInput\n  route: RouteUpdateOneWithoutStopsInput\n}\n\ninput StopUpdateManyWithoutRouteInput {\n  create: [StopCreateWithoutRouteInput!]\n  connect: [StopWhereUniqueInput!]\n  disconnect: [StopWhereUniqueInput!]\n  delete: [StopWhereUniqueInput!]\n  update: [StopUpdateWithWhereUniqueWithoutRouteInput!]\n  upsert: [StopUpsertWithWhereUniqueWithoutRouteInput!]\n}\n\ninput StopUpdateOneWithoutOnComingInput {\n  create: StopCreateWithoutOnComingInput\n  connect: StopWhereUniqueInput\n  delete: Boolean\n  update: StopUpdateWithoutOnComingDataInput\n  upsert: StopUpsertWithoutOnComingInput\n}\n\ninput StopUpdateWithoutOnComingDataInput {\n  m1ID: String\n  displayName: String\n  position: LocationUpdateOneInput\n  route: RouteUpdateOneWithoutStopsInput\n}\n\ninput StopUpdateWithoutRouteDataInput {\n  m1ID: String\n  displayName: String\n  position: LocationUpdateOneInput\n  onComing: ArrivingToUpdateManyWithoutStopInput\n}\n\ninput StopUpdateWithWhereUniqueWithoutRouteInput {\n  where: StopWhereUniqueInput!\n  data: StopUpdateWithoutRouteDataInput!\n}\n\ninput StopUpsertWithoutOnComingInput {\n  update: StopUpdateWithoutOnComingDataInput!\n  create: StopCreateWithoutOnComingInput!\n}\n\ninput StopUpsertWithWhereUniqueWithoutRouteInput {\n  where: StopWhereUniqueInput!\n  update: StopUpdateWithoutRouteDataInput!\n  create: StopCreateWithoutRouteInput!\n}\n\ninput StopWhereInput {\n  # Logical AND on all given filters.\n  AND: [StopWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [StopWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [StopWhereInput!]\n  m1ID: String\n\n  # All values that are not equal to given value.\n  m1ID_not: String\n\n  # All values that are contained in given list.\n  m1ID_in: [String!]\n\n  # All values that are not contained in given list.\n  m1ID_not_in: [String!]\n\n  # All values less than the given value.\n  m1ID_lt: String\n\n  # All values less than or equal the given value.\n  m1ID_lte: String\n\n  # All values greater than the given value.\n  m1ID_gt: String\n\n  # All values greater than or equal the given value.\n  m1ID_gte: String\n\n  # All values containing the given string.\n  m1ID_contains: String\n\n  # All values not containing the given string.\n  m1ID_not_contains: String\n\n  # All values starting with the given string.\n  m1ID_starts_with: String\n\n  # All values not starting with the given string.\n  m1ID_not_starts_with: String\n\n  # All values ending with the given string.\n  m1ID_ends_with: String\n\n  # All values not ending with the given string.\n  m1ID_not_ends_with: String\n  displayName: String\n\n  # All values that are not equal to given value.\n  displayName_not: String\n\n  # All values that are contained in given list.\n  displayName_in: [String!]\n\n  # All values that are not contained in given list.\n  displayName_not_in: [String!]\n\n  # All values less than the given value.\n  displayName_lt: String\n\n  # All values less than or equal the given value.\n  displayName_lte: String\n\n  # All values greater than the given value.\n  displayName_gt: String\n\n  # All values greater than or equal the given value.\n  displayName_gte: String\n\n  # All values containing the given string.\n  displayName_contains: String\n\n  # All values not containing the given string.\n  displayName_not_contains: String\n\n  # All values starting with the given string.\n  displayName_starts_with: String\n\n  # All values not starting with the given string.\n  displayName_not_starts_with: String\n\n  # All values ending with the given string.\n  displayName_ends_with: String\n\n  # All values not ending with the given string.\n  displayName_not_ends_with: String\n  position: LocationWhereInput\n  onComing_every: ArrivingToWhereInput\n  onComing_some: ArrivingToWhereInput\n  onComing_none: ArrivingToWhereInput\n  route: RouteWhereInput\n}\n\ninput StopWhereUniqueInput {\n  id: UUID\n  m1ID: String\n}\n\ntype Subscription {\n  point(where: PointSubscriptionWhereInput): PointSubscriptionPayload\n  route(where: RouteSubscriptionWhereInput): RouteSubscriptionPayload\n  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload\n  busLocation(where: BusLocationSubscriptionWhereInput): BusLocationSubscriptionPayload\n  bus(where: BusSubscriptionWhereInput): BusSubscriptionPayload\n  asignedRoute(where: AsignedRouteSubscriptionWhereInput): AsignedRouteSubscriptionPayload\n  plannedExit(where: PlannedExitSubscriptionWhereInput): PlannedExitSubscriptionPayload\n  stop(where: StopSubscriptionWhereInput): StopSubscriptionPayload\n  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload\n  arrivingTo(where: ArrivingToSubscriptionWhereInput): ArrivingToSubscriptionPayload\n}\n\ntype User {\n  id: UUID!\n  position(where: LocationWhereInput): Location!\n  onBus(where: BusWhereInput): Bus\n}\n\n# A connection to a list of items.\ntype UserConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # A list of edges.\n  edges: [UserEdge]!\n  aggregate: AggregateUser!\n}\n\ninput UserCreateInput {\n  position: LocationCreateOneInput!\n  onBus: BusCreateOneWithoutPassangersInput\n}\n\ninput UserCreateManyWithoutOnBusInput {\n  create: [UserCreateWithoutOnBusInput!]\n  connect: [UserWhereUniqueInput!]\n}\n\ninput UserCreateWithoutOnBusInput {\n  position: LocationCreateOneInput!\n}\n\n# An edge in a connection.\ntype UserEdge {\n  # The item at the end of the edge.\n  node: User!\n\n  # A cursor for use in pagination.\n  cursor: String!\n}\n\nenum UserOrderByInput {\n  id_ASC\n  id_DESC\n  updatedAt_ASC\n  updatedAt_DESC\n  createdAt_ASC\n  createdAt_DESC\n}\n\ntype UserPreviousValues {\n  id: UUID!\n}\n\ntype UserSubscriptionPayload {\n  mutation: MutationType!\n  node: User\n  updatedFields: [String!]\n  previousValues: UserPreviousValues\n}\n\ninput UserSubscriptionWhereInput {\n  # Logical AND on all given filters.\n  AND: [UserSubscriptionWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [UserSubscriptionWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [UserSubscriptionWhereInput!]\n\n  # The subscription event gets dispatched when it's listed in mutation_in\n  mutation_in: [MutationType!]\n\n  # The subscription event gets only dispatched when one of the updated fields names is included in this list\n  updatedFields_contains: String\n\n  # The subscription event gets only dispatched when all of the field names included in this list have been updated\n  updatedFields_contains_every: [String!]\n\n  # The subscription event gets only dispatched when some of the field names included in this list have been updated\n  updatedFields_contains_some: [String!]\n  node: UserWhereInput\n}\n\ninput UserUpdateInput {\n  position: LocationUpdateOneInput\n  onBus: BusUpdateOneWithoutPassangersInput\n}\n\ninput UserUpdateManyWithoutOnBusInput {\n  create: [UserCreateWithoutOnBusInput!]\n  connect: [UserWhereUniqueInput!]\n  disconnect: [UserWhereUniqueInput!]\n  delete: [UserWhereUniqueInput!]\n  update: [UserUpdateWithWhereUniqueWithoutOnBusInput!]\n  upsert: [UserUpsertWithWhereUniqueWithoutOnBusInput!]\n}\n\ninput UserUpdateWithoutOnBusDataInput {\n  position: LocationUpdateOneInput\n}\n\ninput UserUpdateWithWhereUniqueWithoutOnBusInput {\n  where: UserWhereUniqueInput!\n  data: UserUpdateWithoutOnBusDataInput!\n}\n\ninput UserUpsertWithWhereUniqueWithoutOnBusInput {\n  where: UserWhereUniqueInput!\n  update: UserUpdateWithoutOnBusDataInput!\n  create: UserCreateWithoutOnBusInput!\n}\n\ninput UserWhereInput {\n  # Logical AND on all given filters.\n  AND: [UserWhereInput!]\n\n  # Logical OR on all given filters.\n  OR: [UserWhereInput!]\n\n  # Logical NOT on all given filters combined by AND.\n  NOT: [UserWhereInput!]\n  position: LocationWhereInput\n  onBus: BusWhereInput\n}\n\ninput UserWhereUniqueInput {\n  id: UUID\n}\n\n# A type 4 UUID according to IETF RFC 4122.\nscalar UUID\n\n",
      "containsQueryType": true,
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 65,
      "containsCycle": true,
      "numDefinitions": 202
    }
  ],
  "metrics": {
    "created_at": "2017-11-22T23:55:51Z",
    "updated_at": "2019-07-11T14:14:52Z",
    "pushed_at": "2019-07-09T04:07:11Z",
    "issues": 27,
    "watchers": 7,
    "fork_count": 0,
    "has_wiki_enabled": true,
    "license": "mit",
    "pull_requests": 16,
    "pull_requests_open": 0,
    "pull_requests_closed": 0,
    "pull_requests_merged": 16,
    "releases": 0,
    "stargazers": 4
  }
}