{
  "repo_name": "checkin2",
  "repo_full_name": "hackgt/checkin2",
  "repo_owner": "HackGT",
  "repo_description": "Simple and robust check in system for hackathons and other events. Integrates with HackGT/registration",
  "repo_private": false,
  "repo_fork": false,
  "schemas": [
    {
      "name": "api.graphql",
      "path": "api.graphql",
      "sha": "f1ad89b1404673eb4be1502f81cdeca49424b4d6",
      "url": "https://api.github.com/repositories/78793790/contents/api.graphql?ref=a9a3cf4f28991c606bac6a48f436500742925fd9",
      "git_url": "https://api.github.com/repositories/78793790/git/blobs/f1ad89b1404673eb4be1502f81cdeca49424b4d6",
      "html_url": "https://github.com/HackGT/checkin2/blob/a9a3cf4f28991c606bac6a48f436500742925fd9/api.graphql",
      "content": "schema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription,\n}\n\n# The root mutation type, use it to change things\ntype Mutation {\n  # Check-in or check-out a user by specifying the tag name.  Check-in when checkin is set to true; check-out when checkin is set to false\n  check_in(user: ID!, tag: String!, checkin: Boolean!): UserAndTags\n  # Add tag to all users\n  add_tag(tag: String!, start: String, end: String, warnOnDuplicates: Boolean = false): Tag\n}\n\n# The root query type, use to query data\ntype Query {\n  # Get a list of unique tags currently available to set.\n  # set only_current to true to only get events that are currently happening based on their start/end times\n  tags(only_current: Boolean): [Tag!]!\n  # Retrieve user through a user ID or through the token passed to\n  # Query. Leave id empty if you'd like to view the currently logged in\n  # user.\n  user(id: ID!): UserAndTags\n  # All the users in the database, useful for polling for new user information.\n  # This is paginated, n is the number of results, and pagination_token is the last ID\n  # seen from the latest page retrieved, if you want the first page leave this out.\n  users(pagination_token: ID, n: Int!, filter: UserFilter): [UserAndTags!]!\n  # Search through a user's name and email through regex\n  search_user_simple(search: String!, use_regex: Boolean = false, offset: Int!, n: Int!, filter: UserFilter): [UserAndTags!]!\n  # All possible application question branches\n  application_branches: [String!]!\n  # All possible confirmation question branches\n  confirmation_branches: [String!]!\n  # All possible question branches from all types!\n  question_branches: [String!]!\n  # All possible question names, or names of question in a branch\n  question_names(branch: String): [String!]\n  # Counts of checked in users per tag.\n  # Only includes tags that have at least one user checked in.\n  tag_counts(tags: [String!]): [TagData]!\n}\n\n# The root subscription type, all subscribes go through here\ntype Subscription {\n  tag_change: UserAndTags!\n}\n\ntype UserAndTags {\n  # Tags associated with a user\n  tags: [TagState!]!\n  # Registration info about the user\n  user: User!\n}\n\n# Information about checkin tags\ntype Tag {\n  # The unique name of the tag (not human label)\n  name: String!\n  # The start time of the event associated with the tag\n  start: String\n  # The end time of the event associated with the tag\n  end: String\n  # Whether to error on a repeated check in/out event for a user and this tag\n  warnOnDuplicates: Boolean\n}\n\n# Record of checked in / checked out activity\ntype TagDetail {\n  checked_in: Boolean!\n  # Date when attendee was checked in or out\n  checked_in_date: String!\n  # The username of the admin that checked thte attendee in or out\n  checked_in_by: String!\n  # Whether, at the time this checkin attempt was made, the operation was successful.  If false, the check-in\n  # attempt was rejected.  If true or the tag has warnOnDuplicates = true, the check-in request was accepted.\n  checkin_success: Boolean!\n}\n\ntype TagState {\n  tag: Tag!\n  checked_in: Boolean!\n  # If the tag has warnOnDuplicates = false, then this will always return true.  Otherwise, true indicates a valid check-in\n  # and false indicates a duplicate check-in event (e.g., trying to check-in a user for a tag they are already checked into).\n  checkin_success: Boolean!\n  # Date when the attendee was checked in\n  checked_in_date: String!\n  # The username of the admin that checked the attendee in\n  checked_in_by: String!\n  # Details object for the most recent successful check in/out\n  last_successful_checkin: TagDetail\n  # An array of previous checked in / checked out events\n  details: [TagDetail]!\n}\n\n# NOTE: Type names that forward to registration must match the type names\n# in the registration API itself for fragments to work currently.\n\n# Registration info about the user\ntype User {\n  # User ID, valid across the entire system\n  id: ID!\n\n  # User's full name\n  name: String!\n  # User's email\n  email: String!\n  # If the user's email is a verified email\n  email_verified: Boolean!\n\n  # If the user has applied to the event\n  applied: Boolean!\n  # If the user has been accepted to the event\n  accepted: Boolean!\n  # If the user has been accepted and notified of his or her acceptance\n  accepted_and_notified: Boolean!\n  # If the user has submitted a confirmation\n  confirmed: Boolean!\n  # A users assigned confirmation branch\n  confirmationBranch: String\n\n  # A users application phase answers\n  # null if user has not filled out this phase\n  application: Branch\n\n  # A users confirmation phase answers\n  # null if user has not filled out this phase\n  confirmation: Branch\n\n  # Get the answer to one of the questions asked of this user.\n  # If branch is not given, find this question name in any branch.\n  question(name: String!): FormItem\n\n  # Get the answer to multiple questions asked of this user, userful\n  # when the set of questions you want to receive is set by the user.\n  questions(names: [String!]!): [FormItem!]!\n\n  # What team, if any, is the user a part of?\n  team: Team\n  \n  # ID used for pagination\n  pagination_token: ID!\n}\n\n# Filter users by this criterea.\n# A value means to filter by that value, no value\n# means that filter will be ignored.\ninput UserFilter {\n  # If the user has applied to the event\n  applied: Boolean\n  # If the user has been accepted to the event\n  accepted: Boolean\n  # If the user has indicated that he or she is attending\n  confirmed: Boolean\n  # The type of application a user filled out (e.g. Mentor, Participant)\n  application_branch: String\n  # The type of confirmation a user filled out (e.g. Needs Reimbursement)\n  confirmation_branch: String\n}\n\n# A filled out form (application / confirmation form)\ntype Branch {\n  # What type of application did the user fill out (mentor, participant, etc.)\n  # when going through the form?\n  type: String!\n  # A key-value list of questions and answers from the confirmation application\n  data: [FormItem!]!\n  # Start of application as some RFC's date string\n  start_time: String\n  # Submit time of application as some RFC's date string\n  submit_time: String\n}\n\n# Application teams\ntype Team {\n  # ID of the Team\n  id: ID!\n}\n\n# Entries to various forms (application, confirmation, etc.)\ntype FormItem {\n  # Name of the question / form item\n  name: String!\n  # Type of form item (textbox, checkbox, phone no.)\n  type: String!\n  # Value (if just one string)\n  value: String\n  # Values (if many selections are applicable, like checkbox)\n  values: [String!]\n  # File if type contains a file\n  file: File\n}\n\n# Uploaded file\ntype File {\n  # The original name of the uploaded file\n  original_name: String!\n  # The file's encoding\n  encoding: String!\n  # The file's mimetype\n  mimetype: String!\n  # The path to the file in S3\n  path: String!\n  # The size of the file in bytes\n  size: Int!\n}\n\n# Aggregated count data for a tag\ntype TagData {\n  name: String!\n  # Count of checked in users\n  count: Int!\n}",
      "containsQueryType": true,
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 13,
      "containsCycle": false,
      "polynomialLevel": 3,
      "numDefinitions": 15
    }
  ],
  "metrics": {
    "created_at": "2017-01-12T22:45:00Z",
    "updated_at": "2019-07-19T18:51:40Z",
    "pushed_at": "2019-07-19T18:51:41Z",
    "issues": 37,
    "watchers": 8,
    "fork_count": 0,
    "has_wiki_enabled": true,
    "license": "mit",
    "pull_requests": 37,
    "pull_requests_open": 0,
    "pull_requests_closed": 5,
    "pull_requests_merged": 32,
    "releases": 0,
    "stargazers": 8
  }
}