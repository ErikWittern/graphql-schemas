{
  "repo_name": "discipuli-old",
  "repo_full_name": "enheit/discipuli-old",
  "repo_owner": "enheit",
  "repo_description": "The application to manage workflow between teachers and students",
  "repo_private": false,
  "repo_fork": false,
  "schemas": [
    {
      "name": "schema.graphql",
      "path": "schema.graphql",
      "sha": "f21465779b6e67f661102ed34f317d614359a380",
      "url": "https://api.github.com/repositories/115369664/contents/schema.graphql?ref=e2908eb1f4097190f2c2b4e55184d18092e5812c",
      "git_url": "https://api.github.com/repositories/115369664/git/blobs/f21465779b6e67f661102ed34f317d614359a380",
      "html_url": "https://github.com/enheit/discipuli-old/blob/e2908eb1f4097190f2c2b4e55184d18092e5812c/schema.graphql",
      "content": "# All input for the `authenticate` mutation.\ninput AuthenticateInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  email: String!\n  password: String!\n}\n\n# The output of our `authenticate` mutation.\ntype AuthenticatePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  jwtToken: JwtToken\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\ntype Course implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n  rowId: Int!\n  title: String!\n}\n\n# A condition to be used against `Course` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput CourseCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `title` field.\n  title: String\n}\n\n# An input for mutations affecting `Course`\ninput CourseInput {\n  rowId: Int\n  title: String!\n}\n\n# Represents an update to a `Course`. Fields that are set will be updated.\ninput CoursePatch {\n  rowId: Int\n  title: String\n}\n\n# A connection to a list of `Course` values.\ntype CoursesConnection {\n  # A list of `Course` objects.\n  nodes: [Course]!\n\n  # A list of edges which contains the `Course` and cursor to aid in pagination.\n  edges: [CoursesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Course` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Course` edge in the connection.\ntype CoursesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Course` at the end of the edge.\n  node: Course!\n}\n\n# Methods to use when ordering `Course`.\nenum CoursesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  TITLE_ASC\n  TITLE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n}\n\n# All input for the create `Course` mutation.\ninput CreateCourseInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Course` to be created by this mutation.\n  course: CourseInput!\n}\n\n# The output of our create `Course` mutation.\ntype CreateCoursePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Course` that was created by this mutation.\n  course: Course\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for the type. May be used by Relay 1.\n  courseEdge(\n    # The method to use when ordering `Course`.\n    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): CoursesEdge\n}\n\n# All input for the create `Person` mutation.\ninput CreatePersonInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Person` to be created by this mutation.\n  person: PersonInput!\n}\n\n# The output of our create `Person` mutation.\ntype CreatePersonPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Person` that was created by this mutation.\n  person: Person\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `Person`.\n  roleByRoleid: Role\n\n  # An edge for the type. May be used by Relay 1.\n  personEdge(\n    # The method to use when ordering `Person`.\n    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]\n  ): PeopleEdge\n}\n\n# All input for the create `Role` mutation.\ninput CreateRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Role` to be created by this mutation.\n  role: RoleInput!\n}\n\n# The output of our create `Role` mutation.\ntype CreateRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Role` that was created by this mutation.\n  role: Role\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for the type. May be used by Relay 1.\n  roleEdge(\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RolesEdge\n}\n\n# A location in a connection that can be used for resuming pagination.\nscalar Cursor\n\n# A point in time as described by the [ISO\n# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\nscalar Datetime\n\n# All input for the `deleteCourseByRowId` mutation.\ninput DeleteCourseByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  rowId: Int!\n}\n\n# All input for the `deleteCourse` mutation.\ninput DeleteCourseInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Course` to be deleted.\n  id: ID!\n}\n\n# The output of our delete `Course` mutation.\ntype DeleteCoursePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Course` that was deleted by this mutation.\n  course: Course\n  deletedCourseId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for the type. May be used by Relay 1.\n  courseEdge(\n    # The method to use when ordering `Course`.\n    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): CoursesEdge\n}\n\n# All input for the `deletePersonByRowId` mutation.\ninput DeletePersonByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  rowId: Int!\n}\n\n# All input for the `deletePerson` mutation.\ninput DeletePersonInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Person` to be deleted.\n  id: ID!\n}\n\n# The output of our delete `Person` mutation.\ntype DeletePersonPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Person` that was deleted by this mutation.\n  person: Person\n  deletedPersonId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `Person`.\n  roleByRoleid: Role\n\n  # An edge for the type. May be used by Relay 1.\n  personEdge(\n    # The method to use when ordering `Person`.\n    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]\n  ): PeopleEdge\n}\n\n# All input for the `deleteRoleByRowId` mutation.\ninput DeleteRoleByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  rowId: Int!\n}\n\n# All input for the `deleteRole` mutation.\ninput DeleteRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Role` to be deleted.\n  id: ID!\n}\n\n# The output of our delete `Role` mutation.\ntype DeleteRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Role` that was deleted by this mutation.\n  role: Role\n  deletedRoleId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for the type. May be used by Relay 1.\n  roleEdge(\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RolesEdge\n}\n\n# All input for the `genRandomBytes` mutation.\ninput GenRandomBytesInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  arg0: Int!\n}\n\n# The output of our `genRandomBytes` mutation.\ntype GenRandomBytesPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  string: String\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `genRandomUuid` mutation.\ninput GenRandomUuidInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n}\n\n# The output of our `genRandomUuid` mutation.\ntype GenRandomUuidPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  uuid: UUID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)\n# which securely represents claims between two parties.\nscalar JwtToken\n\n# The root mutation type which contains root level fields which mutate data.\ntype Mutation {\n  # Creates a single `Course`.\n  createCourse(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateCourseInput!\n  ): CreateCoursePayload\n\n  # Creates a single `Person`.\n  createPerson(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreatePersonInput!\n  ): CreatePersonPayload\n\n  # Creates a single `Role`.\n  createRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateRoleInput!\n  ): CreateRolePayload\n\n  # Updates a single `Course` using its globally unique id and a patch.\n  updateCourse(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateCourseInput!\n  ): UpdateCoursePayload\n\n  # Updates a single `Course` using a unique key and a patch.\n  updateCourseByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateCourseByRowIdInput!\n  ): UpdateCoursePayload\n\n  # Updates a single `Person` using its globally unique id and a patch.\n  updatePerson(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdatePersonInput!\n  ): UpdatePersonPayload\n\n  # Updates a single `Person` using a unique key and a patch.\n  updatePersonByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdatePersonByRowIdInput!\n  ): UpdatePersonPayload\n\n  # Updates a single `Role` using its globally unique id and a patch.\n  updateRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoleInput!\n  ): UpdateRolePayload\n\n  # Updates a single `Role` using a unique key and a patch.\n  updateRoleByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoleByRowIdInput!\n  ): UpdateRolePayload\n\n  # Deletes a single `Course` using its globally unique id.\n  deleteCourse(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteCourseInput!\n  ): DeleteCoursePayload\n\n  # Deletes a single `Course` using a unique key.\n  deleteCourseByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteCourseByRowIdInput!\n  ): DeleteCoursePayload\n\n  # Deletes a single `Person` using its globally unique id.\n  deletePerson(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeletePersonInput!\n  ): DeletePersonPayload\n\n  # Deletes a single `Person` using a unique key.\n  deletePersonByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeletePersonByRowIdInput!\n  ): DeletePersonPayload\n\n  # Deletes a single `Role` using its globally unique id.\n  deleteRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoleInput!\n  ): DeleteRolePayload\n\n  # Deletes a single `Role` using a unique key.\n  deleteRoleByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoleByRowIdInput!\n  ): DeleteRolePayload\n  authenticate(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: AuthenticateInput!\n  ): AuthenticatePayload\n  genRandomBytes(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: GenRandomBytesInput!\n  ): GenRandomBytesPayload\n  genRandomUuid(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: GenRandomUuidInput!\n  ): GenRandomUuidPayload\n  registerPerson(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: RegisterPersonInput!\n  ): RegisterPersonPayload\n}\n\n# An object with a globally unique `ID`.\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n}\n\n# Information about pagination in a connection.\ntype PageInfo {\n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean!\n\n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean!\n\n  # When paginating backwards, the cursor to continue.\n  startCursor: Cursor\n\n  # When paginating forwards, the cursor to continue.\n  endCursor: Cursor\n}\n\n# A connection to a list of `Person` values.\ntype PeopleConnection {\n  # A list of `Person` objects.\n  nodes: [Person]!\n\n  # A list of edges which contains the `Person` and cursor to aid in pagination.\n  edges: [PeopleEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Person` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Person` edge in the connection.\ntype PeopleEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Person` at the end of the edge.\n  node: Person!\n}\n\n# Methods to use when ordering `Person`.\nenum PeopleOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  FIRST_NAME_ASC\n  FIRST_NAME_DESC\n  LAST_NAME_ASC\n  LAST_NAME_DESC\n  ABOUT_ASC\n  ABOUT_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  ROLEID_ASC\n  ROLEID_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n}\n\ntype Person implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n  rowId: Int!\n  firstName: String!\n  lastName: String\n  about: String\n  createdAt: Datetime\n  roleid: Int\n\n  # Reads a single `Role` that is related to this `Person`.\n  roleByRoleid: Role\n}\n\n# A condition to be used against `Person` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput PersonCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `firstName` field.\n  firstName: String\n\n  # Checks for equality with the object’s `lastName` field.\n  lastName: String\n\n  # Checks for equality with the object’s `about` field.\n  about: String\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `roleid` field.\n  roleid: Int\n}\n\n# An input for mutations affecting `Person`\ninput PersonInput {\n  rowId: Int\n  firstName: String!\n  lastName: String\n  about: String\n  createdAt: Datetime\n  roleid: Int\n}\n\n# Represents an update to a `Person`. Fields that are set will be updated.\ninput PersonPatch {\n  rowId: Int\n  firstName: String\n  lastName: String\n  about: String\n  createdAt: Datetime\n  roleid: Int\n}\n\n# The root query type which gives access points into the data universe.\ntype Query implements Node {\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n\n  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\n  id: ID!\n\n  # Fetches an object given its globally unique `ID`.\n  node(\n    # The globally unique `ID`.\n    id: ID!\n  ): Node\n\n  # Reads and enables pagination through a set of `Course`.\n  allCourses(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Course`.\n    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CourseCondition\n  ): CoursesConnection\n\n  # Reads and enables pagination through a set of `Person`.\n  allPeople(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Person`.\n    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: PersonCondition\n  ): PeopleConnection\n\n  # Reads and enables pagination through a set of `Role`.\n  allRoles(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: RoleCondition\n  ): RolesConnection\n  courseByRowId(rowId: Int!): Course\n  personByRowId(rowId: Int!): Person\n  roleByRowId(rowId: Int!): Role\n  crypt(arg0: String!, arg1: String!): String\n  currentPerson: Person\n  currentUserId: Int\n  dearmor(arg0: String!): String\n  decrypt(arg0: String!, arg1: String!, arg2: String!): String\n  decryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String\n  encrypt(arg0: String!, arg1: String!, arg2: String!): String\n  encryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String\n  pgpKeyId(arg0: String!): String\n\n  # Reads a single `Course` using its globally unique `ID`.\n  course(\n    # The globally unique `ID` to be used in selecting a single `Course`.\n    id: ID!\n  ): Course\n\n  # Reads a single `Person` using its globally unique `ID`.\n  person(\n    # The globally unique `ID` to be used in selecting a single `Person`.\n    id: ID!\n  ): Person\n\n  # Reads a single `Role` using its globally unique `ID`.\n  role(\n    # The globally unique `ID` to be used in selecting a single `Role`.\n    id: ID!\n  ): Role\n}\n\n# All input for the `registerPerson` mutation.\ninput RegisterPersonInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  firstName: String!\n  lastName: String!\n  email: String!\n  password: String!\n  roleid: Int!\n}\n\n# The output of our `registerPerson` mutation.\ntype RegisterPersonPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  person: Person\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `Person`.\n  roleByRoleid: Role\n\n  # An edge for the type. May be used by Relay 1.\n  personEdge(\n    # The method to use when ordering `Person`.\n    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]\n  ): PeopleEdge\n}\n\ntype Role implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n  rowId: Int!\n  role: String\n\n  # Reads and enables pagination through a set of `Person`.\n  peopleByRoleid(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Person`.\n    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: PersonCondition\n  ): PeopleConnection!\n}\n\n# A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput RoleCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `role` field.\n  role: String\n}\n\n# An input for mutations affecting `Role`\ninput RoleInput {\n  rowId: Int!\n  role: String\n}\n\n# Represents an update to a `Role`. Fields that are set will be updated.\ninput RolePatch {\n  rowId: Int\n  role: String\n}\n\n# A connection to a list of `Role` values.\ntype RolesConnection {\n  # A list of `Role` objects.\n  nodes: [Role]!\n\n  # A list of edges which contains the `Role` and cursor to aid in pagination.\n  edges: [RolesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Role` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Role` edge in the connection.\ntype RolesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Role` at the end of the edge.\n  node: Role!\n}\n\n# Methods to use when ordering `Role`.\nenum RolesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  ROLE_ASC\n  ROLE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n}\n\n# All input for the `updateCourseByRowId` mutation.\ninput UpdateCourseByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Course` being updated.\n  coursePatch: CoursePatch!\n  rowId: Int!\n}\n\n# All input for the `updateCourse` mutation.\ninput UpdateCourseInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Course` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `Course` being updated.\n  coursePatch: CoursePatch!\n}\n\n# The output of our update `Course` mutation.\ntype UpdateCoursePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Course` that was updated by this mutation.\n  course: Course\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for the type. May be used by Relay 1.\n  courseEdge(\n    # The method to use when ordering `Course`.\n    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): CoursesEdge\n}\n\n# All input for the `updatePersonByRowId` mutation.\ninput UpdatePersonByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Person` being updated.\n  personPatch: PersonPatch!\n  rowId: Int!\n}\n\n# All input for the `updatePerson` mutation.\ninput UpdatePersonInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Person` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `Person` being updated.\n  personPatch: PersonPatch!\n}\n\n# The output of our update `Person` mutation.\ntype UpdatePersonPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Person` that was updated by this mutation.\n  person: Person\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `Person`.\n  roleByRoleid: Role\n\n  # An edge for the type. May be used by Relay 1.\n  personEdge(\n    # The method to use when ordering `Person`.\n    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]\n  ): PeopleEdge\n}\n\n# All input for the `updateRoleByRowId` mutation.\ninput UpdateRoleByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Role` being updated.\n  rolePatch: RolePatch!\n  rowId: Int!\n}\n\n# All input for the `updateRole` mutation.\ninput UpdateRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Role` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `Role` being updated.\n  rolePatch: RolePatch!\n}\n\n# The output of our update `Role` mutation.\ntype UpdateRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Role` that was updated by this mutation.\n  role: Role\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for the type. May be used by Relay 1.\n  roleEdge(\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RolesEdge\n}\n\n# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).\nscalar UUID\n\n",
      "containsQueryType": true,
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 25,
      "containsCycle": true,
      "numDefinitions": 61
    }
  ],
  "metrics": {
    "created_at": "2017-12-26T00:03:04Z",
    "updated_at": "2018-05-10T08:40:00Z",
    "pushed_at": "2018-04-19T14:10:06Z",
    "issues": 0,
    "watchers": 1,
    "fork_count": 0,
    "has_wiki_enabled": true,
    "license": "mit",
    "pull_requests": 0,
    "pull_requests_open": 0,
    "pull_requests_closed": 0,
    "pull_requests_merged": 0,
    "releases": 0,
    "stargazers": 0
  }
}