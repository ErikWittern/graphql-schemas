{
  "repo_name": "blog_server",
  "repo_full_name": "jamesallain/blog_server",
  "repo_owner": "jamesallain",
  "repo_description": null,
  "repo_private": false,
  "repo_fork": false,
  "schemas": [
    {
      "name": "schema.graphql",
      "path": "data/generated/apollo/schema.graphql",
      "sha": "96b32e23e5650867bffe6218462305a25d0f349b",
      "url": "https://api.github.com/repositories/89964429/contents/data/generated/apollo/schema.graphql?ref=3ced9d8e0e49e9ef2f4eb5059bf568a484b3ee7b",
      "git_url": "https://api.github.com/repositories/89964429/git/blobs/96b32e23e5650867bffe6218462305a25d0f349b",
      "html_url": "https://github.com/jamesallain/blog_server/blob/3ced9d8e0e49e9ef2f4eb5059bf568a484b3ee7b/data/generated/apollo/schema.graphql",
      "content": "# A forum comment written by a user.\ntype Comment implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n\n  # The primary key for the comment.\n  id: Int!\n\n  # The id of the post of the user.\n  postId: Int!\n  userId: Int!\n\n  # The id of the comment the user replied to.\n  commentId: Int!\n\n  # The main content of our comment on the post.\n  content: String!\n\n  # A comment wil be locked after others reply to it.\n  locked: Boolean!\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Reads and enables paginatation through a set of `Comment`.\n  commentsByCommentId(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n}\n\n# A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput CommentCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `postId` field.\n  postId: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `commentId` field.\n  commentId: Int\n\n  # Checks for equality with the object’s `content` field.\n  content: String\n\n  # Checks for equality with the object’s `locked` field.\n  locked: Boolean\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `updatedAt` field.\n  updatedAt: Datetime\n}\n\n# A forum comment written by a user.\ninput CommentInput {\n  # The primary key for the comment.\n  id: Int\n\n  # The id of the post of the user.\n  postId: Int!\n  userId: Int!\n\n  # The id of the comment the user replied to.\n  commentId: Int!\n\n  # The main content of our comment on the post.\n  content: String!\n\n  # A comment wil be locked after others reply to it.\n  locked: Boolean!\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# Represents an update to a `Comment`. Fields that are set will be updated.\ninput CommentPatch {\n  # The primary key for the comment.\n  id: Int\n\n  # The id of the post of the user.\n  postId: Int\n  userId: Int\n\n  # The id of the comment the user replied to.\n  commentId: Int\n\n  # The main content of our comment on the post.\n  content: String\n\n  # A comment wil be locked after others reply to it.\n  locked: Boolean\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# A connection to a list of `Comment` values.\ntype CommentsConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Comment` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `Comment` and cursor to aid in pagination.\n  edges: [CommentsEdge]\n\n  # A list of `Comment` objects.\n  nodes: [Comment!]\n}\n\n# A `Comment` edge in the connection.\ntype CommentsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Comment` at the end of the edge.\n  node: Comment!\n}\n\n# Methods to use when ordering `Comment`.\nenum CommentsOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  POST_ID_ASC\n  POST_ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  COMMENT_ID_ASC\n  COMMENT_ID_DESC\n  CONTENT_ASC\n  CONTENT_DESC\n  LOCKED_ASC\n  LOCKED_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  UPDATED_AT_ASC\n  UPDATED_AT_DESC\n}\n\n# All input for the `createComment` mutation.\ninput CreateCommentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Comment` to be created by this mutation.\n  comment: CommentInput!\n}\n\n# The output of our `createComment` mutation.\ntype CreateCommentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Comment` that was created by this mutation.\n  comment: Comment\n\n  # An edge for our `Comment`. May be used by Relay 1.\n  commentEdge(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n  ): CommentsEdge\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `createPost` mutation.\ninput CreatePostInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Post` to be created by this mutation.\n  post: PostInput!\n}\n\n# The output of our `createPost` mutation.\ntype CreatePostPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Post` that was created by this mutation.\n  post: Post\n\n  # An edge for our `Post`. May be used by Relay 1.\n  postEdge(\n    # The method to use when ordering `Post`.\n    orderBy: PostsOrderBy = PRIMARY_KEY_ASC\n  ): PostsEdge\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `createStatic` mutation.\ninput CreateStaticInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Static` to be created by this mutation.\n  static: StaticInput!\n}\n\n# The output of our `createStatic` mutation.\ntype CreateStaticPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Static` that was created by this mutation.\n  static: Static\n\n  # An edge for our `Static`. May be used by Relay 1.\n  staticEdge(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n  ): StaticsEdge\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `createUser` mutation.\ninput CreateUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `User` to be created by this mutation.\n  user: UserInput!\n}\n\n# The output of our `createUser` mutation.\ntype CreateUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `User` that was created by this mutation.\n  user: User\n\n  # An edge for our `User`. May be used by Relay 1.\n  userEdge(\n    # The method to use when ordering `User`.\n    orderBy: UsersOrderBy = PRIMARY_KEY_ASC\n  ): UsersEdge\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# A location in a connection that can be used for resuming pagination.\nscalar Cursor\n\n# A point in time as described by the [ISO\n# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\nscalar Datetime\n\n# All input for the `deleteCommentById` mutation.\ninput DeleteCommentByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the comment.\n  id: Int!\n}\n\n# All input for the `deleteComment` mutation.\ninput DeleteCommentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Comment` to be deleted.\n  nodeId: ID!\n}\n\n# The output of our `deleteComment` mutation.\ntype DeleteCommentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  comment: Comment\n  deletedCommentId: ID\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `deletePostById` mutation.\ninput DeletePostByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the post.\n  id: Int!\n}\n\n# All input for the `deletePost` mutation.\ninput DeletePostInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Post` to be deleted.\n  nodeId: ID!\n}\n\n# The output of our `deletePost` mutation.\ntype DeletePostPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  post: Post\n  deletedPostId: ID\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `deleteStaticById` mutation.\ninput DeleteStaticByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# All input for the `deleteStatic` mutation.\ninput DeleteStaticInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Static` to be deleted.\n  nodeId: ID!\n}\n\n# The output of our `deleteStatic` mutation.\ntype DeleteStaticPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  static: Static\n  deletedStaticId: ID\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `deleteUserById` mutation.\ninput DeleteUserByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary unique identifier for the user.\n  id: Int!\n}\n\n# All input for the `deleteUser` mutation.\ninput DeleteUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `User` to be deleted.\n  nodeId: ID!\n}\n\n# The output of our `deleteUser` mutation.\ntype DeleteUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  user: User\n  deletedUserId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# The root mutation type which contains root level fields which mutate data.\ntype Mutation {\n  # Creates a single `Comment`.\n  createComment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateCommentInput!\n  ): CreateCommentPayload\n\n  # Updates a single `Comment` using its globally unique id and a patch.\n  updateComment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateCommentInput!\n  ): UpdateCommentPayload\n\n  # Updates a single `Comment` using a unique key and a patch.\n  updateCommentById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateCommentByIdInput!\n  ): UpdateCommentPayload\n\n  # Deletes a single `Comment` using its globally unique id.\n  deleteComment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteCommentInput!\n  ): DeleteCommentPayload\n\n  # Deletes a single `Comment` using a unique key.\n  deleteCommentById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteCommentByIdInput!\n  ): DeleteCommentPayload\n\n  # Creates a single `Post`.\n  createPost(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreatePostInput!\n  ): CreatePostPayload\n\n  # Updates a single `Post` using its globally unique id and a patch.\n  updatePost(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdatePostInput!\n  ): UpdatePostPayload\n\n  # Updates a single `Post` using a unique key and a patch.\n  updatePostById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdatePostByIdInput!\n  ): UpdatePostPayload\n\n  # Deletes a single `Post` using its globally unique id.\n  deletePost(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeletePostInput!\n  ): DeletePostPayload\n\n  # Deletes a single `Post` using a unique key.\n  deletePostById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeletePostByIdInput!\n  ): DeletePostPayload\n\n  # Creates a single `Static`.\n  createStatic(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateStaticInput!\n  ): CreateStaticPayload\n\n  # Updates a single `Static` using its globally unique id and a patch.\n  updateStatic(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateStaticInput!\n  ): UpdateStaticPayload\n\n  # Updates a single `Static` using a unique key and a patch.\n  updateStaticById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateStaticByIdInput!\n  ): UpdateStaticPayload\n\n  # Deletes a single `Static` using its globally unique id.\n  deleteStatic(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteStaticInput!\n  ): DeleteStaticPayload\n\n  # Deletes a single `Static` using a unique key.\n  deleteStaticById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteStaticByIdInput!\n  ): DeleteStaticPayload\n\n  # Creates a single `User`.\n  createUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateUserInput!\n  ): CreateUserPayload\n\n  # Updates a single `User` using its globally unique id and a patch.\n  updateUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserInput!\n  ): UpdateUserPayload\n\n  # Updates a single `User` using a unique key and a patch.\n  updateUserById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserByIdInput!\n  ): UpdateUserPayload\n\n  # Deletes a single `User` using its globally unique id.\n  deleteUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserInput!\n  ): DeleteUserPayload\n\n  # Deletes a single `User` using a unique key.\n  deleteUserById(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserByIdInput!\n  ): DeleteUserPayload\n}\n\n# An object with a globally unique `ID`.\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n}\n\n# Information about pagination in a connection.\ntype PageInfo {\n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean!\n\n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean!\n\n  # When paginating backwards, the cursor to continue.\n  startCursor: Cursor\n\n  # When paginating forwards, the cursor to continue.\n  endCursor: Cursor\n}\n\n# A forum post written by a user.\ntype Post implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n\n  # The primary key for the post.\n  id: Int!\n\n  # The id of the author user.\n  userId: Int!\n\n  # The title written by the user.\n  title: String!\n\n  # The url of the post.\n  url: String\n\n  # The main content text of our post.\n  content: String\n\n  # The topic this has been posted in.\n  topic: PostTopic\n\n  # Number of times the post has been visited.\n  visit: Int\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Reads and enables paginatation through a set of `Comment`.\n  commentsByPostId(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n\n  # Reads and enables paginatation through a set of `Static`.\n  staticsByPostId(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: StaticCondition\n  ): StaticsConnection\n}\n\n# A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput PostCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `title` field.\n  title: String\n\n  # Checks for equality with the object’s `url` field.\n  url: String\n\n  # Checks for equality with the object’s `content` field.\n  content: String\n\n  # Checks for equality with the object’s `topic` field.\n  topic: PostTopic\n\n  # Checks for equality with the object’s `visit` field.\n  visit: Int\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `updatedAt` field.\n  updatedAt: Datetime\n}\n\n# A forum post written by a user.\ninput PostInput {\n  # The primary key for the post.\n  id: Int\n\n  # The id of the author user.\n  userId: Int!\n\n  # The title written by the user.\n  title: String!\n\n  # The url of the post.\n  url: String\n\n  # The main content text of our post.\n  content: String\n\n  # The topic this has been posted in.\n  topic: PostTopic\n\n  # Number of times the post has been visited.\n  visit: Int\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# Represents an update to a `Post`. Fields that are set will be updated.\ninput PostPatch {\n  # The primary key for the post.\n  id: Int\n\n  # The id of the author user.\n  userId: Int\n\n  # The title written by the user.\n  title: String\n\n  # The url of the post.\n  url: String\n\n  # The main content text of our post.\n  content: String\n\n  # The topic this has been posted in.\n  topic: PostTopic\n\n  # Number of times the post has been visited.\n  visit: Int\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# A connection to a list of `Post` values.\ntype PostsConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Post` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `Post` and cursor to aid in pagination.\n  edges: [PostsEdge]\n\n  # A list of `Post` objects.\n  nodes: [Post!]\n}\n\n# A `Post` edge in the connection.\ntype PostsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Post` at the end of the edge.\n  node: Post!\n}\n\n# Methods to use when ordering `Post`.\nenum PostsOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  TITLE_ASC\n  TITLE_DESC\n  URL_ASC\n  URL_DESC\n  CONTENT_ASC\n  CONTENT_DESC\n  TOPIC_ASC\n  TOPIC_DESC\n  VISIT_ASC\n  VISIT_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  UPDATED_AT_ASC\n  UPDATED_AT_DESC\n}\n\nenum PostTopic {\n  DISCUSSION\n  INSPIRATION\n  HELP\n  SHOWCASE\n}\n\n# The root query type which gives access points into the data universe.\ntype Query implements Node {\n  # Fetches an object given its globally unique `ID`.\n  node(\n    # The globally unique `ID`.\n    nodeId: ID!\n  ): Node\n\n  # Reads and enables paginatation through a set of `Comment`.\n  allComments(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n\n  # Reads a single `Comment` using its globally unique `ID`.\n  comment(\n    # The globally unique `ID` to be used in selecting a single `Comment`.\n    nodeId: ID!\n  ): Comment\n  commentById(\n    # The primary key for the comment.\n    id: Int!\n  ): Comment\n\n  # Reads and enables paginatation through a set of `Post`.\n  allPosts(\n    # The method to use when ordering `Post`.\n    orderBy: PostsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: PostCondition\n  ): PostsConnection\n\n  # Reads a single `Post` using its globally unique `ID`.\n  post(\n    # The globally unique `ID` to be used in selecting a single `Post`.\n    nodeId: ID!\n  ): Post\n  postById(\n    # The primary key for the post.\n    id: Int!\n  ): Post\n\n  # Reads and enables paginatation through a set of `Static`.\n  allStatics(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: StaticCondition\n  ): StaticsConnection\n\n  # Reads a single `Static` using its globally unique `ID`.\n  static(\n    # The globally unique `ID` to be used in selecting a single `Static`.\n    nodeId: ID!\n  ): Static\n  staticById(id: Int!): Static\n\n  # Reads and enables paginatation through a set of `User`.\n  allUsers(\n    # The method to use when ordering `User`.\n    orderBy: UsersOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserCondition\n  ): UsersConnection\n\n  # Reads a single `User` using its globally unique `ID`.\n  user(\n    # The globally unique `ID` to be used in selecting a single `User`.\n    nodeId: ID!\n  ): User\n  userById(\n    # The primary unique identifier for the user.\n    id: Int!\n  ): User\n\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n\n  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\n  nodeId: ID!\n}\n\n# A stat is the statics on how long a user stays on one page.\ntype Static implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n\n  # The id of the author user.\n  userId: Int!\n\n  # The id of the post of the user.\n  postId: Int!\n\n  # Legth of time.\n  long: Int!\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n}\n\n# A condition to be used against `Static` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput StaticCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `postId` field.\n  postId: Int\n\n  # Checks for equality with the object’s `long` field.\n  long: Int\n}\n\n# A stat is the statics on how long a user stays on one page.\ninput StaticInput {\n  id: Int\n\n  # The id of the author user.\n  userId: Int!\n\n  # The id of the post of the user.\n  postId: Int!\n\n  # Legth of time.\n  long: Int!\n}\n\n# Represents an update to a `Static`. Fields that are set will be updated.\ninput StaticPatch {\n  id: Int\n\n  # The id of the author user.\n  userId: Int\n\n  # The id of the post of the user.\n  postId: Int\n\n  # Legth of time.\n  long: Int\n}\n\n# A connection to a list of `Static` values.\ntype StaticsConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Static` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `Static` and cursor to aid in pagination.\n  edges: [StaticsEdge]\n\n  # A list of `Static` objects.\n  nodes: [Static!]\n}\n\n# A `Static` edge in the connection.\ntype StaticsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Static` at the end of the edge.\n  node: Static!\n}\n\n# Methods to use when ordering `Static`.\nenum StaticsOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  POST_ID_ASC\n  POST_ID_DESC\n  LONG_ASC\n  LONG_DESC\n}\n\n# All input for the `updateCommentById` mutation.\ninput UpdateCommentByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the comment.\n  id: Int!\n\n  # An object where the defined keys will be set on the `Comment` identified by our unique key.\n  commentPatch: CommentPatch!\n}\n\n# All input for the `updateComment` mutation.\ninput UpdateCommentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Comment` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Comment` identified by our globally unique `ID`.\n  commentPatch: CommentPatch!\n}\n\n# The output of our `updateComment` mutation.\ntype UpdateCommentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  comment: Comment\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `updatePostById` mutation.\ninput UpdatePostByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the post.\n  id: Int!\n\n  # An object where the defined keys will be set on the `Post` identified by our unique key.\n  postPatch: PostPatch!\n}\n\n# All input for the `updatePost` mutation.\ninput UpdatePostInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Post` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Post` identified by our globally unique `ID`.\n  postPatch: PostPatch!\n}\n\n# The output of our `updatePost` mutation.\ntype UpdatePostPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  post: Post\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `updateStaticById` mutation.\ninput UpdateStaticByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n\n  # An object where the defined keys will be set on the `Static` identified by our unique key.\n  staticPatch: StaticPatch!\n}\n\n# All input for the `updateStatic` mutation.\ninput UpdateStaticInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Static` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Static` identified by our globally unique `ID`.\n  staticPatch: StaticPatch!\n}\n\n# The output of our `updateStatic` mutation.\ntype UpdateStaticPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  static: Static\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `updateUserById` mutation.\ninput UpdateUserByIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary unique identifier for the user.\n  id: Int!\n\n  # An object where the defined keys will be set on the `User` identified by our unique key.\n  userPatch: UserPatch!\n}\n\n# All input for the `updateUser` mutation.\ninput UpdateUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `User` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `User` identified by our globally unique `ID`.\n  userPatch: UserPatch!\n}\n\n# The output of our `updateUser` mutation.\ntype UpdateUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  user: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# A user of the blog.\ntype User implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n\n  # The primary unique identifier for the user.\n  id: Int!\n\n  # The QQ id for the the user.\n  qqId: String\n\n  # The Weibo id for the the user.\n  weiboId: String\n\n  # The Facebook id for the the user.\n  facebookId: String\n\n  # The Twitter id for the the user.\n  twitterId: String\n\n  # The Gitbhub id for the the user.\n  githubId: String\n\n  # The avatar address for the the user.\n  avatar: String\n\n  # The user’s nickname.\n  nickname: String!\n\n  # The user’s first name.\n  firstName: String!\n\n  # The user’s last name.\n  lastName: String!\n\n  # Whether or not a user can publish a post.\n  publisher: Boolean\n\n  # The time this user was created.\n  createdAt: Datetime\n\n  # The time this user was updated.\n  updatedAt: Datetime\n\n  # Reads and enables paginatation through a set of `Post`.\n  postsByUserId(\n    # The method to use when ordering `Post`.\n    orderBy: PostsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: PostCondition\n  ): PostsConnection\n\n  # Reads and enables paginatation through a set of `Comment`.\n  commentsByUserId(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n\n  # Reads and enables paginatation through a set of `Static`.\n  staticsByUserId(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: StaticCondition\n  ): StaticsConnection\n}\n\n# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput UserCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `qqId` field.\n  qqId: String\n\n  # Checks for equality with the object’s `weiboId` field.\n  weiboId: String\n\n  # Checks for equality with the object’s `facebookId` field.\n  facebookId: String\n\n  # Checks for equality with the object’s `twitterId` field.\n  twitterId: String\n\n  # Checks for equality with the object’s `githubId` field.\n  githubId: String\n\n  # Checks for equality with the object’s `avatar` field.\n  avatar: String\n\n  # Checks for equality with the object’s `nickname` field.\n  nickname: String\n\n  # Checks for equality with the object’s `firstName` field.\n  firstName: String\n\n  # Checks for equality with the object’s `lastName` field.\n  lastName: String\n\n  # Checks for equality with the object’s `publisher` field.\n  publisher: Boolean\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `updatedAt` field.\n  updatedAt: Datetime\n}\n\n# A user of the blog.\ninput UserInput {\n  # The primary unique identifier for the user.\n  id: Int\n\n  # The QQ id for the the user.\n  qqId: String\n\n  # The Weibo id for the the user.\n  weiboId: String\n\n  # The Facebook id for the the user.\n  facebookId: String\n\n  # The Twitter id for the the user.\n  twitterId: String\n\n  # The Gitbhub id for the the user.\n  githubId: String\n\n  # The avatar address for the the user.\n  avatar: String\n\n  # The user’s nickname.\n  nickname: String!\n\n  # The user’s first name.\n  firstName: String!\n\n  # The user’s last name.\n  lastName: String!\n\n  # Whether or not a user can publish a post.\n  publisher: Boolean\n\n  # The time this user was created.\n  createdAt: Datetime\n\n  # The time this user was updated.\n  updatedAt: Datetime\n}\n\n# Represents an update to a `User`. Fields that are set will be updated.\ninput UserPatch {\n  # The primary unique identifier for the user.\n  id: Int\n\n  # The QQ id for the the user.\n  qqId: String\n\n  # The Weibo id for the the user.\n  weiboId: String\n\n  # The Facebook id for the the user.\n  facebookId: String\n\n  # The Twitter id for the the user.\n  twitterId: String\n\n  # The Gitbhub id for the the user.\n  githubId: String\n\n  # The avatar address for the the user.\n  avatar: String\n\n  # The user’s nickname.\n  nickname: String\n\n  # The user’s first name.\n  firstName: String\n\n  # The user’s last name.\n  lastName: String\n\n  # Whether or not a user can publish a post.\n  publisher: Boolean\n\n  # The time this user was created.\n  createdAt: Datetime\n\n  # The time this user was updated.\n  updatedAt: Datetime\n}\n\n# A connection to a list of `User` values.\ntype UsersConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `User` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `User` and cursor to aid in pagination.\n  edges: [UsersEdge]\n\n  # A list of `User` objects.\n  nodes: [User!]\n}\n\n# A `User` edge in the connection.\ntype UsersEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `User` at the end of the edge.\n  node: User!\n}\n\n# Methods to use when ordering `User`.\nenum UsersOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  QQ_ID_ASC\n  QQ_ID_DESC\n  WEIBO_ID_ASC\n  WEIBO_ID_DESC\n  FACEBOOK_ID_ASC\n  FACEBOOK_ID_DESC\n  TWITTER_ID_ASC\n  TWITTER_ID_DESC\n  GITHUB_ID_ASC\n  GITHUB_ID_DESC\n  AVATAR_ASC\n  AVATAR_DESC\n  NICKNAME_ASC\n  NICKNAME_DESC\n  FIRST_NAME_ASC\n  FIRST_NAME_DESC\n  LAST_NAME_ASC\n  LAST_NAME_DESC\n  PUBLISHER_ASC\n  PUBLISHER_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  UPDATED_AT_ASC\n  UPDATED_AT_DESC\n}\n",
      "containsQueryType": true,
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 27,
      "containsCycle": true,
      "numDefinitions": 67
    },
    {
      "name": "schema.graphql",
      "path": "data/generated/relay/schema.graphql",
      "sha": "1baa046f3b2eae4602a7241ed8a982b55e4b43a2",
      "url": "https://api.github.com/repositories/89964429/contents/data/generated/relay/schema.graphql?ref=3ced9d8e0e49e9ef2f4eb5059bf568a484b3ee7b",
      "git_url": "https://api.github.com/repositories/89964429/git/blobs/1baa046f3b2eae4602a7241ed8a982b55e4b43a2",
      "html_url": "https://github.com/jamesallain/blog_server/blob/3ced9d8e0e49e9ef2f4eb5059bf568a484b3ee7b/data/generated/relay/schema.graphql",
      "content": "# A forum comment written by a user.\ntype Comment implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n\n  # The primary key for the comment.\n  rowId: Int!\n\n  # The id of the post of the user.\n  postId: Int!\n  userId: Int!\n\n  # The id of the comment the user replied to.\n  commentId: Int!\n\n  # The main content of our comment on the post.\n  content: String!\n\n  # A comment wil be locked after others reply to it.\n  locked: Boolean!\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Reads and enables paginatation through a set of `Comment`.\n  commentsByCommentId(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n}\n\n# A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput CommentCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `postId` field.\n  postId: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `commentId` field.\n  commentId: Int\n\n  # Checks for equality with the object’s `content` field.\n  content: String\n\n  # Checks for equality with the object’s `locked` field.\n  locked: Boolean\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `updatedAt` field.\n  updatedAt: Datetime\n}\n\n# A forum comment written by a user.\ninput CommentInput {\n  # The primary key for the comment.\n  rowId: Int\n\n  # The id of the post of the user.\n  postId: Int!\n  userId: Int!\n\n  # The id of the comment the user replied to.\n  commentId: Int!\n\n  # The main content of our comment on the post.\n  content: String!\n\n  # A comment wil be locked after others reply to it.\n  locked: Boolean!\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# Represents an update to a `Comment`. Fields that are set will be updated.\ninput CommentPatch {\n  # The primary key for the comment.\n  rowId: Int\n\n  # The id of the post of the user.\n  postId: Int\n  userId: Int\n\n  # The id of the comment the user replied to.\n  commentId: Int\n\n  # The main content of our comment on the post.\n  content: String\n\n  # A comment wil be locked after others reply to it.\n  locked: Boolean\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# A connection to a list of `Comment` values.\ntype CommentsConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Comment` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `Comment` and cursor to aid in pagination.\n  edges: [CommentsEdge]\n\n  # A list of `Comment` objects.\n  nodes: [Comment!]\n}\n\n# A `Comment` edge in the connection.\ntype CommentsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Comment` at the end of the edge.\n  node: Comment!\n}\n\n# Methods to use when ordering `Comment`.\nenum CommentsOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  POST_ID_ASC\n  POST_ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  COMMENT_ID_ASC\n  COMMENT_ID_DESC\n  CONTENT_ASC\n  CONTENT_DESC\n  LOCKED_ASC\n  LOCKED_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  UPDATED_AT_ASC\n  UPDATED_AT_DESC\n}\n\n# All input for the `createComment` mutation.\ninput CreateCommentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Comment` to be created by this mutation.\n  comment: CommentInput!\n}\n\n# The output of our `createComment` mutation.\ntype CreateCommentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Comment` that was created by this mutation.\n  comment: Comment\n\n  # An edge for our `Comment`. May be used by Relay 1.\n  commentEdge(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n  ): CommentsEdge\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `createPost` mutation.\ninput CreatePostInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Post` to be created by this mutation.\n  post: PostInput!\n}\n\n# The output of our `createPost` mutation.\ntype CreatePostPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Post` that was created by this mutation.\n  post: Post\n\n  # An edge for our `Post`. May be used by Relay 1.\n  postEdge(\n    # The method to use when ordering `Post`.\n    orderBy: PostsOrderBy = PRIMARY_KEY_ASC\n  ): PostsEdge\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `createStatic` mutation.\ninput CreateStaticInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Static` to be created by this mutation.\n  static: StaticInput!\n}\n\n# The output of our `createStatic` mutation.\ntype CreateStaticPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Static` that was created by this mutation.\n  static: Static\n\n  # An edge for our `Static`. May be used by Relay 1.\n  staticEdge(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n  ): StaticsEdge\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `createUser` mutation.\ninput CreateUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `User` to be created by this mutation.\n  user: UserInput!\n}\n\n# The output of our `createUser` mutation.\ntype CreateUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `User` that was created by this mutation.\n  user: User\n\n  # An edge for our `User`. May be used by Relay 1.\n  userEdge(\n    # The method to use when ordering `User`.\n    orderBy: UsersOrderBy = PRIMARY_KEY_ASC\n  ): UsersEdge\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# A location in a connection that can be used for resuming pagination.\nscalar Cursor\n\n# A point in time as described by the [ISO\n# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\nscalar Datetime\n\n# All input for the `deleteCommentByRowId` mutation.\ninput DeleteCommentByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the comment.\n  rowId: Int!\n}\n\n# All input for the `deleteComment` mutation.\ninput DeleteCommentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Comment` to be deleted.\n  id: ID!\n}\n\n# The output of our `deleteComment` mutation.\ntype DeleteCommentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  comment: Comment\n  deletedCommentId: ID\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `deletePostByRowId` mutation.\ninput DeletePostByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the post.\n  rowId: Int!\n}\n\n# All input for the `deletePost` mutation.\ninput DeletePostInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Post` to be deleted.\n  id: ID!\n}\n\n# The output of our `deletePost` mutation.\ntype DeletePostPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  post: Post\n  deletedPostId: ID\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `deleteStaticByRowId` mutation.\ninput DeleteStaticByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  rowId: Int!\n}\n\n# All input for the `deleteStatic` mutation.\ninput DeleteStaticInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Static` to be deleted.\n  id: ID!\n}\n\n# The output of our `deleteStatic` mutation.\ntype DeleteStaticPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  static: Static\n  deletedStaticId: ID\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `deleteUserByRowId` mutation.\ninput DeleteUserByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary unique identifier for the user.\n  rowId: Int!\n}\n\n# All input for the `deleteUser` mutation.\ninput DeleteUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `User` to be deleted.\n  id: ID!\n}\n\n# The output of our `deleteUser` mutation.\ntype DeleteUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  user: User\n  deletedUserId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# The root mutation type which contains root level fields which mutate data.\ntype Mutation {\n  # Creates a single `Comment`.\n  createComment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateCommentInput!\n  ): CreateCommentPayload\n\n  # Updates a single `Comment` using its globally unique id and a patch.\n  updateComment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateCommentInput!\n  ): UpdateCommentPayload\n\n  # Updates a single `Comment` using a unique key and a patch.\n  updateCommentByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateCommentByRowIdInput!\n  ): UpdateCommentPayload\n\n  # Deletes a single `Comment` using its globally unique id.\n  deleteComment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteCommentInput!\n  ): DeleteCommentPayload\n\n  # Deletes a single `Comment` using a unique key.\n  deleteCommentByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteCommentByRowIdInput!\n  ): DeleteCommentPayload\n\n  # Creates a single `Post`.\n  createPost(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreatePostInput!\n  ): CreatePostPayload\n\n  # Updates a single `Post` using its globally unique id and a patch.\n  updatePost(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdatePostInput!\n  ): UpdatePostPayload\n\n  # Updates a single `Post` using a unique key and a patch.\n  updatePostByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdatePostByRowIdInput!\n  ): UpdatePostPayload\n\n  # Deletes a single `Post` using its globally unique id.\n  deletePost(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeletePostInput!\n  ): DeletePostPayload\n\n  # Deletes a single `Post` using a unique key.\n  deletePostByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeletePostByRowIdInput!\n  ): DeletePostPayload\n\n  # Creates a single `Static`.\n  createStatic(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateStaticInput!\n  ): CreateStaticPayload\n\n  # Updates a single `Static` using its globally unique id and a patch.\n  updateStatic(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateStaticInput!\n  ): UpdateStaticPayload\n\n  # Updates a single `Static` using a unique key and a patch.\n  updateStaticByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateStaticByRowIdInput!\n  ): UpdateStaticPayload\n\n  # Deletes a single `Static` using its globally unique id.\n  deleteStatic(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteStaticInput!\n  ): DeleteStaticPayload\n\n  # Deletes a single `Static` using a unique key.\n  deleteStaticByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteStaticByRowIdInput!\n  ): DeleteStaticPayload\n\n  # Creates a single `User`.\n  createUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateUserInput!\n  ): CreateUserPayload\n\n  # Updates a single `User` using its globally unique id and a patch.\n  updateUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserInput!\n  ): UpdateUserPayload\n\n  # Updates a single `User` using a unique key and a patch.\n  updateUserByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserByRowIdInput!\n  ): UpdateUserPayload\n\n  # Deletes a single `User` using its globally unique id.\n  deleteUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserInput!\n  ): DeleteUserPayload\n\n  # Deletes a single `User` using a unique key.\n  deleteUserByRowId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserByRowIdInput!\n  ): DeleteUserPayload\n}\n\n# An object with a globally unique `ID`.\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n}\n\n# Information about pagination in a connection.\ntype PageInfo {\n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean!\n\n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean!\n\n  # When paginating backwards, the cursor to continue.\n  startCursor: Cursor\n\n  # When paginating forwards, the cursor to continue.\n  endCursor: Cursor\n}\n\n# A forum post written by a user.\ntype Post implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n\n  # The primary key for the post.\n  rowId: Int!\n\n  # The id of the author user.\n  userId: Int!\n\n  # The title written by the user.\n  title: String!\n\n  # The url of the post.\n  url: String\n\n  # The main content text of our post.\n  content: String\n\n  # The topic this has been posted in.\n  topic: PostTopic\n\n  # Number of times the post has been visited.\n  visit: Int\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Reads and enables paginatation through a set of `Comment`.\n  commentsByPostId(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n\n  # Reads and enables paginatation through a set of `Static`.\n  staticsByPostId(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: StaticCondition\n  ): StaticsConnection\n}\n\n# A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput PostCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `title` field.\n  title: String\n\n  # Checks for equality with the object’s `url` field.\n  url: String\n\n  # Checks for equality with the object’s `content` field.\n  content: String\n\n  # Checks for equality with the object’s `topic` field.\n  topic: PostTopic\n\n  # Checks for equality with the object’s `visit` field.\n  visit: Int\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `updatedAt` field.\n  updatedAt: Datetime\n}\n\n# A forum post written by a user.\ninput PostInput {\n  # The primary key for the post.\n  rowId: Int\n\n  # The id of the author user.\n  userId: Int!\n\n  # The title written by the user.\n  title: String!\n\n  # The url of the post.\n  url: String\n\n  # The main content text of our post.\n  content: String\n\n  # The topic this has been posted in.\n  topic: PostTopic\n\n  # Number of times the post has been visited.\n  visit: Int\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# Represents an update to a `Post`. Fields that are set will be updated.\ninput PostPatch {\n  # The primary key for the post.\n  rowId: Int\n\n  # The id of the author user.\n  userId: Int\n\n  # The title written by the user.\n  title: String\n\n  # The url of the post.\n  url: String\n\n  # The main content text of our post.\n  content: String\n\n  # The topic this has been posted in.\n  topic: PostTopic\n\n  # Number of times the post has been visited.\n  visit: Int\n\n  # The time this post was created.\n  createdAt: Datetime\n\n  # The time this post was updated.\n  updatedAt: Datetime\n}\n\n# A connection to a list of `Post` values.\ntype PostsConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Post` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `Post` and cursor to aid in pagination.\n  edges: [PostsEdge]\n\n  # A list of `Post` objects.\n  nodes: [Post!]\n}\n\n# A `Post` edge in the connection.\ntype PostsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Post` at the end of the edge.\n  node: Post!\n}\n\n# Methods to use when ordering `Post`.\nenum PostsOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  TITLE_ASC\n  TITLE_DESC\n  URL_ASC\n  URL_DESC\n  CONTENT_ASC\n  CONTENT_DESC\n  TOPIC_ASC\n  TOPIC_DESC\n  VISIT_ASC\n  VISIT_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  UPDATED_AT_ASC\n  UPDATED_AT_DESC\n}\n\nenum PostTopic {\n  DISCUSSION\n  INSPIRATION\n  HELP\n  SHOWCASE\n}\n\n# The root query type which gives access points into the data universe.\ntype Query implements Node {\n  # Fetches an object given its globally unique `ID`.\n  node(\n    # The globally unique `ID`.\n    id: ID!\n  ): Node\n\n  # Reads and enables paginatation through a set of `Comment`.\n  allComments(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n\n  # Reads a single `Comment` using its globally unique `ID`.\n  comment(\n    # The globally unique `ID` to be used in selecting a single `Comment`.\n    id: ID!\n  ): Comment\n  commentByRowId(\n    # The primary key for the comment.\n    rowId: Int!\n  ): Comment\n\n  # Reads and enables paginatation through a set of `Post`.\n  allPosts(\n    # The method to use when ordering `Post`.\n    orderBy: PostsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: PostCondition\n  ): PostsConnection\n\n  # Reads a single `Post` using its globally unique `ID`.\n  post(\n    # The globally unique `ID` to be used in selecting a single `Post`.\n    id: ID!\n  ): Post\n  postByRowId(\n    # The primary key for the post.\n    rowId: Int!\n  ): Post\n\n  # Reads and enables paginatation through a set of `Static`.\n  allStatics(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: StaticCondition\n  ): StaticsConnection\n\n  # Reads a single `Static` using its globally unique `ID`.\n  static(\n    # The globally unique `ID` to be used in selecting a single `Static`.\n    id: ID!\n  ): Static\n  staticByRowId(rowId: Int!): Static\n\n  # Reads and enables paginatation through a set of `User`.\n  allUsers(\n    # The method to use when ordering `User`.\n    orderBy: UsersOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserCondition\n  ): UsersConnection\n\n  # Reads a single `User` using its globally unique `ID`.\n  user(\n    # The globally unique `ID` to be used in selecting a single `User`.\n    id: ID!\n  ): User\n  userByRowId(\n    # The primary unique identifier for the user.\n    rowId: Int!\n  ): User\n\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n\n  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\n  id: ID!\n}\n\n# A stat is the statics on how long a user stays on one page.\ntype Static implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n  rowId: Int!\n\n  # The id of the author user.\n  userId: Int!\n\n  # The id of the post of the user.\n  postId: Int!\n\n  # Legth of time.\n  long: Int!\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n}\n\n# A condition to be used against `Static` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput StaticCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `postId` field.\n  postId: Int\n\n  # Checks for equality with the object’s `long` field.\n  long: Int\n}\n\n# A stat is the statics on how long a user stays on one page.\ninput StaticInput {\n  rowId: Int\n\n  # The id of the author user.\n  userId: Int!\n\n  # The id of the post of the user.\n  postId: Int!\n\n  # Legth of time.\n  long: Int!\n}\n\n# Represents an update to a `Static`. Fields that are set will be updated.\ninput StaticPatch {\n  rowId: Int\n\n  # The id of the author user.\n  userId: Int\n\n  # The id of the post of the user.\n  postId: Int\n\n  # Legth of time.\n  long: Int\n}\n\n# A connection to a list of `Static` values.\ntype StaticsConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Static` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `Static` and cursor to aid in pagination.\n  edges: [StaticsEdge]\n\n  # A list of `Static` objects.\n  nodes: [Static!]\n}\n\n# A `Static` edge in the connection.\ntype StaticsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Static` at the end of the edge.\n  node: Static!\n}\n\n# Methods to use when ordering `Static`.\nenum StaticsOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  POST_ID_ASC\n  POST_ID_DESC\n  LONG_ASC\n  LONG_DESC\n}\n\n# All input for the `updateCommentByRowId` mutation.\ninput UpdateCommentByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the comment.\n  rowId: Int!\n\n  # An object where the defined keys will be set on the `Comment` identified by our unique key.\n  commentPatch: CommentPatch!\n}\n\n# All input for the `updateComment` mutation.\ninput UpdateCommentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Comment` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `Comment` identified by our globally unique `ID`.\n  commentPatch: CommentPatch!\n}\n\n# The output of our `updateComment` mutation.\ntype UpdateCommentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  comment: Comment\n\n  # Reads a single `Post` that is related to this `Comment`.\n  postByPostId: Post\n\n  # Reads a single `User` that is related to this `Comment`.\n  userByUserId: User\n\n  # Reads a single `Comment` that is related to this `Comment`.\n  commentByCommentId: Comment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `updatePostByRowId` mutation.\ninput UpdatePostByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary key for the post.\n  rowId: Int!\n\n  # An object where the defined keys will be set on the `Post` identified by our unique key.\n  postPatch: PostPatch!\n}\n\n# All input for the `updatePost` mutation.\ninput UpdatePostInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Post` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `Post` identified by our globally unique `ID`.\n  postPatch: PostPatch!\n}\n\n# The output of our `updatePost` mutation.\ntype UpdatePostPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  post: Post\n\n  # Reads a single `User` that is related to this `Post`.\n  userByUserId: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `updateStaticByRowId` mutation.\ninput UpdateStaticByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  rowId: Int!\n\n  # An object where the defined keys will be set on the `Static` identified by our unique key.\n  staticPatch: StaticPatch!\n}\n\n# All input for the `updateStatic` mutation.\ninput UpdateStaticInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Static` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `Static` identified by our globally unique `ID`.\n  staticPatch: StaticPatch!\n}\n\n# The output of our `updateStatic` mutation.\ntype UpdateStaticPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  static: Static\n\n  # Reads a single `User` that is related to this `Static`.\n  userByUserId: User\n\n  # Reads a single `Post` that is related to this `Static`.\n  postByPostId: Post\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# All input for the `updateUserByRowId` mutation.\ninput UpdateUserByRowIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The primary unique identifier for the user.\n  rowId: Int!\n\n  # An object where the defined keys will be set on the `User` identified by our unique key.\n  userPatch: UserPatch!\n}\n\n# All input for the `updateUser` mutation.\ninput UpdateUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `User` to be updated.\n  id: ID!\n\n  # An object where the defined keys will be set on the `User` identified by our globally unique `ID`.\n  userPatch: UserPatch!\n}\n\n# The output of our `updateUser` mutation.\ntype UpdateUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n  user: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\n# A user of the blog.\ntype User implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  id: ID!\n\n  # The primary unique identifier for the user.\n  rowId: Int!\n\n  # The QQ id for the the user.\n  qqId: String\n\n  # The Weibo id for the the user.\n  weiboId: String\n\n  # The Facebook id for the the user.\n  facebookId: String\n\n  # The Twitter id for the the user.\n  twitterId: String\n\n  # The Gitbhub id for the the user.\n  githubId: String\n\n  # The avatar address for the the user.\n  avatar: String\n\n  # The user’s nickname.\n  nickname: String!\n\n  # The user’s first name.\n  firstName: String!\n\n  # The user’s last name.\n  lastName: String!\n\n  # Whether or not a user can publish a post.\n  publisher: Boolean\n\n  # The time this user was created.\n  createdAt: Datetime\n\n  # The time this user was updated.\n  updatedAt: Datetime\n\n  # Reads and enables paginatation through a set of `Post`.\n  postsByUserId(\n    # The method to use when ordering `Post`.\n    orderBy: PostsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: PostCondition\n  ): PostsConnection\n\n  # Reads and enables paginatation through a set of `Comment`.\n  commentsByUserId(\n    # The method to use when ordering `Comment`.\n    orderBy: CommentsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: CommentCondition\n  ): CommentsConnection\n\n  # Reads and enables paginatation through a set of `Static`.\n  staticsByUserId(\n    # The method to use when ordering `Static`.\n    orderBy: StaticsOrderBy = PRIMARY_KEY_ASC\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: StaticCondition\n  ): StaticsConnection\n}\n\n# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput UserCondition {\n  # Checks for equality with the object’s `rowId` field.\n  rowId: Int\n\n  # Checks for equality with the object’s `qqId` field.\n  qqId: String\n\n  # Checks for equality with the object’s `weiboId` field.\n  weiboId: String\n\n  # Checks for equality with the object’s `facebookId` field.\n  facebookId: String\n\n  # Checks for equality with the object’s `twitterId` field.\n  twitterId: String\n\n  # Checks for equality with the object’s `githubId` field.\n  githubId: String\n\n  # Checks for equality with the object’s `avatar` field.\n  avatar: String\n\n  # Checks for equality with the object’s `nickname` field.\n  nickname: String\n\n  # Checks for equality with the object’s `firstName` field.\n  firstName: String\n\n  # Checks for equality with the object’s `lastName` field.\n  lastName: String\n\n  # Checks for equality with the object’s `publisher` field.\n  publisher: Boolean\n\n  # Checks for equality with the object’s `createdAt` field.\n  createdAt: Datetime\n\n  # Checks for equality with the object’s `updatedAt` field.\n  updatedAt: Datetime\n}\n\n# A user of the blog.\ninput UserInput {\n  # The primary unique identifier for the user.\n  rowId: Int\n\n  # The QQ id for the the user.\n  qqId: String\n\n  # The Weibo id for the the user.\n  weiboId: String\n\n  # The Facebook id for the the user.\n  facebookId: String\n\n  # The Twitter id for the the user.\n  twitterId: String\n\n  # The Gitbhub id for the the user.\n  githubId: String\n\n  # The avatar address for the the user.\n  avatar: String\n\n  # The user’s nickname.\n  nickname: String!\n\n  # The user’s first name.\n  firstName: String!\n\n  # The user’s last name.\n  lastName: String!\n\n  # Whether or not a user can publish a post.\n  publisher: Boolean\n\n  # The time this user was created.\n  createdAt: Datetime\n\n  # The time this user was updated.\n  updatedAt: Datetime\n}\n\n# Represents an update to a `User`. Fields that are set will be updated.\ninput UserPatch {\n  # The primary unique identifier for the user.\n  rowId: Int\n\n  # The QQ id for the the user.\n  qqId: String\n\n  # The Weibo id for the the user.\n  weiboId: String\n\n  # The Facebook id for the the user.\n  facebookId: String\n\n  # The Twitter id for the the user.\n  twitterId: String\n\n  # The Gitbhub id for the the user.\n  githubId: String\n\n  # The avatar address for the the user.\n  avatar: String\n\n  # The user’s nickname.\n  nickname: String\n\n  # The user’s first name.\n  firstName: String\n\n  # The user’s last name.\n  lastName: String\n\n  # Whether or not a user can publish a post.\n  publisher: Boolean\n\n  # The time this user was created.\n  createdAt: Datetime\n\n  # The time this user was updated.\n  updatedAt: Datetime\n}\n\n# A connection to a list of `User` values.\ntype UsersConnection {\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `User` you could get from the connection.\n  totalCount: Int\n\n  # A list of edges which contains the `User` and cursor to aid in pagination.\n  edges: [UsersEdge]\n\n  # A list of `User` objects.\n  nodes: [User!]\n}\n\n# A `User` edge in the connection.\ntype UsersEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `User` at the end of the edge.\n  node: User!\n}\n\n# Methods to use when ordering `User`.\nenum UsersOrderBy {\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  NATURAL\n  ID_ASC\n  ID_DESC\n  QQ_ID_ASC\n  QQ_ID_DESC\n  WEIBO_ID_ASC\n  WEIBO_ID_DESC\n  FACEBOOK_ID_ASC\n  FACEBOOK_ID_DESC\n  TWITTER_ID_ASC\n  TWITTER_ID_DESC\n  GITHUB_ID_ASC\n  GITHUB_ID_DESC\n  AVATAR_ASC\n  AVATAR_DESC\n  NICKNAME_ASC\n  NICKNAME_DESC\n  FIRST_NAME_ASC\n  FIRST_NAME_DESC\n  LAST_NAME_ASC\n  LAST_NAME_DESC\n  PUBLISHER_ASC\n  PUBLISHER_DESC\n  CREATED_AT_ASC\n  CREATED_AT_DESC\n  UPDATED_AT_ASC\n  UPDATED_AT_DESC\n}\n",
      "containsQueryType": true,
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 27,
      "containsCycle": true,
      "numDefinitions": 67
    }
  ],
  "metrics": {
    "created_at": "2017-05-01T21:27:06Z",
    "updated_at": "2017-05-01T21:35:08Z",
    "pushed_at": "2017-05-01T21:35:21Z",
    "issues": 0,
    "watchers": 1,
    "fork_count": 0,
    "has_wiki_enabled": true,
    "license": "mit",
    "pull_requests": 0,
    "pull_requests_open": 0,
    "pull_requests_closed": 0,
    "pull_requests_merged": 0,
    "releases": 0,
    "stargazers": 0
  }
}