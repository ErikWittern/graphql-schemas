{
  "repo_name": "ervell",
  "repo_full_name": "aredotna/ervell",
  "repo_owner": "aredotna",
  "repo_description": "Are.na front-end client",
  "repo_private": false,
  "repo_fork": false,
  "schemas": [
    {
      "name": "schema.graphql",
      "path": "src/v2/apollo/schema.graphql",
      "sha": "a2c379323c537ffbb8d1d19d59fbe46d7b0ebb8a",
      "url": "https://api.github.com/repositories/22520829/contents/src/v2/apollo/schema.graphql?ref=4f678f8fdeae3d8ea0d44c3a2079c9f942c18a5f",
      "git_url": "https://api.github.com/repositories/22520829/git/blobs/a2c379323c537ffbb8d1d19d59fbe46d7b0ebb8a",
      "html_url": "https://github.com/aredotna/ervell/blob/4f678f8fdeae3d8ea0d44c3a2079c9f942c18a5f/src/v2/apollo/schema.graphql",
      "content": "# Autogenerated input type of AcceptChannelTransfer\ninput AcceptChannelTransferInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  token: String!\n}\n\n# Autogenerated return type of AcceptChannelTransfer\ntype AcceptChannelTransferPayload {\n  channel_transfer_request: ChannelTransferRequest\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of AcceptInvitation\ninput AcceptInvitationInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String!\n  first_name: String!\n  invitation_token: String!\n  last_name: String!\n  password: String!\n  password_confirmation: String!\n  receive_newsletter: Boolean\n  receive_tips_emails: Boolean\n  validation_token: String\n}\n\n# Autogenerated return type of AcceptInvitation\ntype AcceptInvitationPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Autogenerated input type of AddChannelMembers\ninput AddChannelMembersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  members: [ChannelMemberInput]!\n}\n\n# Autogenerated return type of AddChannelMembers\ntype AddChannelMembersPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of AddCollaborator\ninput AddCollaboratorInput {\n  channel_id: ID!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  user_ids: [ID]!\n}\n\n# Autogenerated return type of AddCollaborator\ntype AddCollaboratorPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of AddCreditCard\ninput AddCreditCardInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  default_source: Boolean\n  token: String!\n}\n\n# Autogenerated return type of AddCreditCard\ntype AddCreditCardPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  customer: Customer\n}\n\n# Autogenerated input type of AddGroupUsers\ninput AddGroupUsersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  user_ids: [ID]!\n}\n\n# Autogenerated return type of AddGroupUsers\ntype AddGroupUsersPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  group: Group\n}\n\n# Autogenerated input type of ApplyCouponToSubscription\ninput ApplyCouponToSubscriptionInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coupon_code: String!\n}\n\n# Autogenerated return type of ApplyCouponToSubscription\ntype ApplyCouponToSubscriptionPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# An attachment block\ntype Attachment implements Block & ConnectableInterface & Model {\n  can: BlockCan\n  channels: [Channel]\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  counts: BlockCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  file_content_type: String\n  file_extension: String\n  file_size(precision: Int = 3): String\n  file_url: String\n  href: String\n  id: Int\n  image_url(size: ImageVersion = DISPLAY): String\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# Providers for external authentication\nenum AuthenticatedServiceProvider {\n  TWITTER\n}\n\n# An authorized external service provider\ntype Authentication implements Model {\n  contacts(page: Int = 1, per: Int = 50): [User]\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  provider: String\n  uid: String\n  updated_at(format: String, relative: Boolean): String\n}\n\n# Avatar sizes\nenum AvatarVersion {\n  LARGE\n  MEDIUM\n  SMALL\n  UNCROPPED\n}\n\nenum BannerEnum {\n  BOOKMARKLET\n  CONFIRM\n  INVITE\n  PROPOSE_PREMIUM\n  STRONGLY_PROPOSE_PREMIUM\n}\n\n# Possible connectables for a new connection\nenum BaseConnectableTypeEnum {\n  BLOCK\n  CHANNEL\n}\n\n# Fields common to all Block types\ninterface Block {\n  can: BlockCan\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment]\n  counts: BlockCounts\n}\n\n# The actions that the CurrentUser can perform on the Block\ntype BlockCan {\n  comment: Boolean\n  manage: Boolean\n  mute: Boolean\n  read: Boolean\n}\n\ntype BlockCounts {\n  channels: Int\n  channels_with_same_source: Int\n  comments: Int\n  private_accessible_channels: Int\n  public_channels: Int\n}\n\n# Block types\nenum BlockFilterEnum {\n  ALL\n  ATTACHMENT\n  EMBED\n  IMAGE\n  LINK\n  TEXT\n}\n\n# Autogenerated input type of CancelChannelTransfer\ninput CancelChannelTransferInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of CancelChannelTransfer\ntype CancelChannelTransferPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of CancelPremiumSubscription\ninput CancelPremiumSubscriptionInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated return type of CancelPremiumSubscription\ntype CancelPremiumSubscriptionPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Autogenerated input type of CancelPremiumSubscriptions\ninput CancelPremiumSubscriptionsInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  user_ids: [ID]!\n}\n\n# Autogenerated return type of CancelPremiumSubscriptions\ntype CancelPremiumSubscriptionsPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n  users: [User]\n}\n\n# A single channel\ntype Channel implements ConnectableInterface & Followable & Model & Mutable {\n  added_to_at(format: String, relative: Boolean): String\n  blocks(direction: Directions = ASC, page: Int = 1, per: Int = 25, sort_by: Sorts = POSITION, type: ConnectableTypeEnum = null, user_id: ID = null): [Connectable] @deprecated(reason: \"Use `blokks` until this can be replaced with it\")\n  blokks(direction: Directions = ASC, page: Int = 1, per: Int = 25, sort_by: Sorts = POSITION, type: ConnectableTypeEnum = null, user_id: ID = null): [Konnectable]\n  can: ChannelCan\n  channels: [Channel]\n  collaborators: [User] @deprecated(reason: \"This only returns Users. Use `members` field instead\")\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n  connected_to_channels: [Channel]\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  content_flag: String\n  counts: ChannelCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  followers(page: Int = 1, per: Int = 1): [User]\n  href: String\n  id: Int\n  is_collaboration: Boolean\n  is_followed: Boolean\n  is_muted: Boolean\n  is_nsfw: Boolean\n  is_open: Boolean @deprecated(reason: \"Use `visibility`\")\n  is_pending_transfer: Boolean\n  is_published: Boolean @deprecated(reason: \"Use `visibility`\")\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  members: [Member]\n  memberships: [ChannelMembership]\n  owner: ChannelOwner\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  share: ChannelShare\n  share_id: String\n  skeleton(type: [BaseConnectableTypeEnum] = [BLOCK, CHANNEL]): [SkeletalConnectable]\n  slug: String\n  source: ConnectableSource\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  transfer_request: ChannelTransferRequest\n  type: String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# The actions that the CurrentUser can perform on the Channel\ntype ChannelCan {\n  add_to: Boolean\n  connect: Boolean\n  destroy: Boolean\n  export: Boolean\n  follow: Boolean\n  manage: Boolean\n  manage_collaborators: Boolean\n  mute: Boolean\n  read: Boolean\n  transfer: Boolean\n  update: Boolean\n}\n\ntype ChannelCounts {\n  blocks: Int\n  channels: Int\n  collaborators: Int\n  connected_to_channels: Int\n  contents: Int\n  followers: Int\n}\n\ninput ChannelMemberInput {\n  id: ID!\n  type: MemberTypes = USER\n}\n\n# A membership defining the relationship between Channels and Members (Users or Groups)\ntype ChannelMembership implements Model {\n  can: ChannelMembershipCan\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  member: Member\n  updated_at(format: String, relative: Boolean): String\n}\n\n# The actions that the CurrentUser can perform on the ChannelMembership\ntype ChannelMembershipCan {\n  manage: Boolean\n}\n\nunion ChannelOwner = Group | User\n\nenum ChannelOwnerTypeEnum {\n  GROUP\n  USER\n}\n\n# Properties needed to share channels externally\ntype ChannelShare {\n  facebook_url: String\n  twitter_url: String\n  url: String\n}\n\n# A request to transfer the ownership of a channel to a new user\ntype ChannelTransferRequest implements Model {\n  channel: Channel\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  is_recipient_member: Boolean\n  is_user_to_member: Boolean @deprecated(reason: \"User => Owner: use `is_recipient_member` field\")\n  recipient: ChannelOwner\n  sender: ChannelOwner\n  updated_at(format: String, relative: Boolean): String\n  user_from: User @deprecated(reason: \"User => Owner: use `sender` field\")\n  user_to: User @deprecated(reason: \"User => Owner: use recipient field\")\n}\n\n# Privacy states for a channel\nenum ChannelVisibility {\n  CLOSED\n  PRIVATE\n  PUBLIC\n}\n\n# Autogenerated input type of ClearNotifications\ninput ClearNotificationsInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  confirm: Boolean!\n}\n\n# Autogenerated return type of ClearNotifications\ntype ClearNotificationsPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# A single comment\ntype Comment implements Model {\n  body(format: Format, no_links: Boolean = false, truncate: Int): String\n  can: CommentCan\n  commentable: Commentable\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  updated_at(format: String, relative: Boolean): String\n  user: User\n}\n\ntype CommentCan {\n  destroy: Boolean\n  manage: Boolean\n}\n\n# Union of objects that can be commented on\nunion Commentable = Attachment | Embed | Image | Link | Text\n\n# A block or a channel\ntype Connectable implements ConnectableInterface & Model & Mutable {\n  can: ConnectableCan @deprecated(reason: \"Use specific type cans\")\n  channels: [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  href: String\n  id: Int\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# The actions that the CurrentUser can perform on the Connectable\ntype ConnectableCan {\n  manage: Boolean\n  read: Boolean\n}\n\n# Fields common to models that can be connected\ninterface ConnectableInterface {\n  channels: [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  description(format: Format, no_links: Boolean = false): String\n  href: String\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  user: User\n  visibility: String\n}\n\n# Connectable attributes specific to its class\nunion ConnectableKind = Attachment | Channel | Embed | Image | Link | PendingBlock | Text\n\ntype ConnectableSource {\n  provider_name: String\n  provider_url: String\n  title: String\n  url: String\n}\n\n# Connectable types\nenum ConnectableTypeEnum {\n  ATTACHMENT\n  BLOCK\n  CHANNEL\n  EMBED\n  IMAGE\n  LINK\n  TEXT\n}\n\n# A connection\ntype Connection implements Model {\n  can: ConnectionCan\n  channel: Channel\n  connectable: Connectable\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  position: Int\n  updated_at(format: String, relative: Boolean): String\n  user: User\n}\n\n# The actions that the CurrentUser can perform on the Connection\ntype ConnectionCan {\n  create: Boolean\n  destroy: Boolean\n  manage: Boolean\n}\n\n# Available content flag states for channels\nenum ContentFlag {\n  NSFW\n  SAFE\n}\n\ntype Coupon {\n  amount_off: Int\n  code: String\n  created_at(format: String, relative: Boolean): String\n  currency: String\n  description: String\n  duration: String\n  duration_in_months: String\n  id: String\n  is_valid: Boolean\n  percent_off: Int\n  redeem_by(format: String, relative: Boolean): String\n}\n\n# Autogenerated input type of CreateAuthenticatedService\ninput CreateAuthenticatedServiceInput {\n  avatar_url: String\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  provider: AuthenticatedServiceProvider = TWITTER\n  secret: String!\n  token: String!\n  uid: String!\n}\n\n# Autogenerated return type of CreateAuthenticatedService\ntype CreateAuthenticatedServicePayload {\n  authenticated_service: Authentication\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of CreateBlock\ninput CreateBlockInput {\n  channel_ids: [ID]!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  content: String\n  description: String\n  original_source_title: String\n  original_source_url: String\n  source_url: String\n  title: String\n}\n\n# Autogenerated return type of CreateBlock\ntype CreateBlockPayload {\n  block: Connectable\n  channels: [Channel]\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of CreateChannel\ninput CreateChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  description: String\n  group_id: ID\n  title: String!\n  visibility: ChannelVisibility = CLOSED\n}\n\n# Autogenerated return type of CreateChannel\ntype CreateChannelPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of CreateComment\ninput CreateCommentInput {\n  block_id: ID!\n  body: String!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated return type of CreateComment\ntype CreateCommentPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  comment: Comment\n}\n\n# Autogenerated input type of CreateConnection\ninput CreateConnectionInput {\n  channel_ids: [ID]!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  connectable_id: ID!\n  connectable_type: BaseConnectableTypeEnum!\n}\n\n# Autogenerated return type of CreateConnection\ntype CreateConnectionPayload {\n  channels: [Channel]\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  connectable: Connectable\n  connections: [Connection]\n  konnectable: Konnectable\n}\n\n# Autogenerated input type of CreateGroup\ninput CreateGroupInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  description: String\n  name: String!\n}\n\n# Autogenerated return type of CreateGroup\ntype CreateGroupPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  group: Group\n}\n\n# Autogenerated input type of CreateUserMessageChannel\ninput CreateUserMessageChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of CreateUserMessageChannel\ntype CreateUserMessageChannelPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\ntype CreditCard {\n  brand: String\n  exp_month: String\n  exp_year: String\n  id: String\n  last4: String\n}\n\n# Your account customer data\ntype Customer implements Model {\n  created_at(format: String, relative: Boolean): String\n  credit_cards: [CreditCard]\n  current_period_end_at(format: String, relative: Boolean): String\n  current_period_start_at(format: String, relative: Boolean): String\n  default_credit_card: CreditCard\n  external_id: String\n  id: Int\n  is_beneficiary: Boolean\n  is_canceled: Boolean\n  is_delinquent: Boolean\n  is_lifetime: Boolean\n  is_patron: Boolean\n  is_premium: Boolean\n  patron: User\n  plan: Plan\n  plan_id: String\n  status: String\n  subscription: PremiumSubscription\n  upcoming_invoice(coupon_code: String, plan_id: SupportedPlanEnum): Invoice\n  updated_at(format: String, relative: Boolean): String\n}\n\nenum CustomerStatuses {\n  ACTIVE\n  CANCELED\n  INACTIVE\n}\n\n# A single deed\ntype Deed implements Model {\n  action: String\n  bulletin_id: ID\n  connector: String\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  is_private: Boolean\n  is_read: Boolean\n  item: DeedKind\n  item_title(truncate: Int): String\n  owner: DeedOwner\n  parent: DeedKind\n  target: DeedKind\n  updated_at(format: String, relative: Boolean): String\n  user: User\n}\n\n# A group of deeds\ntype DeedGroup {\n  action: String\n  are_all_read: Boolean\n  connector: String\n  created_at(format: String, relative: Boolean): String\n  deeds: [Deed]\n  ids: [ID]\n  is_private: Boolean\n  is_single: Boolean\n  item: DeedKind\n  item_phrase(truncate: Int): String\n  items: [DeedKind] @deprecated(reason: \"Use `objects`\")\n  key: String\n  length: Int\n  object: DeedKind @deprecated(reason: \"Use `item`\")\n  object_phrase(truncate: Int): String @deprecated(reason: \"Use `item_phrase`\")\n  objects: [DeedKkind]\n  owner: DeedOwner\n  target: DeedKind\n  target_phrase(truncate: Int): String\n  user: User\n  verb: String @deprecated(reason: \"Use `action`\")\n}\n\n# Deed item, target, or parent\nunion DeedKind = Channel | Comment | Connectable | Group | Null | User\n\n# Deed item, target, or parent\nunion DeedKkind = Attachment | Channel | Comment | Embed | Group | Image | Link | Text | User\n\nunion DeedOwner = Group | User\n\n# Autogenerated input type of DeleteAuthenticatedService\ninput DeleteAuthenticatedServiceInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of DeleteAuthenticatedService\ntype DeleteAuthenticatedServicePayload {\n  authenticated_service: Authentication\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of DeleteChannel\ninput DeleteChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of DeleteChannel\ntype DeleteChannelPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  status: String\n}\n\n# Autogenerated input type of DeleteComment\ninput DeleteCommentInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of DeleteComment\ntype DeleteCommentPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  commentable: Commentable\n  status: String\n}\n\n# Autogenerated input type of DeleteConnection\ninput DeleteConnectionInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of DeleteConnection\ntype DeleteConnectionPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  status: String\n}\n\n# Autogenerated input type of DeleteGroup\ninput DeleteGroupInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of DeleteGroup\ntype DeleteGroupPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  status: String\n}\n\n# Directions to sort blocks\nenum Directions {\n  ASC\n  DESC\n}\n\n# Autogenerated input type of DismissBanner\ninput DismissBannerInput {\n  banner: BannerEnum!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated return type of DismissBanner\ntype DismissBannerPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# An embed block\ntype Embed implements Block & ConnectableInterface & Model {\n  can: BlockCan\n  channels: [Channel]\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  counts: BlockCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  embed_height: Int\n  embed_html: String\n  embed_width: Int\n  href: String\n  id: Int\n  image_url(size: ImageVersion = DISPLAY): String\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  source_url: String\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# Autogenerated input type of ExportChannel\ninput ExportChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  format: ExportFormats!\n  id: ID!\n}\n\n# Autogenerated return type of ExportChannel\ntype ExportChannelPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  status: String\n}\n\nenum ExportFormats {\n  HTML\n  PDF\n  ZIP\n}\n\n# A feed\ntype Feed {\n  deeds: [Deed]\n  groups: [DeedGroup]\n  total: Int\n}\n\n# Autogenerated input type of Follow\ninput FollowInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  type: FollowableTypeEnum!\n}\n\n# Autogenerated return type of Follow\ntype FollowPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  followable: FollowableType\n}\n\n# Fields common to models that can be followed\ninterface Followable {\n  followers(page: Int = 1, per: Int = 1): [User]\n  is_followed: Boolean\n}\n\n# Followable object\nunion FollowableType = Channel | Group | User\n\n# Types of followable objects\nenum FollowableTypeEnum {\n  CHANNEL\n  GROUP\n  USER\n}\n\n# Ways to format a markdown field\nenum Format {\n  HTML\n  MARKDOWN\n}\n\n# A Group of Users\ntype Group implements Followable & Model {\n  avatar(size: AvatarVersion): String\n  can: GroupCan\n  channels(page: Int = 1, per: Int = 1, q: String = null): [Channel]\n\n  # Special channel field that eager loads all the owner and does not do pagination\n  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]\n  counts: GroupCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  followers(page: Int = 1, per: Int = 1): [User]\n  href: String\n  id: Int\n  initials: String\n  is_current_user_a_member: Boolean\n  is_followed: Boolean\n\n  # Is *every* user in the group Premium?\n  is_premium(include_owner: Boolean = false): Boolean\n\n  # Are *any* users in the group upgradeable to Premium?\n  is_upgradeable(include_owner: Boolean = false): Boolean\n  manageable_user_ids: [Int]\n  memberships: [GroupMembership]\n  name: String\n  slug: String\n  subscription: PremiumSubscription\n  upcoming_invoice(coupon_code: String, plan_id: SupportedPlanEnum, quantity: Int): Invoice\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  users: [User]\n  visibility: String\n}\n\n# The actions that the CurrentUser can perform on the Group\ntype GroupCan {\n  add_to: Boolean\n  destroy: Boolean\n  follow: Boolean\n  manage: Boolean\n  manage_users: Boolean\n  update: Boolean\n}\n\ntype GroupCounts {\n  channels: Int\n  followers: Int\n  users: Int\n}\n\n# A membership defining the relationship between Groups and Users\ntype GroupMembership implements Model {\n  can: GroupMembershipCan\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  updated_at(format: String, relative: Boolean): String\n  user: User\n}\n\n# The actions that the CurrentUser can perform on the GroupMembership\ntype GroupMembershipCan {\n  manage: Boolean\n}\n\n# Relationship to group\nenum GroupType {\n  ALL\n  MEMBER\n  OWNER\n}\n\nunion Identifiable = Group | User\n\n# An object which exposes and names Users and Groups\ntype Identity {\n  identifiable: Identifiable!\n  name: String!\n  slug: String!\n}\n\n# An image block\ntype Image implements Block & ConnectableInterface & Model {\n  can: BlockCan\n  channels: [Channel]\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  counts: BlockCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  find_original_url: String\n  href: String\n  id: Int\n  image_url(size: ImageVersion = DISPLAY): String\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# Image sizes\nenum ImageVersion {\n  DISPLAY\n  LARGE\n  ORIGINAL\n  SQUARE\n  THUMB\n}\n\ntype IndexedChannels {\n  channels: [Channel]\n  key: String\n}\n\nenum IndexedChannelsTypes {\n  COLLABORATION\n  OWN\n}\n\n# Autogenerated input type of InitiateChannelTransfer\ninput InitiateChannelTransferInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  owner_id: ID\n  owner_type: ChannelOwnerTypeEnum\n  user_id: ID\n}\n\n# Autogenerated return type of InitiateChannelTransfer\ntype InitiateChannelTransferPayload {\n  channel_transfer_request: ChannelTransferRequest\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of InviteCollaborator\ninput InviteCollaboratorInput {\n  channel_id: ID!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String!\n}\n\n# Autogenerated return type of InviteCollaborator\ntype InviteCollaboratorPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of InviteGroupUsers\ninput InviteGroupUsersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  emails: [String!]!\n  id: ID!\n}\n\n# Autogenerated return type of InviteGroupUsers\ntype InviteGroupUsersPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  group: Group\n}\n\n# Autogenerated input type of InviteUsers\ninput InviteUsersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  emails: [String!]!\n}\n\n# Autogenerated return type of InviteUsers\ntype InviteUsersPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  users: [User]\n}\n\n# An invited user\ntype Invitee implements Model & UserInterface {\n  avatar(size: AvatarVersion): String\n  badge: String\n  bio(format: Format, no_links: Boolean = false): String\n  can: UserCan\n  channels(page: Int = 1, per: Int = 1): [Channel]\n\n  # Special channel field that eager loads all the owner and does not do pagination\n  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]\n  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = DEFAULT, type: ConnectableTypeEnum = null): [Connectable]\n  created_at(format: String, relative: Boolean): String\n  email: String\n  first_name: String\n  following(page: Int = 1, per: Int = 1): [FollowableType]\n  groups(page: Int = 1, per: Int = 1): [Group]\n  hidden_email: String\n  href(absolute: Boolean = false): String\n  id: Int\n  initials: String\n  is_canceled: Boolean\n  is_indexable: Boolean\n  is_investor: Boolean\n  is_me: Boolean\n  is_premium: Boolean\n  is_upgradeable: Boolean\n  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]\n  last_name: String\n  name: String\n  slug: String\n  updated_at(format: String, relative: Boolean): String\n}\n\ntype Invoice {\n  # Can be `null` in cases where there is a manually sent invoice\n  next_payment_attempt_at(format: String, relative: Boolean): String\n\n  # USD cents\n  subtotal: Int\n\n  # USD cents\n  total: Int\n}\n\nunion Konnectable = Attachment | Channel | Embed | Image | Link | PendingBlock | Text\n\n# A link block\ntype Link implements Block & ConnectableInterface & Model {\n  can: BlockCan\n  channels: [Channel]\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  counts: BlockCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  href: String\n  id: Int\n  image_url(size: ImageVersion = DISPLAY): String\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  source_url: String\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# Autogenerated input type of Login\ninput LoginInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String!\n  password: String!\n}\n\n# Autogenerated return type of Login\ntype LoginPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# The current user\ntype Me implements Model & UserInterface {\n  authenticated_service(provider: AuthenticatedServiceProvider = TWITTER): Authentication\n  authentication_token: String\n  avatar(size: AvatarVersion): String\n  badge: String\n  banner: BannerEnum\n  bio(format: Format, no_links: Boolean = false): String\n  can: UserCan\n  channels(page: Int = 1, per: Int = 1): [Channel]\n\n  # Special channel field that eager loads all the owner and does not do pagination\n  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]\n  connection_search(direction: Directions = DESC, per: Int = 5, q: String = null): [Channel]\n  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = DEFAULT, type: ConnectableTypeEnum = null): [Connectable]\n  counts: MeCounts\n  created_at(format: String, relative: Boolean): String\n  customer: Customer\n  email: String\n  feed(end: String = \"-inf\", limit: Int = 50, offset: Int = 0, start: String = \"+inf\", type: String = \"User\"): Feed\n  first_name: String\n  flag(name: String!): Boolean\n  flags: MeFlags\n  following(page: Int = 1, per: Int = 1): [FollowableType]\n  groups(page: Int = 1, per: Int = 1, type: GroupType = ALL): [Group]\n  hidden_email: String\n  home_path: String\n  href(absolute: Boolean = false): String\n  id: Int\n  initials: String\n  is_canceled: Boolean\n  is_confirmed: Boolean\n  is_exceeding_private_connections_limit: Boolean\n  is_indexable: Boolean\n  is_investor: Boolean\n  is_me: Boolean\n  is_pending_confirmation: Boolean\n  is_pending_reconfirmation: Boolean\n  is_premium: Boolean\n  is_upgradeable: Boolean\n  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]\n  last_name: String\n  name: String\n  non_premium_private_connections_limit: Int\n  notifications(end: String = \"-inf\", limit: Int = 50, offset: Int = 0, start: String = \"+inf\"): Feed\n  plan: String\n  plans: [Plan]\n\n  # Manifest for uploading new files to S3\n  policy: Policy\n  post_address: String\n  recent_connections(per: Int = 1): [Channel]\n  settings: MeSettings\n  slug: String\n  unconfirmed_email: String\n  updated_at(format: String, relative: Boolean): String\n}\n\ntype MeCounts implements UserCountsInterface {\n  blocks: Int\n  channels: Int\n  connections: Int\n  followers: Int\n  following: Int\n  groups: Int\n  notifications: Int\n  private_connections: Int\n  private_connections_limit: Int\n}\n\ninput MeFlagInput {\n  name: String!\n  value: Boolean!\n}\n\ntype MeFlags {\n  has_seen_feed_connect_twitter: Boolean\n}\n\n# Flag keys\nenum MeFlagsEnum {\n  HAS_SEEN_FEED_CONNECT_TWITTER\n}\n\ntype MeSettings {\n  exclude_from_indexes: Boolean\n  receive_email: String\n  receive_newsletter: Boolean\n  receive_tips_emails: Boolean\n  show_nsfw: Boolean\n  show_tour: Boolean\n}\n\n# Union of Channel members\nunion Member = Group | User\n\n# Member types\nenum MemberTypes {\n  GROUP\n  USER\n}\n\n# Fields common to all models\ninterface Model {\n  created_at(format: String, relative: Boolean): String\n  id: Int\n  updated_at(format: String, relative: Boolean): String\n}\n\n# Fields common to models that can be muted\ninterface Mutable {\n  is_muted: Boolean\n}\n\n# Mute-able object\nunion MutableType = Channel | Connectable\n\n# Objects that can be muted\nenum MutableTypeEnum {\n  BLOCK\n  CHANNEL\n}\n\ntype Mutation {\n  accept_channel_transfer(input: AcceptChannelTransferInput!): AcceptChannelTransferPayload\n  accept_invitation(input: AcceptInvitationInput!): AcceptInvitationPayload\n  add_channel_members(input: AddChannelMembersInput!): AddChannelMembersPayload\n  add_collaborators(input: AddCollaboratorInput!): AddCollaboratorPayload @deprecated(reason: \"Use `add_channel_member` instead\")\n  add_credit_card(input: AddCreditCardInput!): AddCreditCardPayload\n  add_group_users(input: AddGroupUsersInput!): AddGroupUsersPayload\n  apply_coupon_to_subscription(input: ApplyCouponToSubscriptionInput!): ApplyCouponToSubscriptionPayload\n  cancel_channel_transfer(input: CancelChannelTransferInput!): CancelChannelTransferPayload\n  cancel_premium_subscription(input: CancelPremiumSubscriptionInput!): CancelPremiumSubscriptionPayload\n  cancel_premium_subscriptions(input: CancelPremiumSubscriptionsInput!): CancelPremiumSubscriptionsPayload\n  clear_notifications(input: ClearNotificationsInput!): ClearNotificationsPayload\n  create_authenticated_service(input: CreateAuthenticatedServiceInput!): CreateAuthenticatedServicePayload\n  create_block(input: CreateBlockInput!): CreateBlockPayload\n  create_channel(input: CreateChannelInput!): CreateChannelPayload\n  create_comment(input: CreateCommentInput!): CreateCommentPayload\n  create_connection(input: CreateConnectionInput!): CreateConnectionPayload\n  create_group(input: CreateGroupInput!): CreateGroupPayload\n  create_user_message_channel(input: CreateUserMessageChannelInput!): CreateUserMessageChannelPayload\n  delete_authenticated_service(input: DeleteAuthenticatedServiceInput!): DeleteAuthenticatedServicePayload\n  delete_channel(input: DeleteChannelInput!): DeleteChannelPayload\n  delete_comment(input: DeleteCommentInput!): DeleteCommentPayload\n  delete_connection(input: DeleteConnectionInput!): DeleteConnectionPayload\n  delete_group(input: DeleteGroupInput!): DeleteGroupPayload\n  dismiss_banner(input: DismissBannerInput!): DismissBannerPayload\n  export_channel(input: ExportChannelInput!): ExportChannelPayload\n  follow(input: FollowInput!): FollowPayload\n  initiate_channel_transfer(input: InitiateChannelTransferInput!): InitiateChannelTransferPayload\n  invite_collaborator(input: InviteCollaboratorInput!): InviteCollaboratorPayload @deprecated(reason: \"Use `invite_channel_member` instead\")\n  invite_group_users(input: InviteGroupUsersInput!): InviteGroupUsersPayload\n  invite_users(input: InviteUsersInput!): InviteUsersPayload\n  login(input: LoginInput!): LoginPayload\n  mute(input: MuteInput!): MutePayload\n  mute_channel(input: MuteChannelInput!): MuteChannelPayload @deprecated(reason: \"Use `mute` instead\")\n  read_notification(input: ReadNotificationInput!): ReadNotificationPayload\n  registration(input: RegistrationInput!): RegistrationPayload\n  reject_channel_transfer(input: RejectChannelTransferInput!): RejectChannelTransferPayload\n  remove_channel_members(input: RemoveChannelMembersInput!): RemoveChannelMembersPayload\n  remove_collaborators(input: RemoveCollaboratorInput!): RemoveCollaboratorPayload @deprecated(reason: \"Use `remove_channel_member` instead\")\n  remove_connection(input: RemoveConnectionInput!): RemoveConnectionPayload\n  remove_credit_card(input: RemoveCreditCardInput!): RemoveCreditCardPayload\n  remove_group_users(input: RemoveGroupUsersInput!): RemoveGroupUsersPayload\n  request_password_reset(input: RequestPasswordResetInput!): RequestPasswordResetPayload\n  resend_confirmation_email(input: ResendConfirmationEmailInput!): ResendConfirmationEmailPayload\n  reset_password(input: ResetPasswordInput!): ResetPasswordPayload\n  set_me_flags(input: SetMeFlagsInput!): SetMeFlagsPayload\n  share_channel(input: ShareChannelInput!): ShareChannelPayload\n  subscribe_to_premium(input: SubscribeToPremiumInput!): SubscribeToPremiumPayload\n  subscribe_to_premium_for_users(input: SubscribeToPremiumForUsersInput!): SubscribeToPremiumForUsersPayload\n  unfollow(input: UnfollowInput!): UnfollowPayload\n  unmute(input: UnmuteInput!): UnmutePayload\n  unmute_channel(input: UnmuteChannelInput!): UnmuteChannelPayload @deprecated(reason: \"Use `unmute` instead\")\n  update_account(input: UpdateAccountInput!): UpdateAccountPayload\n  update_block(input: UpdateBlockInput!): UpdateBlockPayload\n  update_channel(input: UpdateChannelInput!): UpdateChannelPayload\n  update_customer(input: UpdateCustomerInput!): UpdateCustomerPayload\n  update_flag(input: UpdateFlagInput!): UpdateFlagPayload @deprecated(reason: \"Use `set_me_flags` instead\")\n  update_group(input: UpdateGroupInput!): UpdateGroupPayload\n}\n\n# Autogenerated input type of MuteChannel\ninput MuteChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of MuteChannel\ntype MuteChannelPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of Mute\ninput MuteInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  type: MutableTypeEnum!\n}\n\n# Autogenerated return type of Mute\ntype MutePayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  mutable: MutableType\n}\n\n# An empty object\ntype Null {\n  is_null: Boolean\n}\n\n# A block which has not yet found its calling\ntype PendingBlock implements Block & ConnectableInterface & Model {\n  can: BlockCan\n  channels: [Channel]\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  counts: BlockCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  href: String\n  id: Int\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  remote_source_url: String\n  source: ConnectableSource\n  source_title: String\n  source_url: String\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\ntype Plan {\n  # USD cents\n  amount: Float\n  external_id: String\n  id: ID\n  is_hidden: Boolean\n  period_end_at(format: String, relative: Boolean): String\n  period_start_at(format: String, relative: Boolean): String\n  term: String\n}\n\n# A policy\ntype Policy {\n  AWSAccessKeyId: String\n  acl: String\n  bucket: String\n  expires: String\n  key: String\n  policy: String\n  signature: String\n  success_action_status: String\n}\n\ntype PremiumSubscription {\n  canceled_at(format: String, relative: Boolean): String\n  current_period_end_at(format: String, relative: Boolean): String\n  current_period_start_at(format: String, relative: Boolean): String\n  id: ID\n  is_canceled: Boolean\n  plan: Plan\n  plan_id: String\n  users(status: CustomerStatuses = ACTIVE): [User]\n}\n\n# The query root for this schema\ntype Query {\n  block(id: ID!): Connectable @deprecated(reason: \"Use `blokk` until this can be replaced with it\")\n  blokk(id: ID!): Konnectable\n\n  # A single channel\n  channel(id: ID!): Channel\n\n  # Multiple channels\n  channels(ids: [ID]!): [Channel]\n  coupon(code: String!): Coupon\n  explore(direction: Directions = DESC, page: Int = 1, per: Int = 1, sort_by: SearchSorts = null, type: SearchType): [SearchResult]\n  exxplore(direction: Directions = DESC, page: Int = 1, per: Int = 1, seed: Int = 87, sort_by: SearchSorts = null, type: SearchType): [Konnectable]\n\n  # Interface for getting the follow status of users or channels\n  followable(id: ID, type: FollowableTypeEnum): FollowableType\n  group(id: ID!): Group\n  identity(id: ID!): Identity\n\n  # Locates the invited user through their invitation token\n  invitee(invitation_token: String!): Invitee\n\n  # The current logged in user\n  me: Me\n\n  # Interface for getting the mute status of blocks or channels\n  mutable(id: ID!, type: MutableTypeEnum!): MutableType\n\n  # Locates the user through their reset password token\n  password_resettable_user(reset_password_token: String!): User\n  password_token(token: ID!): User\n  random_title: String\n  search(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String! = null, seed: Int = 87, sort_by: SearchSorts = null, type: SearchType = null): [SearchResult]\n  searches: Searches\n  ssearch(block_filter: BlockFilterEnum = null, direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String! = null, seed: Int = 87, sort_by: SearchSorts = null, type: [SsearchType] = [USER, GROUP, CHANNEL, BLOCK]): [SsearchResult]\n\n  # Is this endpoint operational?\n  status: String\n\n  # A single user\n  user(id: ID!): User\n}\n\n# Possible types for quick search results\nunion QuickSearchResult = Channel | Group | User\n\n# Autogenerated input type of ReadNotification\ninput ReadNotificationInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  notification_id: ID!\n}\n\n# Autogenerated return type of ReadNotification\ntype ReadNotificationPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  deed: Deed\n}\n\n# Autogenerated input type of Registration\ninput RegistrationInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String!\n  first_name: String!\n  last_name: String!\n  password: String!\n  password_confirmation: String!\n  receive_newsletter: Boolean\n  receive_tips_emails: Boolean\n  validation_token: String\n}\n\n# Autogenerated return type of Registration\ntype RegistrationPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Autogenerated input type of RejectChannelTransfer\ninput RejectChannelTransferInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  token: String!\n}\n\n# Autogenerated return type of RejectChannelTransfer\ntype RejectChannelTransferPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of RemoveChannelMembers\ninput RemoveChannelMembersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  members: [ChannelMemberInput]!\n}\n\n# Autogenerated return type of RemoveChannelMembers\ntype RemoveChannelMembersPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of RemoveCollaborator\ninput RemoveCollaboratorInput {\n  channel_id: ID!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  user_ids: [ID]!\n}\n\n# Autogenerated return type of RemoveCollaborator\ntype RemoveCollaboratorPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of RemoveConnection\ninput RemoveConnectionInput {\n  channel_id: ID!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  connectable_id: ID!\n  connectable_type: BaseConnectableTypeEnum!\n}\n\n# Autogenerated return type of RemoveConnection\ntype RemoveConnectionPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  status: String\n}\n\n# Autogenerated input type of RemoveCreditCard\ninput RemoveCreditCardInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: String!\n}\n\n# Autogenerated return type of RemoveCreditCard\ntype RemoveCreditCardPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  customer: Customer\n}\n\n# Autogenerated input type of RemoveGroupUsers\ninput RemoveGroupUsersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  user_ids: [ID]!\n}\n\n# Autogenerated return type of RemoveGroupUsers\ntype RemoveGroupUsersPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  group: Group\n}\n\n# Autogenerated input type of RequestPasswordReset\ninput RequestPasswordResetInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String!\n}\n\n# Autogenerated return type of RequestPasswordReset\ntype RequestPasswordResetPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String\n}\n\n# Autogenerated input type of ResendConfirmationEmail\ninput ResendConfirmationEmailInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated return type of ResendConfirmationEmail\ntype ResendConfirmationEmailPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Autogenerated input type of ResetPassword\ninput ResetPasswordInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  password: String!\n  password_confirmation: String!\n  token: String!\n}\n\n# Autogenerated return type of ResetPassword\ntype ResetPasswordPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Possible types for search results\nunion SearchResult = Channel | Connectable | Group | User\n\n# Ways to sort blocks\nenum SearchSorts {\n  ALPHA\n  CREATED_AT\n  DEFAULT\n  FOLLOWER_COUNT\n  LENGTH\n  RANDOM\n  UPDATED_AT\n}\n\n# Ways to filter search by type\nenum SearchType {\n  ALL\n  CHANNEL\n  CONNECTABLE\n  USER\n}\n\ntype Searches {\n  collaborators(limit: Int = 10, query: String!, types: [SearchesCollaboratorsType] = [USER, GROUP]): [Member]\n  quick(limit: Int = 6, query: String!): [QuickSearchResult]\n}\n\nenum SearchesCollaboratorsType {\n  GROUP\n  USER\n}\n\n# Autogenerated input type of SetMeFlags\ninput SetMeFlagsInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  flags: [MeFlagInput]\n}\n\n# Autogenerated return type of SetMeFlags\ntype SetMeFlagsPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Autogenerated input type of ShareChannel\ninput ShareChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  enable: Boolean!\n  id: ID!\n}\n\n# Autogenerated return type of ShareChannel\ntype ShareChannelPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# A spooky connectable\ntype SkeletalConnectable {\n  id: Int\n  type: String\n}\n\n# Ways to sort blocks\nenum Sorts {\n  CREATED_AT\n  POSITION\n  UPDATED_AT\n}\n\n# Possible types for search results\nunion SsearchResult = Attachment | Channel | Embed | Group | Image | Link | PendingBlock | Text | User\n\n# Ways to filter search by type\nenum SsearchType {\n  BLOCK\n  CHANNEL\n  GROUP\n  USER\n}\n\n# Autogenerated input type of SubscribeToPremiumForUsers\ninput SubscribeToPremiumForUsersInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coupon_code: String\n\n  # ID of Group that users are a member of\n  group_id: ID!\n  plan_id: SupportedPlanEnum!\n\n  # Tokenized card/card ID from Stripe\n  token: String!\n\n  # IDs of Users that this subscription should apply to\n  user_ids: [ID]!\n}\n\n# Autogenerated return type of SubscribeToPremiumForUsers\ntype SubscribeToPremiumForUsersPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  group: Group\n  me: Me\n  users: [User]\n}\n\n# Autogenerated input type of SubscribeToPremium\ninput SubscribeToPremiumInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coupon_code: String\n  plan_id: SupportedPlanEnum!\n\n  # Tokenized card from Stripe\n  token: String!\n}\n\n# Autogenerated return type of SubscribeToPremium\ntype SubscribeToPremiumPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Subscription plans that are purchaseable by users\nenum SupportedPlanEnum {\n  MONTHLY\n  YEARLY\n}\n\n# A text block\ntype Text implements Block & ConnectableInterface & Model {\n  can: BlockCan\n  channels: [Channel]\n  channels_with_same_source(page: Int = 1, per: Int = 1): [Channel]\n  comments(direction: Directions = ASC): [Comment] @deprecated(reason: \"Channels do not have comments. Call this on Block.\")\n\n  # Returns the outer channel if we are inside of one\n  connection: Connection\n  connections: [Connection]\n  content(format: Format, no_links: Boolean = false): String\n  counts: BlockCounts\n  created_at(format: String, relative: Boolean): String\n  description(format: Format, no_links: Boolean = false): String\n  find_original_url: String\n  href: String\n  id: Int\n  is_muted: Boolean\n  kind: ConnectableKind @deprecated(reason: \"Avoid using if at all possible\")\n  klass: String\n  private_accessible_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  public_channels(direction: Directions = DESC, page: Int = 1, per: Int = 1): [Channel]\n  source: ConnectableSource\n  state: String\n  title(truncate: Int): String\n  to_s(truncate: Int): String\n  updated_at(format: String, relative: Boolean): String\n  user: User\n  visibility: String\n}\n\n# Autogenerated input type of Unfollow\ninput UnfollowInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  type: FollowableTypeEnum!\n}\n\n# Autogenerated return type of Unfollow\ntype UnfollowPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  followable: FollowableType\n}\n\n# Autogenerated input type of UnmuteChannel\ninput UnmuteChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n}\n\n# Autogenerated return type of UnmuteChannel\ntype UnmuteChannelPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of Unmute\ninput UnmuteInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: ID!\n  type: MutableTypeEnum!\n}\n\n# Autogenerated return type of Unmute\ntype UnmutePayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  mutable: MutableType\n}\n\n# Autogenerated input type of UpdateAccount\ninput UpdateAccountInput {\n  bio: String\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  email: String\n  exclude_from_indexes: Boolean\n  first_name: String\n  home_path: String\n  last_name: String\n  receive_email: String\n  receive_newsletter: Boolean\n  show_nsfw: Boolean\n  show_tour: Boolean\n}\n\n# Autogenerated return type of UpdateAccount\ntype UpdateAccountPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  me: Me\n}\n\n# Autogenerated input type of UpdateBlock\ninput UpdateBlockInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  content: String\n  description: String\n  id: ID!\n  title: String\n}\n\n# Autogenerated return type of UpdateBlock\ntype UpdateBlockPayload {\n  block: Connectable\n  blokk: Konnectable\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of UpdateChannel\ninput UpdateChannelInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  content_flag: ContentFlag\n  description: String\n  id: ID!\n  owner: ChannelMemberInput\n  title: String\n  visibility: ChannelVisibility\n}\n\n# Autogenerated return type of UpdateChannel\ntype UpdateChannelPayload {\n  channel: Channel\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated input type of UpdateCustomer\ninput UpdateCustomerInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  default_credit_card_id: String\n}\n\n# Autogenerated return type of UpdateCustomer\ntype UpdateCustomerPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  customer: Customer\n}\n\n# Autogenerated input type of UpdateFlag\ninput UpdateFlagInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  name: MeFlagsEnum!\n  value: Boolean!\n}\n\n# Autogenerated return type of UpdateFlag\ntype UpdateFlagPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  flags: MeFlags\n}\n\n# Autogenerated input type of UpdateGroup\ninput UpdateGroupInput {\n  avatar_url: String\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  description: String\n  id: ID!\n  name: String\n}\n\n# Autogenerated return type of UpdateGroup\ntype UpdateGroupPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  group: Group\n}\n\n# A single user\ntype User implements Followable & Model & UserInterface {\n  avatar(size: AvatarVersion): String\n  badge: String\n  bio(format: Format, no_links: Boolean = false): String\n  can: UserCan\n  channels(page: Int = 1, per: Int = 1): [Channel]\n\n  # Special channel field that eager loads all the owner and does not do pagination\n  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]\n  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = DEFAULT, type: ConnectableTypeEnum = null): [Connectable]\n  counts: UserCounts\n  created_at(format: String, relative: Boolean): String\n  first_name: String\n  followers(page: Int = 1, per: Int = 1): [User]\n  following(page: Int = 1, per: Int = 1): [FollowableType]\n  groups(page: Int = 1, per: Int = 1): [Group]\n  hidden_email: String\n  href(absolute: Boolean = false): String\n  id: Int\n  initials: String\n  is_canceled: Boolean\n  is_followed: Boolean\n  is_indexable: Boolean\n  is_investor: Boolean\n  is_me: Boolean\n  is_premium: Boolean\n  is_upgradeable: Boolean\n  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]\n  last_name: String\n  name: String\n  slug: String\n  updated_at(format: String, relative: Boolean): String\n}\n\n# The actions that the CurrentUser can perform on the User\ntype UserCan {\n  cancel_premium: Boolean\n  follow: Boolean\n  manage: Boolean\n  message: Boolean\n}\n\ntype UserCounts implements UserCountsInterface {\n  blocks: Int\n  channels: Int\n  connections: Int\n  followers: Int\n  following: Int\n  groups: Int\n}\n\ninterface UserCountsInterface {\n  blocks: Int\n  channels: Int\n  connections: Int\n  followers: Int\n  following: Int\n  groups: Int\n}\n\n# Fields common to all users\ninterface UserInterface {\n  avatar(size: AvatarVersion): String\n  badge: String\n  bio(format: Format, no_links: Boolean = false): String\n  can: UserCan\n  channels(page: Int = 1, per: Int = 1): [Channel]\n\n  # Special channel field that eager loads all the owner and does not do pagination\n  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]\n  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = DEFAULT, type: ConnectableTypeEnum = null): [Connectable]\n  first_name: String\n  following(page: Int = 1, per: Int = 1): [FollowableType]\n  groups(page: Int = 1, per: Int = 1): [Group]\n  hidden_email: String\n  href(absolute: Boolean = false): String\n  initials: String\n  is_canceled: Boolean\n  is_indexable: Boolean\n  is_investor: Boolean\n  is_me: Boolean\n  is_premium: Boolean\n  is_upgradeable: Boolean\n  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 87, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]\n  last_name: String\n  name: String\n  slug: String\n}",
      "containsQueryType": true,
      "typesUndefined": [],
      "directivesUndefined": [
        "deprecated"
      ],
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 110,
      "containsCycle": true,
      "numDefinitions": 216
    }
  ],
  "metrics": {
    "created_at": "2014-08-01T17:44:16Z",
    "updated_at": "2019-07-19T16:46:16Z",
    "pushed_at": "2019-07-19T17:16:31Z",
    "issues": 807,
    "watchers": 16,
    "fork_count": 9,
    "has_wiki_enabled": true,
    "license": "mit",
    "pull_requests": 1314,
    "pull_requests_open": 0,
    "pull_requests_closed": 54,
    "pull_requests_merged": 1260,
    "releases": 0,
    "stargazers": 73
  }
}