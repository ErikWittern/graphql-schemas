{
  "repo_name": "acnw2",
  "repo_full_name": "ggascoigne/acnw2",
  "repo_owner": "ggascoigne",
  "repo_description": null,
  "repo_private": false,
  "repo_fork": false,
  "schemas": [
    {
      "name": "graphql-schema.graphql",
      "path": "packages/ui/graphql-schema.graphql",
      "sha": "9da5aa81bd041b985f45938d4aac55d681efcb6d",
      "url": "https://api.github.com/repositories/163881036/contents/packages/ui/graphql-schema.graphql?ref=def4b0f30ed3144ee236b21532fec854bf10fb47",
      "git_url": "https://api.github.com/repositories/163881036/git/blobs/9da5aa81bd041b985f45938d4aac55d681efcb6d",
      "html_url": "https://github.com/ggascoigne/acnw2/blob/def4b0f30ed3144ee236b21532fec854bf10fb47/packages/ui/graphql-schema.graphql",
      "content": "# A floating point number that requires more precision than IEEE 754 binary 64\nscalar BigFloat\n\n# A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’\ninput BigFloatFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: BigFloat\n\n  # Not equal to the specified value.\n  notEqualTo: BigFloat\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: BigFloat\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: BigFloat\n\n  # Included in the specified list.\n  in: [BigFloat!]\n\n  # Not included in the specified list.\n  notIn: [BigFloat!]\n\n  # Less than the specified value.\n  lessThan: BigFloat\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: BigFloat\n\n  # Greater than the specified value.\n  greaterThan: BigFloat\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: BigFloat\n}\n\n# A signed eight-byte integer. The upper big integer values are greater then the\n# max value for a JavaScript number. Therefore all big integers will be output as\n# strings and not numbers.\nscalar BigInt\n\n# A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’\ninput BigIntFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: BigInt\n\n  # Not equal to the specified value.\n  notEqualTo: BigInt\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: BigInt\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: BigInt\n\n  # Included in the specified list.\n  in: [BigInt!]\n\n  # Not included in the specified list.\n  notIn: [BigInt!]\n\n  # Less than the specified value.\n  lessThan: BigInt\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: BigInt\n\n  # Greater than the specified value.\n  greaterThan: BigInt\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: BigInt\n}\n\n# A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’\ninput BooleanFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: Boolean\n\n  # Not equal to the specified value.\n  notEqualTo: Boolean\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: Boolean\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: Boolean\n\n  # Included in the specified list.\n  in: [Boolean!]\n\n  # Not included in the specified list.\n  notIn: [Boolean!]\n\n  # Less than the specified value.\n  lessThan: Boolean\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: Boolean\n\n  # Greater than the specified value.\n  greaterThan: Boolean\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: Boolean\n}\n\n# All input for the create `GameAssignment` mutation.\ninput CreateGameAssignmentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `GameAssignment` to be created by this mutation.\n  gameAssignment: GameAssignmentInput!\n}\n\n# The output of our create `GameAssignment` mutation.\ntype CreateGameAssignmentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameAssignment` that was created by this mutation.\n  gameAssignment: GameAssignment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `GameAssignment`.\n  member: Membership\n\n  # Reads a single `Game` that is related to this `GameAssignment`.\n  game: Game\n\n  # An edge for our `GameAssignment`. May be used by Relay 1.\n  gameAssignmentEdge(\n    # The method to use when ordering `GameAssignment`.\n    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameAssignmentsEdge\n}\n\n# All input for the create `GameChoice` mutation.\ninput CreateGameChoiceInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `GameChoice` to be created by this mutation.\n  gameChoice: GameChoiceInput!\n}\n\n# The output of our create `GameChoice` mutation.\ntype CreateGameChoicePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameChoice` that was created by this mutation.\n  gameChoice: GameChoice\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Game` that is related to this `GameChoice`.\n  game: Game\n\n  # Reads a single `Membership` that is related to this `GameChoice`.\n  member: Membership\n\n  # Reads a single `Slot` that is related to this `GameChoice`.\n  slot: Slot\n\n  # An edge for our `GameChoice`. May be used by Relay 1.\n  gameChoiceEdge(\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameChoicesEdge\n}\n\n# All input for the create `Game` mutation.\ninput CreateGameInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Game` to be created by this mutation.\n  game: GameInput!\n}\n\n# The output of our create `Game` mutation.\ntype CreateGamePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Game` that was created by this mutation.\n  game: Game\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Room` that is related to this `Game`.\n  room: Room\n\n  # Reads a single `Slot` that is related to this `Game`.\n  slot: Slot\n\n  # Reads a single `User` that is related to this `Game`.\n  author: User\n\n  # An edge for our `Game`. May be used by Relay 1.\n  gameEdge(\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GamesEdge\n}\n\n# All input for the create `GameSubmission` mutation.\ninput CreateGameSubmissionInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `GameSubmission` to be created by this mutation.\n  gameSubmission: GameSubmissionInput!\n}\n\n# The output of our create `GameSubmission` mutation.\ntype CreateGameSubmissionPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameSubmission` that was created by this mutation.\n  gameSubmission: GameSubmission\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `GameSubmission`.\n  member: Membership\n\n  # An edge for our `GameSubmission`. May be used by Relay 1.\n  gameSubmissionEdge(\n    # The method to use when ordering `GameSubmission`.\n    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameSubmissionsEdge\n}\n\n# All input for the create `HotelRoomDetail` mutation.\ninput CreateHotelRoomDetailInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `HotelRoomDetail` to be created by this mutation.\n  hotelRoomDetail: HotelRoomDetailInput!\n}\n\n# The output of our create `HotelRoomDetail` mutation.\ntype CreateHotelRoomDetailPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `HotelRoomDetail` that was created by this mutation.\n  hotelRoomDetail: HotelRoomDetail\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `HotelRoomDetail`. May be used by Relay 1.\n  hotelRoomDetailEdge(\n    # The method to use when ordering `HotelRoomDetail`.\n    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): HotelRoomDetailsEdge\n}\n\n# All input for the create `HotelRoom` mutation.\ninput CreateHotelRoomInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `HotelRoom` to be created by this mutation.\n  hotelRoom: HotelRoomInput!\n}\n\n# The output of our create `HotelRoom` mutation.\ntype CreateHotelRoomPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `HotelRoom` that was created by this mutation.\n  hotelRoom: HotelRoom\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `HotelRoom`. May be used by Relay 1.\n  hotelRoomEdge(\n    # The method to use when ordering `HotelRoom`.\n    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): HotelRoomsEdge\n}\n\n# All input for the create `Lookup` mutation.\ninput CreateLookupInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Lookup` to be created by this mutation.\n  lookup: LookupInput!\n}\n\n# The output of our create `Lookup` mutation.\ntype CreateLookupPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Lookup` that was created by this mutation.\n  lookup: Lookup\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Lookup`. May be used by Relay 1.\n  lookupEdge(\n    # The method to use when ordering `Lookup`.\n    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): LookupsEdge\n}\n\n# All input for the create `LookupValue` mutation.\ninput CreateLookupValueInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `LookupValue` to be created by this mutation.\n  lookupValue: LookupValueInput!\n}\n\n# The output of our create `LookupValue` mutation.\ntype CreateLookupValuePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `LookupValue` that was created by this mutation.\n  lookupValue: LookupValue\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Lookup` that is related to this `LookupValue`.\n  lookup: Lookup\n\n  # An edge for our `LookupValue`. May be used by Relay 1.\n  lookupValueEdge(\n    # The method to use when ordering `LookupValue`.\n    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): LookupValuesEdge\n}\n\n# All input for the create `MemberHotelRoomAssignment` mutation.\ninput CreateMemberHotelRoomAssignmentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `MemberHotelRoomAssignment` to be created by this mutation.\n  memberHotelRoomAssignment: MemberHotelRoomAssignmentInput!\n}\n\n# The output of our create `MemberHotelRoomAssignment` mutation.\ntype CreateMemberHotelRoomAssignmentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `MemberHotelRoomAssignment` that was created by this mutation.\n  memberHotelRoomAssignment: MemberHotelRoomAssignment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`.\n  member: Membership\n\n  # Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`.\n  hotelRoom: HotelRoomDetail\n\n  # An edge for our `MemberHotelRoomAssignment`. May be used by Relay 1.\n  memberHotelRoomAssignmentEdge(\n    # The method to use when ordering `MemberHotelRoomAssignment`.\n    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): MemberHotelRoomAssignmentsEdge\n}\n\n# All input for the create `Membership` mutation.\ninput CreateMembershipInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Membership` to be created by this mutation.\n  membership: MembershipInput!\n}\n\n# The output of our create `Membership` mutation.\ntype CreateMembershipPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Membership` that was created by this mutation.\n  membership: Membership\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `HotelRoom` that is related to this `Membership`.\n  hotelRoom: HotelRoom\n\n  # Reads a single `User` that is related to this `Membership`.\n  user: User\n\n  # An edge for our `Membership`. May be used by Relay 1.\n  membershipEdge(\n    # The method to use when ordering `Membership`.\n    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): MembershipsEdge\n}\n\n# All input for the create `Profile` mutation.\ninput CreateProfileInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Profile` to be created by this mutation.\n  profile: ProfileInput!\n}\n\n# The output of our create `Profile` mutation.\ntype CreateProfilePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Profile` that was created by this mutation.\n  profile: Profile\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Profile`. May be used by Relay 1.\n  profileEdge(\n    # The method to use when ordering `Profile`.\n    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ProfilesEdge\n}\n\n# All input for the create `RegistrationCode` mutation.\ninput CreateRegistrationCodeInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `RegistrationCode` to be created by this mutation.\n  registrationCode: RegistrationCodeInput!\n}\n\n# The output of our create `RegistrationCode` mutation.\ntype CreateRegistrationCodePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `RegistrationCode` that was created by this mutation.\n  registrationCode: RegistrationCode\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `RegistrationCode`. May be used by Relay 1.\n  registrationCodeEdge(\n    # The method to use when ordering `RegistrationCode`.\n    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RegistrationCodesEdge\n}\n\n# All input for the create `Role` mutation.\ninput CreateRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Role` to be created by this mutation.\n  role: RoleInput!\n}\n\n# The output of our create `Role` mutation.\ntype CreateRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Role` that was created by this mutation.\n  role: Role\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Role`. May be used by Relay 1.\n  roleEdge(\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RolesEdge\n}\n\n# All input for the create `Room` mutation.\ninput CreateRoomInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Room` to be created by this mutation.\n  room: RoomInput!\n}\n\n# The output of our create `Room` mutation.\ntype CreateRoomPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Room` that was created by this mutation.\n  room: Room\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Room`. May be used by Relay 1.\n  roomEdge(\n    # The method to use when ordering `Room`.\n    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RoomsEdge\n}\n\n# All input for the create `Setting` mutation.\ninput CreateSettingInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Setting` to be created by this mutation.\n  setting: SettingInput!\n}\n\n# The output of our create `Setting` mutation.\ntype CreateSettingPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Setting` that was created by this mutation.\n  setting: Setting\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Setting`. May be used by Relay 1.\n  settingEdge(\n    # The method to use when ordering `Setting`.\n    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): SettingsEdge\n}\n\n# All input for the create `ShirtOrder` mutation.\ninput CreateShirtOrderInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `ShirtOrder` to be created by this mutation.\n  shirtOrder: ShirtOrderInput!\n}\n\n# All input for the create `ShirtOrderItem` mutation.\ninput CreateShirtOrderItemInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `ShirtOrderItem` to be created by this mutation.\n  shirtOrderItem: ShirtOrderItemInput!\n}\n\n# The output of our create `ShirtOrderItem` mutation.\ntype CreateShirtOrderItemPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `ShirtOrderItem` that was created by this mutation.\n  shirtOrderItem: ShirtOrderItem\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`.\n  order: ShirtOrder\n\n  # An edge for our `ShirtOrderItem`. May be used by Relay 1.\n  shirtOrderItemEdge(\n    # The method to use when ordering `ShirtOrderItem`.\n    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ShirtOrderItemsEdge\n}\n\n# The output of our create `ShirtOrder` mutation.\ntype CreateShirtOrderPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `ShirtOrder` that was created by this mutation.\n  shirtOrder: ShirtOrder\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `User` that is related to this `ShirtOrder`.\n  user: User\n\n  # An edge for our `ShirtOrder`. May be used by Relay 1.\n  shirtOrderEdge(\n    # The method to use when ordering `ShirtOrder`.\n    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ShirtOrdersEdge\n}\n\n# All input for the create `Slot` mutation.\ninput CreateSlotInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Slot` to be created by this mutation.\n  slot: SlotInput!\n}\n\n# The output of our create `Slot` mutation.\ntype CreateSlotPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Slot` that was created by this mutation.\n  slot: Slot\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Slot`. May be used by Relay 1.\n  slotEdge(\n    # The method to use when ordering `Slot`.\n    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): SlotsEdge\n}\n\n# All input for the create `Token` mutation.\ninput CreateTokenInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `Token` to be created by this mutation.\n  token: TokenInput!\n}\n\n# The output of our create `Token` mutation.\ntype CreateTokenPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Token` that was created by this mutation.\n  token: Token\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `User` that is related to this `Token`.\n  user: User\n\n  # An edge for our `Token`. May be used by Relay 1.\n  tokenEdge(\n    # The method to use when ordering `Token`.\n    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]\n  ): TokensEdge\n}\n\n# All input for the create `User` mutation.\ninput CreateUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `User` to be created by this mutation.\n  user: UserInput!\n}\n\n# The output of our create `User` mutation.\ntype CreateUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `User` that was created by this mutation.\n  user: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Profile` that is related to this `User`.\n  profile: Profile\n\n  # An edge for our `User`. May be used by Relay 1.\n  userEdge(\n    # The method to use when ordering `User`.\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n  ): UsersEdge\n}\n\n# All input for the create `UserRole` mutation.\ninput CreateUserRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The `UserRole` to be created by this mutation.\n  userRole: UserRoleInput!\n}\n\n# The output of our create `UserRole` mutation.\ntype CreateUserRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `UserRole` that was created by this mutation.\n  userRole: UserRole\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `UserRole`.\n  role: Role\n\n  # Reads a single `User` that is related to this `UserRole`.\n  user: User\n\n  # An edge for our `UserRole`. May be used by Relay 1.\n  userRoleEdge(\n    # The method to use when ordering `UserRole`.\n    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): UserRolesEdge\n}\n\n# A location in a connection that can be used for resuming pagination.\nscalar Cursor\n\n# A point in time as described by the [ISO\n# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\nscalar Datetime\n\n# A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’\ninput DatetimeFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: Datetime\n\n  # Not equal to the specified value.\n  notEqualTo: Datetime\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: Datetime\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: Datetime\n\n  # Included in the specified list.\n  in: [Datetime!]\n\n  # Not included in the specified list.\n  notIn: [Datetime!]\n\n  # Less than the specified value.\n  lessThan: Datetime\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: Datetime\n\n  # Greater than the specified value.\n  greaterThan: Datetime\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: Datetime\n}\n\n# All input for the `deleteGameAssignmentByNodeId` mutation.\ninput DeleteGameAssignmentByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `GameAssignment` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteGameAssignment` mutation.\ninput DeleteGameAssignmentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  memberId: Int!\n  gameId: Int!\n  gm: Int!\n}\n\n# The output of our delete `GameAssignment` mutation.\ntype DeleteGameAssignmentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameAssignment` that was deleted by this mutation.\n  gameAssignment: GameAssignment\n  deletedGameAssignmentNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `GameAssignment`.\n  member: Membership\n\n  # Reads a single `Game` that is related to this `GameAssignment`.\n  game: Game\n\n  # An edge for our `GameAssignment`. May be used by Relay 1.\n  gameAssignmentEdge(\n    # The method to use when ordering `GameAssignment`.\n    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameAssignmentsEdge\n}\n\n# All input for the `deleteGameByNodeId` mutation.\ninput DeleteGameByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Game` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteGameChoiceByNodeId` mutation.\ninput DeleteGameChoiceByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `GameChoice` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteGameChoice` mutation.\ninput DeleteGameChoiceInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `GameChoice` mutation.\ntype DeleteGameChoicePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameChoice` that was deleted by this mutation.\n  gameChoice: GameChoice\n  deletedGameChoiceNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Game` that is related to this `GameChoice`.\n  game: Game\n\n  # Reads a single `Membership` that is related to this `GameChoice`.\n  member: Membership\n\n  # Reads a single `Slot` that is related to this `GameChoice`.\n  slot: Slot\n\n  # An edge for our `GameChoice`. May be used by Relay 1.\n  gameChoiceEdge(\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameChoicesEdge\n}\n\n# All input for the `deleteGame` mutation.\ninput DeleteGameInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Game` mutation.\ntype DeleteGamePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Game` that was deleted by this mutation.\n  game: Game\n  deletedGameNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Room` that is related to this `Game`.\n  room: Room\n\n  # Reads a single `Slot` that is related to this `Game`.\n  slot: Slot\n\n  # Reads a single `User` that is related to this `Game`.\n  author: User\n\n  # An edge for our `Game`. May be used by Relay 1.\n  gameEdge(\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GamesEdge\n}\n\n# All input for the `deleteGameSubmissionByNodeId` mutation.\ninput DeleteGameSubmissionByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `GameSubmission` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteGameSubmission` mutation.\ninput DeleteGameSubmissionInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `GameSubmission` mutation.\ntype DeleteGameSubmissionPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameSubmission` that was deleted by this mutation.\n  gameSubmission: GameSubmission\n  deletedGameSubmissionNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `GameSubmission`.\n  member: Membership\n\n  # An edge for our `GameSubmission`. May be used by Relay 1.\n  gameSubmissionEdge(\n    # The method to use when ordering `GameSubmission`.\n    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameSubmissionsEdge\n}\n\n# All input for the `deleteHotelRoomByNodeId` mutation.\ninput DeleteHotelRoomByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `HotelRoom` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteHotelRoomDetailByNodeId` mutation.\ninput DeleteHotelRoomDetailByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `HotelRoomDetail` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteHotelRoomDetail` mutation.\ninput DeleteHotelRoomDetailInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: BigInt!\n}\n\n# The output of our delete `HotelRoomDetail` mutation.\ntype DeleteHotelRoomDetailPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `HotelRoomDetail` that was deleted by this mutation.\n  hotelRoomDetail: HotelRoomDetail\n  deletedHotelRoomDetailNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `HotelRoomDetail`. May be used by Relay 1.\n  hotelRoomDetailEdge(\n    # The method to use when ordering `HotelRoomDetail`.\n    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): HotelRoomDetailsEdge\n}\n\n# All input for the `deleteHotelRoom` mutation.\ninput DeleteHotelRoomInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `HotelRoom` mutation.\ntype DeleteHotelRoomPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `HotelRoom` that was deleted by this mutation.\n  hotelRoom: HotelRoom\n  deletedHotelRoomNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `HotelRoom`. May be used by Relay 1.\n  hotelRoomEdge(\n    # The method to use when ordering `HotelRoom`.\n    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): HotelRoomsEdge\n}\n\n# All input for the `deleteLookupByNodeId` mutation.\ninput DeleteLookupByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Lookup` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteLookupByRealm` mutation.\ninput DeleteLookupByRealmInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  realm: String!\n}\n\n# All input for the `deleteLookup` mutation.\ninput DeleteLookupInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Lookup` mutation.\ntype DeleteLookupPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Lookup` that was deleted by this mutation.\n  lookup: Lookup\n  deletedLookupNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Lookup`. May be used by Relay 1.\n  lookupEdge(\n    # The method to use when ordering `Lookup`.\n    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): LookupsEdge\n}\n\n# All input for the `deleteLookupValueByLookupIdAndCode` mutation.\ninput DeleteLookupValueByLookupIdAndCodeInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  lookupId: Int!\n  code: String!\n}\n\n# All input for the `deleteLookupValueByNodeId` mutation.\ninput DeleteLookupValueByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `LookupValue` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteLookupValue` mutation.\ninput DeleteLookupValueInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `LookupValue` mutation.\ntype DeleteLookupValuePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `LookupValue` that was deleted by this mutation.\n  lookupValue: LookupValue\n  deletedLookupValueNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Lookup` that is related to this `LookupValue`.\n  lookup: Lookup\n\n  # An edge for our `LookupValue`. May be used by Relay 1.\n  lookupValueEdge(\n    # The method to use when ordering `LookupValue`.\n    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): LookupValuesEdge\n}\n\n# All input for the `deleteMemberHotelRoomAssignmentByNodeId` mutation.\ninput DeleteMemberHotelRoomAssignmentByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `MemberHotelRoomAssignment` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteMemberHotelRoomAssignment` mutation.\ninput DeleteMemberHotelRoomAssignmentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  memberId: BigInt!\n  hotelRoomId: BigInt!\n}\n\n# The output of our delete `MemberHotelRoomAssignment` mutation.\ntype DeleteMemberHotelRoomAssignmentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `MemberHotelRoomAssignment` that was deleted by this mutation.\n  memberHotelRoomAssignment: MemberHotelRoomAssignment\n  deletedMemberHotelRoomAssignmentNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`.\n  member: Membership\n\n  # Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`.\n  hotelRoom: HotelRoomDetail\n\n  # An edge for our `MemberHotelRoomAssignment`. May be used by Relay 1.\n  memberHotelRoomAssignmentEdge(\n    # The method to use when ordering `MemberHotelRoomAssignment`.\n    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): MemberHotelRoomAssignmentsEdge\n}\n\n# All input for the `deleteMembershipByNodeId` mutation.\ninput DeleteMembershipByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Membership` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteMembership` mutation.\ninput DeleteMembershipInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Membership` mutation.\ntype DeleteMembershipPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Membership` that was deleted by this mutation.\n  membership: Membership\n  deletedMembershipNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `HotelRoom` that is related to this `Membership`.\n  hotelRoom: HotelRoom\n\n  # Reads a single `User` that is related to this `Membership`.\n  user: User\n\n  # An edge for our `Membership`. May be used by Relay 1.\n  membershipEdge(\n    # The method to use when ordering `Membership`.\n    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): MembershipsEdge\n}\n\n# All input for the `deleteProfileByEmail` mutation.\ninput DeleteProfileByEmailInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  email: String!\n}\n\n# All input for the `deleteProfileByNodeId` mutation.\ninput DeleteProfileByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Profile` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteProfile` mutation.\ninput DeleteProfileInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Profile` mutation.\ntype DeleteProfilePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Profile` that was deleted by this mutation.\n  profile: Profile\n  deletedProfileNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Profile`. May be used by Relay 1.\n  profileEdge(\n    # The method to use when ordering `Profile`.\n    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ProfilesEdge\n}\n\n# All input for the `deleteRegistrationCodeByNodeId` mutation.\ninput DeleteRegistrationCodeByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `RegistrationCode` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteRegistrationCode` mutation.\ninput DeleteRegistrationCodeInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `RegistrationCode` mutation.\ntype DeleteRegistrationCodePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `RegistrationCode` that was deleted by this mutation.\n  registrationCode: RegistrationCode\n  deletedRegistrationCodeNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `RegistrationCode`. May be used by Relay 1.\n  registrationCodeEdge(\n    # The method to use when ordering `RegistrationCode`.\n    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RegistrationCodesEdge\n}\n\n# All input for the `deleteRoleByAuthority` mutation.\ninput DeleteRoleByAuthorityInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  authority: String!\n}\n\n# All input for the `deleteRoleByNodeId` mutation.\ninput DeleteRoleByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Role` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteRole` mutation.\ninput DeleteRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Role` mutation.\ntype DeleteRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Role` that was deleted by this mutation.\n  role: Role\n  deletedRoleNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Role`. May be used by Relay 1.\n  roleEdge(\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RolesEdge\n}\n\n# All input for the `deleteRoomByNodeId` mutation.\ninput DeleteRoomByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Room` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteRoom` mutation.\ninput DeleteRoomInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Room` mutation.\ntype DeleteRoomPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Room` that was deleted by this mutation.\n  room: Room\n  deletedRoomNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Room`. May be used by Relay 1.\n  roomEdge(\n    # The method to use when ordering `Room`.\n    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RoomsEdge\n}\n\n# All input for the `deleteSettingByNodeId` mutation.\ninput DeleteSettingByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Setting` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteSetting` mutation.\ninput DeleteSettingInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Setting` mutation.\ntype DeleteSettingPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Setting` that was deleted by this mutation.\n  setting: Setting\n  deletedSettingNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Setting`. May be used by Relay 1.\n  settingEdge(\n    # The method to use when ordering `Setting`.\n    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): SettingsEdge\n}\n\n# All input for the `deleteShirtOrderByNodeId` mutation.\ninput DeleteShirtOrderByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `ShirtOrder` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteShirtOrder` mutation.\ninput DeleteShirtOrderInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# All input for the `deleteShirtOrderItemByNodeId` mutation.\ninput DeleteShirtOrderItemByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `ShirtOrderItem` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteShirtOrderItem` mutation.\ninput DeleteShirtOrderItemInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `ShirtOrderItem` mutation.\ntype DeleteShirtOrderItemPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `ShirtOrderItem` that was deleted by this mutation.\n  shirtOrderItem: ShirtOrderItem\n  deletedShirtOrderItemNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`.\n  order: ShirtOrder\n\n  # An edge for our `ShirtOrderItem`. May be used by Relay 1.\n  shirtOrderItemEdge(\n    # The method to use when ordering `ShirtOrderItem`.\n    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ShirtOrderItemsEdge\n}\n\n# The output of our delete `ShirtOrder` mutation.\ntype DeleteShirtOrderPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `ShirtOrder` that was deleted by this mutation.\n  shirtOrder: ShirtOrder\n  deletedShirtOrderNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `User` that is related to this `ShirtOrder`.\n  user: User\n\n  # An edge for our `ShirtOrder`. May be used by Relay 1.\n  shirtOrderEdge(\n    # The method to use when ordering `ShirtOrder`.\n    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ShirtOrdersEdge\n}\n\n# All input for the `deleteSlotByNodeId` mutation.\ninput DeleteSlotByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Slot` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteSlot` mutation.\ninput DeleteSlotInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Slot` mutation.\ntype DeleteSlotPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Slot` that was deleted by this mutation.\n  slot: Slot\n  deletedSlotNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Slot`. May be used by Relay 1.\n  slotEdge(\n    # The method to use when ordering `Slot`.\n    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): SlotsEdge\n}\n\n# All input for the `deleteTokenByNodeId` mutation.\ninput DeleteTokenByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Token` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteToken` mutation.\ninput DeleteTokenInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `Token` mutation.\ntype DeleteTokenPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Token` that was deleted by this mutation.\n  token: Token\n  deletedTokenNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `User` that is related to this `Token`.\n  user: User\n\n  # An edge for our `Token`. May be used by Relay 1.\n  tokenEdge(\n    # The method to use when ordering `Token`.\n    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]\n  ): TokensEdge\n}\n\n# All input for the `deleteUserByNodeId` mutation.\ninput DeleteUserByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `User` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteUserByUsername` mutation.\ninput DeleteUserByUsernameInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  username: String!\n}\n\n# All input for the `deleteUser` mutation.\ninput DeleteUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  id: Int!\n}\n\n# The output of our delete `User` mutation.\ntype DeleteUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `User` that was deleted by this mutation.\n  user: User\n  deletedUserNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Profile` that is related to this `User`.\n  profile: Profile\n\n  # An edge for our `User`. May be used by Relay 1.\n  userEdge(\n    # The method to use when ordering `User`.\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n  ): UsersEdge\n}\n\n# All input for the `deleteUserRoleByNodeId` mutation.\ninput DeleteUserRoleByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `UserRole` to be deleted.\n  nodeId: ID!\n}\n\n# All input for the `deleteUserRole` mutation.\ninput DeleteUserRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  roleId: Int!\n  userId: Int!\n}\n\n# The output of our delete `UserRole` mutation.\ntype DeleteUserRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `UserRole` that was deleted by this mutation.\n  userRole: UserRole\n  deletedUserRoleNodeId: ID\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `UserRole`.\n  role: Role\n\n  # Reads a single `User` that is related to this `UserRole`.\n  user: User\n\n  # An edge for our `UserRole`. May be used by Relay 1.\n  userRoleEdge(\n    # The method to use when ordering `UserRole`.\n    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): UserRolesEdge\n}\n\n# A filter to be used against Float fields. All fields are combined with a logical ‘and.’\ninput FloatFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: Float\n\n  # Not equal to the specified value.\n  notEqualTo: Float\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: Float\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: Float\n\n  # Included in the specified list.\n  in: [Float!]\n\n  # Not included in the specified list.\n  notIn: [Float!]\n\n  # Less than the specified value.\n  lessThan: Float\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: Float\n\n  # Greater than the specified value.\n  greaterThan: Float\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: Float\n}\n\n# All input for the `fTruncateTables` mutation.\ninput FTruncateTablesInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n  _username: String\n}\n\n# The output of our `fTruncateTables` mutation.\ntype FTruncateTablesPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n}\n\ntype Game implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  description: String!\n  lateFinish: Boolean\n  lateStart: String\n  name: String!\n  playerMax: Int!\n  playerMin: Int!\n  roomId: Int\n  shortName: String\n  slotId: Int\n  charInstructions: String!\n  estimatedLength: String!\n  gameContactEmail: String!\n  genre: String!\n  gmNames: String\n  message: String!\n  playerPreference: String!\n  playersContactGm: Boolean!\n  returningPlayers: String!\n  setting: String!\n  slotConflicts: String!\n  slotPreference: Int!\n  teenFriendly: Boolean!\n  type: String!\n  year: Int!\n  authorId: Int\n\n  # Reads a single `Room` that is related to this `Game`.\n  room: Room\n\n  # Reads a single `Slot` that is related to this `Game`.\n  slot: Slot\n\n  # Reads a single `User` that is related to this `Game`.\n  author: User\n\n  # Reads and enables pagination through a set of `GameAssignment`.\n  gameAssignments(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameAssignment`.\n    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameAssignmentCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameAssignmentFilter\n  ): GameAssignmentsConnection!\n\n  # Reads and enables pagination through a set of `GameChoice`.\n  gameChoices(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameChoiceCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameChoiceFilter\n  ): GameChoicesConnection!\n}\n\ntype GameAssignment implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  memberId: Int!\n  gameId: Int!\n  gm: Int!\n  year: Int!\n\n  # Reads a single `Membership` that is related to this `GameAssignment`.\n  member: Membership\n\n  # Reads a single `Game` that is related to this `GameAssignment`.\n  game: Game\n}\n\n# A condition to be used against `GameAssignment` object types. All fields are\n# tested for equality and combined with a logical ‘and.’\ninput GameAssignmentCondition {\n  # Checks for equality with the object’s `memberId` field.\n  memberId: Int\n\n  # Checks for equality with the object’s `gameId` field.\n  gameId: Int\n\n  # Checks for equality with the object’s `gm` field.\n  gm: Int\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n}\n\n# A filter to be used against `GameAssignment` object types. All fields are combined with a logical ‘and.’\ninput GameAssignmentFilter {\n  # Filter by the object’s `memberId` field.\n  memberId: IntFilter\n\n  # Filter by the object’s `gameId` field.\n  gameId: IntFilter\n\n  # Filter by the object’s `gm` field.\n  gm: IntFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [GameAssignmentFilter!]\n\n  # Checks for any expressions in this list.\n  or: [GameAssignmentFilter!]\n\n  # Negates the expression.\n  not: GameAssignmentFilter\n}\n\n# An input for mutations affecting `GameAssignment`\ninput GameAssignmentInput {\n  memberId: Int!\n  gameId: Int!\n  gm: Int!\n  year: Int!\n}\n\n# Represents an update to a `GameAssignment`. Fields that are set will be updated.\ninput GameAssignmentPatch {\n  memberId: Int\n  gameId: Int\n  gm: Int\n  year: Int\n}\n\n# A connection to a list of `GameAssignment` values.\ntype GameAssignmentsConnection {\n  # A list of `GameAssignment` objects.\n  nodes: [GameAssignment]!\n\n  # A list of edges which contains the `GameAssignment` and cursor to aid in pagination.\n  edges: [GameAssignmentsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `GameAssignment` you could get from the connection.\n  totalCount: Int\n}\n\n# A `GameAssignment` edge in the connection.\ntype GameAssignmentsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `GameAssignment` at the end of the edge.\n  node: GameAssignment\n}\n\n# Methods to use when ordering `GameAssignment`.\nenum GameAssignmentsOrderBy {\n  NATURAL\n  MEMBER_ID_ASC\n  MEMBER_ID_DESC\n  GAME_ID_ASC\n  GAME_ID_DESC\n  GM_ASC\n  GM_DESC\n  YEAR_ASC\n  YEAR_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC\n  GAME_BY_GAME_ID__ID_ASC\n  GAME_BY_GAME_ID__ID_DESC\n  GAME_BY_GAME_ID__DESCRIPTION_ASC\n  GAME_BY_GAME_ID__DESCRIPTION_DESC\n  GAME_BY_GAME_ID__LATE_FINISH_ASC\n  GAME_BY_GAME_ID__LATE_FINISH_DESC\n  GAME_BY_GAME_ID__LATE_START_ASC\n  GAME_BY_GAME_ID__LATE_START_DESC\n  GAME_BY_GAME_ID__NAME_ASC\n  GAME_BY_GAME_ID__NAME_DESC\n  GAME_BY_GAME_ID__PLAYER_MAX_ASC\n  GAME_BY_GAME_ID__PLAYER_MAX_DESC\n  GAME_BY_GAME_ID__PLAYER_MIN_ASC\n  GAME_BY_GAME_ID__PLAYER_MIN_DESC\n  GAME_BY_GAME_ID__ROOM_ID_ASC\n  GAME_BY_GAME_ID__ROOM_ID_DESC\n  GAME_BY_GAME_ID__SHORT_NAME_ASC\n  GAME_BY_GAME_ID__SHORT_NAME_DESC\n  GAME_BY_GAME_ID__SLOT_ID_ASC\n  GAME_BY_GAME_ID__SLOT_ID_DESC\n  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC\n  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC\n  GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC\n  GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC\n  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC\n  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC\n  GAME_BY_GAME_ID__GENRE_ASC\n  GAME_BY_GAME_ID__GENRE_DESC\n  GAME_BY_GAME_ID__GM_NAMES_ASC\n  GAME_BY_GAME_ID__GM_NAMES_DESC\n  GAME_BY_GAME_ID__MESSAGE_ASC\n  GAME_BY_GAME_ID__MESSAGE_DESC\n  GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC\n  GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC\n  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC\n  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC\n  GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC\n  GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC\n  GAME_BY_GAME_ID__SETTING_ASC\n  GAME_BY_GAME_ID__SETTING_DESC\n  GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC\n  GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC\n  GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC\n  GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC\n  GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC\n  GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC\n  GAME_BY_GAME_ID__TYPE_ASC\n  GAME_BY_GAME_ID__TYPE_DESC\n  GAME_BY_GAME_ID__YEAR_ASC\n  GAME_BY_GAME_ID__YEAR_DESC\n  GAME_BY_GAME_ID__AUTHOR_ID_ASC\n  GAME_BY_GAME_ID__AUTHOR_ID_DESC\n}\n\ntype GameChoice implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  gameId: Int\n  memberId: Int!\n  rank: Int!\n  slotId: Int!\n  year: Int!\n  returningPlayer: Boolean!\n\n  # Reads a single `Game` that is related to this `GameChoice`.\n  game: Game\n\n  # Reads a single `Membership` that is related to this `GameChoice`.\n  member: Membership\n\n  # Reads a single `Slot` that is related to this `GameChoice`.\n  slot: Slot\n}\n\n# A condition to be used against `GameChoice` object types. All fields are tested\n# for equality and combined with a logical ‘and.’\ninput GameChoiceCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `gameId` field.\n  gameId: Int\n\n  # Checks for equality with the object’s `memberId` field.\n  memberId: Int\n\n  # Checks for equality with the object’s `rank` field.\n  rank: Int\n\n  # Checks for equality with the object’s `slotId` field.\n  slotId: Int\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n\n  # Checks for equality with the object’s `returningPlayer` field.\n  returningPlayer: Boolean\n}\n\n# A filter to be used against `GameChoice` object types. All fields are combined with a logical ‘and.’\ninput GameChoiceFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `gameId` field.\n  gameId: IntFilter\n\n  # Filter by the object’s `memberId` field.\n  memberId: IntFilter\n\n  # Filter by the object’s `rank` field.\n  rank: IntFilter\n\n  # Filter by the object’s `slotId` field.\n  slotId: IntFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Filter by the object’s `returningPlayer` field.\n  returningPlayer: BooleanFilter\n\n  # Checks for all expressions in this list.\n  and: [GameChoiceFilter!]\n\n  # Checks for any expressions in this list.\n  or: [GameChoiceFilter!]\n\n  # Negates the expression.\n  not: GameChoiceFilter\n}\n\n# An input for mutations affecting `GameChoice`\ninput GameChoiceInput {\n  id: Int\n  gameId: Int\n  memberId: Int!\n  rank: Int!\n  slotId: Int!\n  year: Int!\n  returningPlayer: Boolean!\n}\n\n# Represents an update to a `GameChoice`. Fields that are set will be updated.\ninput GameChoicePatch {\n  id: Int\n  gameId: Int\n  memberId: Int\n  rank: Int\n  slotId: Int\n  year: Int\n  returningPlayer: Boolean\n}\n\n# A connection to a list of `GameChoice` values.\ntype GameChoicesConnection {\n  # A list of `GameChoice` objects.\n  nodes: [GameChoice]!\n\n  # A list of edges which contains the `GameChoice` and cursor to aid in pagination.\n  edges: [GameChoicesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `GameChoice` you could get from the connection.\n  totalCount: Int\n}\n\n# A `GameChoice` edge in the connection.\ntype GameChoicesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `GameChoice` at the end of the edge.\n  node: GameChoice\n}\n\n# Methods to use when ordering `GameChoice`.\nenum GameChoicesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  GAME_ID_ASC\n  GAME_ID_DESC\n  MEMBER_ID_ASC\n  MEMBER_ID_DESC\n  RANK_ASC\n  RANK_DESC\n  SLOT_ID_ASC\n  SLOT_ID_DESC\n  YEAR_ASC\n  YEAR_DESC\n  RETURNING_PLAYER_ASC\n  RETURNING_PLAYER_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  GAME_BY_GAME_ID__ID_ASC\n  GAME_BY_GAME_ID__ID_DESC\n  GAME_BY_GAME_ID__DESCRIPTION_ASC\n  GAME_BY_GAME_ID__DESCRIPTION_DESC\n  GAME_BY_GAME_ID__LATE_FINISH_ASC\n  GAME_BY_GAME_ID__LATE_FINISH_DESC\n  GAME_BY_GAME_ID__LATE_START_ASC\n  GAME_BY_GAME_ID__LATE_START_DESC\n  GAME_BY_GAME_ID__NAME_ASC\n  GAME_BY_GAME_ID__NAME_DESC\n  GAME_BY_GAME_ID__PLAYER_MAX_ASC\n  GAME_BY_GAME_ID__PLAYER_MAX_DESC\n  GAME_BY_GAME_ID__PLAYER_MIN_ASC\n  GAME_BY_GAME_ID__PLAYER_MIN_DESC\n  GAME_BY_GAME_ID__ROOM_ID_ASC\n  GAME_BY_GAME_ID__ROOM_ID_DESC\n  GAME_BY_GAME_ID__SHORT_NAME_ASC\n  GAME_BY_GAME_ID__SHORT_NAME_DESC\n  GAME_BY_GAME_ID__SLOT_ID_ASC\n  GAME_BY_GAME_ID__SLOT_ID_DESC\n  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC\n  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC\n  GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC\n  GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC\n  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC\n  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC\n  GAME_BY_GAME_ID__GENRE_ASC\n  GAME_BY_GAME_ID__GENRE_DESC\n  GAME_BY_GAME_ID__GM_NAMES_ASC\n  GAME_BY_GAME_ID__GM_NAMES_DESC\n  GAME_BY_GAME_ID__MESSAGE_ASC\n  GAME_BY_GAME_ID__MESSAGE_DESC\n  GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC\n  GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC\n  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC\n  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC\n  GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC\n  GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC\n  GAME_BY_GAME_ID__SETTING_ASC\n  GAME_BY_GAME_ID__SETTING_DESC\n  GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC\n  GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC\n  GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC\n  GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC\n  GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC\n  GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC\n  GAME_BY_GAME_ID__TYPE_ASC\n  GAME_BY_GAME_ID__TYPE_DESC\n  GAME_BY_GAME_ID__YEAR_ASC\n  GAME_BY_GAME_ID__YEAR_DESC\n  GAME_BY_GAME_ID__AUTHOR_ID_ASC\n  GAME_BY_GAME_ID__AUTHOR_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC\n  SLOT_BY_SLOT_ID__ID_ASC\n  SLOT_BY_SLOT_ID__ID_DESC\n  SLOT_BY_SLOT_ID__SLOT_ASC\n  SLOT_BY_SLOT_ID__SLOT_DESC\n  SLOT_BY_SLOT_ID__DAY_ASC\n  SLOT_BY_SLOT_ID__DAY_DESC\n  SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC\n  SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC\n  SLOT_BY_SLOT_ID__LENGTH_ASC\n  SLOT_BY_SLOT_ID__LENGTH_DESC\n  SLOT_BY_SLOT_ID__TIME_ASC\n  SLOT_BY_SLOT_ID__TIME_DESC\n}\n\n# A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput GameCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `description` field.\n  description: String\n\n  # Checks for equality with the object’s `lateFinish` field.\n  lateFinish: Boolean\n\n  # Checks for equality with the object’s `lateStart` field.\n  lateStart: String\n\n  # Checks for equality with the object’s `name` field.\n  name: String\n\n  # Checks for equality with the object’s `playerMax` field.\n  playerMax: Int\n\n  # Checks for equality with the object’s `playerMin` field.\n  playerMin: Int\n\n  # Checks for equality with the object’s `roomId` field.\n  roomId: Int\n\n  # Checks for equality with the object’s `shortName` field.\n  shortName: String\n\n  # Checks for equality with the object’s `slotId` field.\n  slotId: Int\n\n  # Checks for equality with the object’s `charInstructions` field.\n  charInstructions: String\n\n  # Checks for equality with the object’s `estimatedLength` field.\n  estimatedLength: String\n\n  # Checks for equality with the object’s `gameContactEmail` field.\n  gameContactEmail: String\n\n  # Checks for equality with the object’s `genre` field.\n  genre: String\n\n  # Checks for equality with the object’s `gmNames` field.\n  gmNames: String\n\n  # Checks for equality with the object’s `message` field.\n  message: String\n\n  # Checks for equality with the object’s `playerPreference` field.\n  playerPreference: String\n\n  # Checks for equality with the object’s `playersContactGm` field.\n  playersContactGm: Boolean\n\n  # Checks for equality with the object’s `returningPlayers` field.\n  returningPlayers: String\n\n  # Checks for equality with the object’s `setting` field.\n  setting: String\n\n  # Checks for equality with the object’s `slotConflicts` field.\n  slotConflicts: String\n\n  # Checks for equality with the object’s `slotPreference` field.\n  slotPreference: Int\n\n  # Checks for equality with the object’s `teenFriendly` field.\n  teenFriendly: Boolean\n\n  # Checks for equality with the object’s `type` field.\n  type: String\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n\n  # Checks for equality with the object’s `authorId` field.\n  authorId: Int\n}\n\n# A filter to be used against `Game` object types. All fields are combined with a logical ‘and.’\ninput GameFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `description` field.\n  description: StringFilter\n\n  # Filter by the object’s `lateFinish` field.\n  lateFinish: BooleanFilter\n\n  # Filter by the object’s `lateStart` field.\n  lateStart: StringFilter\n\n  # Filter by the object’s `name` field.\n  name: StringFilter\n\n  # Filter by the object’s `playerMax` field.\n  playerMax: IntFilter\n\n  # Filter by the object’s `playerMin` field.\n  playerMin: IntFilter\n\n  # Filter by the object’s `roomId` field.\n  roomId: IntFilter\n\n  # Filter by the object’s `shortName` field.\n  shortName: StringFilter\n\n  # Filter by the object’s `slotId` field.\n  slotId: IntFilter\n\n  # Filter by the object’s `charInstructions` field.\n  charInstructions: StringFilter\n\n  # Filter by the object’s `estimatedLength` field.\n  estimatedLength: StringFilter\n\n  # Filter by the object’s `gameContactEmail` field.\n  gameContactEmail: StringFilter\n\n  # Filter by the object’s `genre` field.\n  genre: StringFilter\n\n  # Filter by the object’s `gmNames` field.\n  gmNames: StringFilter\n\n  # Filter by the object’s `message` field.\n  message: StringFilter\n\n  # Filter by the object’s `playerPreference` field.\n  playerPreference: StringFilter\n\n  # Filter by the object’s `playersContactGm` field.\n  playersContactGm: BooleanFilter\n\n  # Filter by the object’s `returningPlayers` field.\n  returningPlayers: StringFilter\n\n  # Filter by the object’s `setting` field.\n  setting: StringFilter\n\n  # Filter by the object’s `slotConflicts` field.\n  slotConflicts: StringFilter\n\n  # Filter by the object’s `slotPreference` field.\n  slotPreference: IntFilter\n\n  # Filter by the object’s `teenFriendly` field.\n  teenFriendly: BooleanFilter\n\n  # Filter by the object’s `type` field.\n  type: StringFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Filter by the object’s `authorId` field.\n  authorId: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [GameFilter!]\n\n  # Checks for any expressions in this list.\n  or: [GameFilter!]\n\n  # Negates the expression.\n  not: GameFilter\n}\n\n# An input for mutations affecting `Game`\ninput GameInput {\n  id: Int\n  description: String!\n  lateFinish: Boolean\n  lateStart: String\n  name: String!\n  playerMax: Int!\n  playerMin: Int!\n  roomId: Int\n  shortName: String\n  slotId: Int\n  charInstructions: String!\n  estimatedLength: String!\n  gameContactEmail: String!\n  genre: String!\n  gmNames: String\n  message: String!\n  playerPreference: String!\n  playersContactGm: Boolean!\n  returningPlayers: String!\n  setting: String!\n  slotConflicts: String!\n  slotPreference: Int!\n  teenFriendly: Boolean!\n  type: String!\n  year: Int!\n  authorId: Int\n}\n\n# Represents an update to a `Game`. Fields that are set will be updated.\ninput GamePatch {\n  id: Int\n  description: String\n  lateFinish: Boolean\n  lateStart: String\n  name: String\n  playerMax: Int\n  playerMin: Int\n  roomId: Int\n  shortName: String\n  slotId: Int\n  charInstructions: String\n  estimatedLength: String\n  gameContactEmail: String\n  genre: String\n  gmNames: String\n  message: String\n  playerPreference: String\n  playersContactGm: Boolean\n  returningPlayers: String\n  setting: String\n  slotConflicts: String\n  slotPreference: Int\n  teenFriendly: Boolean\n  type: String\n  year: Int\n  authorId: Int\n}\n\n# A connection to a list of `Game` values.\ntype GamesConnection {\n  # A list of `Game` objects.\n  nodes: [Game]!\n\n  # A list of edges which contains the `Game` and cursor to aid in pagination.\n  edges: [GamesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Game` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Game` edge in the connection.\ntype GamesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Game` at the end of the edge.\n  node: Game\n}\n\n# Methods to use when ordering `Game`.\nenum GamesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  DESCRIPTION_ASC\n  DESCRIPTION_DESC\n  LATE_FINISH_ASC\n  LATE_FINISH_DESC\n  LATE_START_ASC\n  LATE_START_DESC\n  NAME_ASC\n  NAME_DESC\n  PLAYER_MAX_ASC\n  PLAYER_MAX_DESC\n  PLAYER_MIN_ASC\n  PLAYER_MIN_DESC\n  ROOM_ID_ASC\n  ROOM_ID_DESC\n  SHORT_NAME_ASC\n  SHORT_NAME_DESC\n  SLOT_ID_ASC\n  SLOT_ID_DESC\n  CHAR_INSTRUCTIONS_ASC\n  CHAR_INSTRUCTIONS_DESC\n  ESTIMATED_LENGTH_ASC\n  ESTIMATED_LENGTH_DESC\n  GAME_CONTACT_EMAIL_ASC\n  GAME_CONTACT_EMAIL_DESC\n  GENRE_ASC\n  GENRE_DESC\n  GM_NAMES_ASC\n  GM_NAMES_DESC\n  MESSAGE_ASC\n  MESSAGE_DESC\n  PLAYER_PREFERENCE_ASC\n  PLAYER_PREFERENCE_DESC\n  PLAYERS_CONTACT_GM_ASC\n  PLAYERS_CONTACT_GM_DESC\n  RETURNING_PLAYERS_ASC\n  RETURNING_PLAYERS_DESC\n  SETTING_ASC\n  SETTING_DESC\n  SLOT_CONFLICTS_ASC\n  SLOT_CONFLICTS_DESC\n  SLOT_PREFERENCE_ASC\n  SLOT_PREFERENCE_DESC\n  TEEN_FRIENDLY_ASC\n  TEEN_FRIENDLY_DESC\n  TYPE_ASC\n  TYPE_DESC\n  YEAR_ASC\n  YEAR_DESC\n  AUTHOR_ID_ASC\n  AUTHOR_ID_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  ROOM_BY_ROOM_ID__ID_ASC\n  ROOM_BY_ROOM_ID__ID_DESC\n  ROOM_BY_ROOM_ID__DESCRIPTION_ASC\n  ROOM_BY_ROOM_ID__DESCRIPTION_DESC\n  ROOM_BY_ROOM_ID__SIZE_ASC\n  ROOM_BY_ROOM_ID__SIZE_DESC\n  ROOM_BY_ROOM_ID__TYPE_ASC\n  ROOM_BY_ROOM_ID__TYPE_DESC\n  ROOM_BY_ROOM_ID__UPDATED_ASC\n  ROOM_BY_ROOM_ID__UPDATED_DESC\n  SLOT_BY_SLOT_ID__ID_ASC\n  SLOT_BY_SLOT_ID__ID_DESC\n  SLOT_BY_SLOT_ID__SLOT_ASC\n  SLOT_BY_SLOT_ID__SLOT_DESC\n  SLOT_BY_SLOT_ID__DAY_ASC\n  SLOT_BY_SLOT_ID__DAY_DESC\n  SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC\n  SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC\n  SLOT_BY_SLOT_ID__LENGTH_ASC\n  SLOT_BY_SLOT_ID__LENGTH_DESC\n  SLOT_BY_SLOT_ID__TIME_ASC\n  SLOT_BY_SLOT_ID__TIME_DESC\n  USER_BY_AUTHOR_ID__ID_ASC\n  USER_BY_AUTHOR_ID__ID_DESC\n  USER_BY_AUTHOR_ID__ACCOUNT_LOCKED_ASC\n  USER_BY_AUTHOR_ID__ACCOUNT_LOCKED_DESC\n  USER_BY_AUTHOR_ID__ENABLED_ASC\n  USER_BY_AUTHOR_ID__ENABLED_DESC\n  USER_BY_AUTHOR_ID__PASSWORD_ASC\n  USER_BY_AUTHOR_ID__PASSWORD_DESC\n  USER_BY_AUTHOR_ID__PROFILE_ID_ASC\n  USER_BY_AUTHOR_ID__PROFILE_ID_DESC\n  USER_BY_AUTHOR_ID__USERNAME_ASC\n  USER_BY_AUTHOR_ID__USERNAME_DESC\n  GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_ASC\n  GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_DESC\n  GAME_CHOICES_BY_GAME_ID__COUNT_ASC\n  GAME_CHOICES_BY_GAME_ID__COUNT_DESC\n}\n\ntype GameSubmission implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  memberId: Int!\n  message: String!\n  year: Int!\n\n  # Reads a single `Membership` that is related to this `GameSubmission`.\n  member: Membership\n}\n\n# A condition to be used against `GameSubmission` object types. All fields are\n# tested for equality and combined with a logical ‘and.’\ninput GameSubmissionCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `memberId` field.\n  memberId: Int\n\n  # Checks for equality with the object’s `message` field.\n  message: String\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n}\n\n# A filter to be used against `GameSubmission` object types. All fields are combined with a logical ‘and.’\ninput GameSubmissionFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `memberId` field.\n  memberId: IntFilter\n\n  # Filter by the object’s `message` field.\n  message: StringFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [GameSubmissionFilter!]\n\n  # Checks for any expressions in this list.\n  or: [GameSubmissionFilter!]\n\n  # Negates the expression.\n  not: GameSubmissionFilter\n}\n\n# An input for mutations affecting `GameSubmission`\ninput GameSubmissionInput {\n  id: Int\n  memberId: Int!\n  message: String!\n  year: Int!\n}\n\n# Represents an update to a `GameSubmission`. Fields that are set will be updated.\ninput GameSubmissionPatch {\n  id: Int\n  memberId: Int\n  message: String\n  year: Int\n}\n\n# A connection to a list of `GameSubmission` values.\ntype GameSubmissionsConnection {\n  # A list of `GameSubmission` objects.\n  nodes: [GameSubmission]!\n\n  # A list of edges which contains the `GameSubmission` and cursor to aid in pagination.\n  edges: [GameSubmissionsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `GameSubmission` you could get from the connection.\n  totalCount: Int\n}\n\n# A `GameSubmission` edge in the connection.\ntype GameSubmissionsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `GameSubmission` at the end of the edge.\n  node: GameSubmission\n}\n\n# Methods to use when ordering `GameSubmission`.\nenum GameSubmissionsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  MEMBER_ID_ASC\n  MEMBER_ID_DESC\n  MESSAGE_ASC\n  MESSAGE_DESC\n  YEAR_ASC\n  YEAR_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC\n}\n\ntype HotelRoom implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  description: String!\n  gamingRoom: Boolean!\n  occupancy: String!\n  quantity: Int!\n  rate: String!\n  bathroomType: String!\n  type: String!\n\n  # Reads and enables pagination through a set of `Membership`.\n  memberships(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Membership`.\n    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: MembershipCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: MembershipFilter\n  ): MembershipsConnection!\n}\n\n# A condition to be used against `HotelRoom` object types. All fields are tested\n# for equality and combined with a logical ‘and.’\ninput HotelRoomCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `description` field.\n  description: String\n\n  # Checks for equality with the object’s `gamingRoom` field.\n  gamingRoom: Boolean\n\n  # Checks for equality with the object’s `occupancy` field.\n  occupancy: String\n\n  # Checks for equality with the object’s `quantity` field.\n  quantity: Int\n\n  # Checks for equality with the object’s `rate` field.\n  rate: String\n\n  # Checks for equality with the object’s `bathroomType` field.\n  bathroomType: String\n\n  # Checks for equality with the object’s `type` field.\n  type: String\n}\n\ntype HotelRoomDetail implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: BigInt!\n  version: BigInt!\n  bathroomType: String!\n  comment: String!\n  enabled: Boolean!\n  gamingRoom: Boolean!\n  internalRoomType: String!\n  name: String!\n  reserved: Boolean!\n  reservedFor: String!\n  roomType: String!\n  formattedRoomType: String!\n\n  # Reads and enables pagination through a set of `MemberHotelRoomAssignment`.\n  memberHotelRoomAssignmentsByHotelRoomId(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `MemberHotelRoomAssignment`.\n    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: MemberHotelRoomAssignmentCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: MemberHotelRoomAssignmentFilter\n  ): MemberHotelRoomAssignmentsConnection!\n}\n\n# A condition to be used against `HotelRoomDetail` object types. All fields are\n# tested for equality and combined with a logical ‘and.’\ninput HotelRoomDetailCondition {\n  # Checks for equality with the object’s `id` field.\n  id: BigInt\n\n  # Checks for equality with the object’s `version` field.\n  version: BigInt\n\n  # Checks for equality with the object’s `bathroomType` field.\n  bathroomType: String\n\n  # Checks for equality with the object’s `comment` field.\n  comment: String\n\n  # Checks for equality with the object’s `enabled` field.\n  enabled: Boolean\n\n  # Checks for equality with the object’s `gamingRoom` field.\n  gamingRoom: Boolean\n\n  # Checks for equality with the object’s `internalRoomType` field.\n  internalRoomType: String\n\n  # Checks for equality with the object’s `name` field.\n  name: String\n\n  # Checks for equality with the object’s `reserved` field.\n  reserved: Boolean\n\n  # Checks for equality with the object’s `reservedFor` field.\n  reservedFor: String\n\n  # Checks for equality with the object’s `roomType` field.\n  roomType: String\n\n  # Checks for equality with the object’s `formattedRoomType` field.\n  formattedRoomType: String\n}\n\n# A filter to be used against `HotelRoomDetail` object types. All fields are combined with a logical ‘and.’\ninput HotelRoomDetailFilter {\n  # Filter by the object’s `id` field.\n  id: BigIntFilter\n\n  # Filter by the object’s `version` field.\n  version: BigIntFilter\n\n  # Filter by the object’s `bathroomType` field.\n  bathroomType: StringFilter\n\n  # Filter by the object’s `comment` field.\n  comment: StringFilter\n\n  # Filter by the object’s `enabled` field.\n  enabled: BooleanFilter\n\n  # Filter by the object’s `gamingRoom` field.\n  gamingRoom: BooleanFilter\n\n  # Filter by the object’s `internalRoomType` field.\n  internalRoomType: StringFilter\n\n  # Filter by the object’s `name` field.\n  name: StringFilter\n\n  # Filter by the object’s `reserved` field.\n  reserved: BooleanFilter\n\n  # Filter by the object’s `reservedFor` field.\n  reservedFor: StringFilter\n\n  # Filter by the object’s `roomType` field.\n  roomType: StringFilter\n\n  # Filter by the object’s `formattedRoomType` field.\n  formattedRoomType: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [HotelRoomDetailFilter!]\n\n  # Checks for any expressions in this list.\n  or: [HotelRoomDetailFilter!]\n\n  # Negates the expression.\n  not: HotelRoomDetailFilter\n}\n\n# An input for mutations affecting `HotelRoomDetail`\ninput HotelRoomDetailInput {\n  id: BigInt\n  version: BigInt!\n  bathroomType: String!\n  comment: String!\n  enabled: Boolean!\n  gamingRoom: Boolean!\n  internalRoomType: String!\n  name: String!\n  reserved: Boolean!\n  reservedFor: String!\n  roomType: String!\n  formattedRoomType: String!\n}\n\n# Represents an update to a `HotelRoomDetail`. Fields that are set will be updated.\ninput HotelRoomDetailPatch {\n  id: BigInt\n  version: BigInt\n  bathroomType: String\n  comment: String\n  enabled: Boolean\n  gamingRoom: Boolean\n  internalRoomType: String\n  name: String\n  reserved: Boolean\n  reservedFor: String\n  roomType: String\n  formattedRoomType: String\n}\n\n# A connection to a list of `HotelRoomDetail` values.\ntype HotelRoomDetailsConnection {\n  # A list of `HotelRoomDetail` objects.\n  nodes: [HotelRoomDetail]!\n\n  # A list of edges which contains the `HotelRoomDetail` and cursor to aid in pagination.\n  edges: [HotelRoomDetailsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `HotelRoomDetail` you could get from the connection.\n  totalCount: Int\n}\n\n# A `HotelRoomDetail` edge in the connection.\ntype HotelRoomDetailsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `HotelRoomDetail` at the end of the edge.\n  node: HotelRoomDetail\n}\n\n# Methods to use when ordering `HotelRoomDetail`.\nenum HotelRoomDetailsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  VERSION_ASC\n  VERSION_DESC\n  BATHROOM_TYPE_ASC\n  BATHROOM_TYPE_DESC\n  COMMENT_ASC\n  COMMENT_DESC\n  ENABLED_ASC\n  ENABLED_DESC\n  GAMING_ROOM_ASC\n  GAMING_ROOM_DESC\n  INTERNAL_ROOM_TYPE_ASC\n  INTERNAL_ROOM_TYPE_DESC\n  NAME_ASC\n  NAME_DESC\n  RESERVED_ASC\n  RESERVED_DESC\n  RESERVED_FOR_ASC\n  RESERVED_FOR_DESC\n  ROOM_TYPE_ASC\n  ROOM_TYPE_DESC\n  FORMATTED_ROOM_TYPE_ASC\n  FORMATTED_ROOM_TYPE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_HOTEL_ROOM_ID__COUNT_ASC\n  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_HOTEL_ROOM_ID__COUNT_DESC\n}\n\n# A filter to be used against `HotelRoom` object types. All fields are combined with a logical ‘and.’\ninput HotelRoomFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `description` field.\n  description: StringFilter\n\n  # Filter by the object’s `gamingRoom` field.\n  gamingRoom: BooleanFilter\n\n  # Filter by the object’s `occupancy` field.\n  occupancy: StringFilter\n\n  # Filter by the object’s `quantity` field.\n  quantity: IntFilter\n\n  # Filter by the object’s `rate` field.\n  rate: StringFilter\n\n  # Filter by the object’s `bathroomType` field.\n  bathroomType: StringFilter\n\n  # Filter by the object’s `type` field.\n  type: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [HotelRoomFilter!]\n\n  # Checks for any expressions in this list.\n  or: [HotelRoomFilter!]\n\n  # Negates the expression.\n  not: HotelRoomFilter\n}\n\n# An input for mutations affecting `HotelRoom`\ninput HotelRoomInput {\n  id: Int\n  description: String!\n  gamingRoom: Boolean!\n  occupancy: String!\n  quantity: Int!\n  rate: String!\n  bathroomType: String!\n  type: String!\n}\n\n# Represents an update to a `HotelRoom`. Fields that are set will be updated.\ninput HotelRoomPatch {\n  id: Int\n  description: String\n  gamingRoom: Boolean\n  occupancy: String\n  quantity: Int\n  rate: String\n  bathroomType: String\n  type: String\n}\n\n# A connection to a list of `HotelRoom` values.\ntype HotelRoomsConnection {\n  # A list of `HotelRoom` objects.\n  nodes: [HotelRoom]!\n\n  # A list of edges which contains the `HotelRoom` and cursor to aid in pagination.\n  edges: [HotelRoomsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `HotelRoom` you could get from the connection.\n  totalCount: Int\n}\n\n# A `HotelRoom` edge in the connection.\ntype HotelRoomsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `HotelRoom` at the end of the edge.\n  node: HotelRoom\n}\n\n# Methods to use when ordering `HotelRoom`.\nenum HotelRoomsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  DESCRIPTION_ASC\n  DESCRIPTION_DESC\n  GAMING_ROOM_ASC\n  GAMING_ROOM_DESC\n  OCCUPANCY_ASC\n  OCCUPANCY_DESC\n  QUANTITY_ASC\n  QUANTITY_DESC\n  RATE_ASC\n  RATE_DESC\n  BATHROOM_TYPE_ASC\n  BATHROOM_TYPE_DESC\n  TYPE_ASC\n  TYPE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_ASC\n  MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_DESC\n}\n\n# A filter to be used against Int fields. All fields are combined with a logical ‘and.’\ninput IntFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: Int\n\n  # Not equal to the specified value.\n  notEqualTo: Int\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: Int\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: Int\n\n  # Included in the specified list.\n  in: [Int!]\n\n  # Not included in the specified list.\n  notIn: [Int!]\n\n  # Less than the specified value.\n  lessThan: Int\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: Int\n\n  # Greater than the specified value.\n  greaterThan: Int\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: Int\n}\n\ntype Lookup implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  codeMaximum: String\n  codeMinimum: String\n  codeScale: Int\n  codeType: String!\n  internationalize: Boolean!\n  ordering: String!\n  realm: String!\n  valueMaximum: String\n  valueMinimum: String\n  valueScale: Int\n  valueType: String!\n\n  # Reads and enables pagination through a set of `LookupValue`.\n  lookupValues(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `LookupValue`.\n    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: LookupValueCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: LookupValueFilter\n  ): LookupValuesConnection!\n}\n\n# A condition to be used against `Lookup` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput LookupCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `codeMaximum` field.\n  codeMaximum: String\n\n  # Checks for equality with the object’s `codeMinimum` field.\n  codeMinimum: String\n\n  # Checks for equality with the object’s `codeScale` field.\n  codeScale: Int\n\n  # Checks for equality with the object’s `codeType` field.\n  codeType: String\n\n  # Checks for equality with the object’s `internationalize` field.\n  internationalize: Boolean\n\n  # Checks for equality with the object’s `ordering` field.\n  ordering: String\n\n  # Checks for equality with the object’s `realm` field.\n  realm: String\n\n  # Checks for equality with the object’s `valueMaximum` field.\n  valueMaximum: String\n\n  # Checks for equality with the object’s `valueMinimum` field.\n  valueMinimum: String\n\n  # Checks for equality with the object’s `valueScale` field.\n  valueScale: Int\n\n  # Checks for equality with the object’s `valueType` field.\n  valueType: String\n}\n\n# A filter to be used against `Lookup` object types. All fields are combined with a logical ‘and.’\ninput LookupFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `codeMaximum` field.\n  codeMaximum: StringFilter\n\n  # Filter by the object’s `codeMinimum` field.\n  codeMinimum: StringFilter\n\n  # Filter by the object’s `codeScale` field.\n  codeScale: IntFilter\n\n  # Filter by the object’s `codeType` field.\n  codeType: StringFilter\n\n  # Filter by the object’s `internationalize` field.\n  internationalize: BooleanFilter\n\n  # Filter by the object’s `ordering` field.\n  ordering: StringFilter\n\n  # Filter by the object’s `realm` field.\n  realm: StringFilter\n\n  # Filter by the object’s `valueMaximum` field.\n  valueMaximum: StringFilter\n\n  # Filter by the object’s `valueMinimum` field.\n  valueMinimum: StringFilter\n\n  # Filter by the object’s `valueScale` field.\n  valueScale: IntFilter\n\n  # Filter by the object’s `valueType` field.\n  valueType: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [LookupFilter!]\n\n  # Checks for any expressions in this list.\n  or: [LookupFilter!]\n\n  # Negates the expression.\n  not: LookupFilter\n}\n\n# An input for mutations affecting `Lookup`\ninput LookupInput {\n  id: Int\n  codeMaximum: String\n  codeMinimum: String\n  codeScale: Int\n  codeType: String!\n  internationalize: Boolean!\n  ordering: String!\n  realm: String!\n  valueMaximum: String\n  valueMinimum: String\n  valueScale: Int\n  valueType: String!\n}\n\n# Represents an update to a `Lookup`. Fields that are set will be updated.\ninput LookupPatch {\n  id: Int\n  codeMaximum: String\n  codeMinimum: String\n  codeScale: Int\n  codeType: String\n  internationalize: Boolean\n  ordering: String\n  realm: String\n  valueMaximum: String\n  valueMinimum: String\n  valueScale: Int\n  valueType: String\n}\n\n# A connection to a list of `Lookup` values.\ntype LookupsConnection {\n  # A list of `Lookup` objects.\n  nodes: [Lookup]!\n\n  # A list of edges which contains the `Lookup` and cursor to aid in pagination.\n  edges: [LookupsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Lookup` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Lookup` edge in the connection.\ntype LookupsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Lookup` at the end of the edge.\n  node: Lookup\n}\n\n# Methods to use when ordering `Lookup`.\nenum LookupsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  CODE_MAXIMUM_ASC\n  CODE_MAXIMUM_DESC\n  CODE_MINIMUM_ASC\n  CODE_MINIMUM_DESC\n  CODE_SCALE_ASC\n  CODE_SCALE_DESC\n  CODE_TYPE_ASC\n  CODE_TYPE_DESC\n  INTERNATIONALIZE_ASC\n  INTERNATIONALIZE_DESC\n  ORDERING_ASC\n  ORDERING_DESC\n  REALM_ASC\n  REALM_DESC\n  VALUE_MAXIMUM_ASC\n  VALUE_MAXIMUM_DESC\n  VALUE_MINIMUM_ASC\n  VALUE_MINIMUM_DESC\n  VALUE_SCALE_ASC\n  VALUE_SCALE_DESC\n  VALUE_TYPE_ASC\n  VALUE_TYPE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_ASC\n  LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_DESC\n}\n\ntype LookupValue implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  code: String!\n  lookupId: Int!\n  numericSequencer: BigFloat!\n  sequencer: Int!\n  stringSequencer: String!\n  value: String!\n\n  # Reads a single `Lookup` that is related to this `LookupValue`.\n  lookup: Lookup\n}\n\n# A condition to be used against `LookupValue` object types. All fields are tested\n# for equality and combined with a logical ‘and.’\ninput LookupValueCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `code` field.\n  code: String\n\n  # Checks for equality with the object’s `lookupId` field.\n  lookupId: Int\n\n  # Checks for equality with the object’s `numericSequencer` field.\n  numericSequencer: BigFloat\n\n  # Checks for equality with the object’s `sequencer` field.\n  sequencer: Int\n\n  # Checks for equality with the object’s `stringSequencer` field.\n  stringSequencer: String\n\n  # Checks for equality with the object’s `value` field.\n  value: String\n}\n\n# A filter to be used against `LookupValue` object types. All fields are combined with a logical ‘and.’\ninput LookupValueFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `code` field.\n  code: StringFilter\n\n  # Filter by the object’s `lookupId` field.\n  lookupId: IntFilter\n\n  # Filter by the object’s `numericSequencer` field.\n  numericSequencer: BigFloatFilter\n\n  # Filter by the object’s `sequencer` field.\n  sequencer: IntFilter\n\n  # Filter by the object’s `stringSequencer` field.\n  stringSequencer: StringFilter\n\n  # Filter by the object’s `value` field.\n  value: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [LookupValueFilter!]\n\n  # Checks for any expressions in this list.\n  or: [LookupValueFilter!]\n\n  # Negates the expression.\n  not: LookupValueFilter\n}\n\n# An input for mutations affecting `LookupValue`\ninput LookupValueInput {\n  id: Int\n  code: String!\n  lookupId: Int!\n  numericSequencer: BigFloat!\n  sequencer: Int!\n  stringSequencer: String!\n  value: String!\n}\n\n# Represents an update to a `LookupValue`. Fields that are set will be updated.\ninput LookupValuePatch {\n  id: Int\n  code: String\n  lookupId: Int\n  numericSequencer: BigFloat\n  sequencer: Int\n  stringSequencer: String\n  value: String\n}\n\n# A connection to a list of `LookupValue` values.\ntype LookupValuesConnection {\n  # A list of `LookupValue` objects.\n  nodes: [LookupValue]!\n\n  # A list of edges which contains the `LookupValue` and cursor to aid in pagination.\n  edges: [LookupValuesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `LookupValue` you could get from the connection.\n  totalCount: Int\n}\n\n# A `LookupValue` edge in the connection.\ntype LookupValuesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `LookupValue` at the end of the edge.\n  node: LookupValue\n}\n\n# Methods to use when ordering `LookupValue`.\nenum LookupValuesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  CODE_ASC\n  CODE_DESC\n  LOOKUP_ID_ASC\n  LOOKUP_ID_DESC\n  NUMERIC_SEQUENCER_ASC\n  NUMERIC_SEQUENCER_DESC\n  SEQUENCER_ASC\n  SEQUENCER_DESC\n  STRING_SEQUENCER_ASC\n  STRING_SEQUENCER_DESC\n  VALUE_ASC\n  VALUE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  LOOKUP_BY_LOOKUP_ID__ID_ASC\n  LOOKUP_BY_LOOKUP_ID__ID_DESC\n  LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_ASC\n  LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_DESC\n  LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_ASC\n  LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_DESC\n  LOOKUP_BY_LOOKUP_ID__CODE_SCALE_ASC\n  LOOKUP_BY_LOOKUP_ID__CODE_SCALE_DESC\n  LOOKUP_BY_LOOKUP_ID__CODE_TYPE_ASC\n  LOOKUP_BY_LOOKUP_ID__CODE_TYPE_DESC\n  LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_ASC\n  LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_DESC\n  LOOKUP_BY_LOOKUP_ID__ORDERING_ASC\n  LOOKUP_BY_LOOKUP_ID__ORDERING_DESC\n  LOOKUP_BY_LOOKUP_ID__REALM_ASC\n  LOOKUP_BY_LOOKUP_ID__REALM_DESC\n  LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_ASC\n  LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_DESC\n  LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_ASC\n  LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_DESC\n  LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_ASC\n  LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_DESC\n  LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_ASC\n  LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_DESC\n}\n\ntype MemberHotelRoomAssignment implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  memberId: BigInt!\n  hotelRoomId: BigInt!\n  roomOwner: Boolean!\n  year: Int!\n\n  # Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`.\n  member: Membership\n\n  # Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`.\n  hotelRoom: HotelRoomDetail\n}\n\n# A condition to be used against `MemberHotelRoomAssignment` object types. All\n# fields are tested for equality and combined with a logical ‘and.’\ninput MemberHotelRoomAssignmentCondition {\n  # Checks for equality with the object’s `memberId` field.\n  memberId: BigInt\n\n  # Checks for equality with the object’s `hotelRoomId` field.\n  hotelRoomId: BigInt\n\n  # Checks for equality with the object’s `roomOwner` field.\n  roomOwner: Boolean\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n}\n\n# A filter to be used against `MemberHotelRoomAssignment` object types. All fields are combined with a logical ‘and.’\ninput MemberHotelRoomAssignmentFilter {\n  # Filter by the object’s `memberId` field.\n  memberId: BigIntFilter\n\n  # Filter by the object’s `hotelRoomId` field.\n  hotelRoomId: BigIntFilter\n\n  # Filter by the object’s `roomOwner` field.\n  roomOwner: BooleanFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [MemberHotelRoomAssignmentFilter!]\n\n  # Checks for any expressions in this list.\n  or: [MemberHotelRoomAssignmentFilter!]\n\n  # Negates the expression.\n  not: MemberHotelRoomAssignmentFilter\n}\n\n# An input for mutations affecting `MemberHotelRoomAssignment`\ninput MemberHotelRoomAssignmentInput {\n  memberId: BigInt!\n  hotelRoomId: BigInt!\n  roomOwner: Boolean!\n  year: Int!\n}\n\n# Represents an update to a `MemberHotelRoomAssignment`. Fields that are set will be updated.\ninput MemberHotelRoomAssignmentPatch {\n  memberId: BigInt\n  hotelRoomId: BigInt\n  roomOwner: Boolean\n  year: Int\n}\n\n# A connection to a list of `MemberHotelRoomAssignment` values.\ntype MemberHotelRoomAssignmentsConnection {\n  # A list of `MemberHotelRoomAssignment` objects.\n  nodes: [MemberHotelRoomAssignment]!\n\n  # A list of edges which contains the `MemberHotelRoomAssignment` and cursor to aid in pagination.\n  edges: [MemberHotelRoomAssignmentsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `MemberHotelRoomAssignment` you could get from the connection.\n  totalCount: Int\n}\n\n# A `MemberHotelRoomAssignment` edge in the connection.\ntype MemberHotelRoomAssignmentsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `MemberHotelRoomAssignment` at the end of the edge.\n  node: MemberHotelRoomAssignment\n}\n\n# Methods to use when ordering `MemberHotelRoomAssignment`.\nenum MemberHotelRoomAssignmentsOrderBy {\n  NATURAL\n  MEMBER_ID_ASC\n  MEMBER_ID_DESC\n  HOTEL_ROOM_ID_ASC\n  HOTEL_ROOM_ID_DESC\n  ROOM_OWNER_ASC\n  ROOM_OWNER_DESC\n  YEAR_ASC\n  YEAR_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC\n  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC\n  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC\n  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC\n  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC\n  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC\n  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC\n  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ID_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ID_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__VERSION_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__VERSION_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__COMMENT_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__COMMENT_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ENABLED_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ENABLED_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__GAMING_ROOM_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__GAMING_ROOM_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__INTERNAL_ROOM_TYPE_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__INTERNAL_ROOM_TYPE_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__NAME_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__NAME_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_FOR_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_FOR_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ROOM_TYPE_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ROOM_TYPE_DESC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__FORMATTED_ROOM_TYPE_ASC\n  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__FORMATTED_ROOM_TYPE_DESC\n}\n\ntype Membership implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  arrivalDate: Datetime!\n  attendance: String!\n  attending: Boolean!\n  departureDate: Datetime!\n  hotelRoomId: Int!\n  interestLevel: String!\n  message: String!\n  roomPreferenceAndNotes: String!\n  roomingPreferences: String!\n  roomingWith: String!\n  userId: Int!\n  volunteer: Boolean!\n  year: Int!\n  offerSubsidy: Boolean!\n  requestOldPrice: Boolean!\n  amountOwed: Float!\n  amountPaid: Float!\n\n  # Reads a single `HotelRoom` that is related to this `Membership`.\n  hotelRoom: HotelRoom\n\n  # Reads a single `User` that is related to this `Membership`.\n  user: User\n\n  # Reads and enables pagination through a set of `GameAssignment`.\n  gameAssignmentsByMemberId(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameAssignment`.\n    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameAssignmentCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameAssignmentFilter\n  ): GameAssignmentsConnection!\n\n  # Reads and enables pagination through a set of `GameChoice`.\n  gameChoicesByMemberId(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameChoiceCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameChoiceFilter\n  ): GameChoicesConnection!\n\n  # Reads and enables pagination through a set of `GameSubmission`.\n  gameSubmissionsByMemberId(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameSubmission`.\n    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameSubmissionCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameSubmissionFilter\n  ): GameSubmissionsConnection!\n\n  # Reads and enables pagination through a set of `MemberHotelRoomAssignment`.\n  memberHotelRoomAssignmentsByMemberId(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `MemberHotelRoomAssignment`.\n    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: MemberHotelRoomAssignmentCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: MemberHotelRoomAssignmentFilter\n  ): MemberHotelRoomAssignmentsConnection!\n}\n\n# A condition to be used against `Membership` object types. All fields are tested\n# for equality and combined with a logical ‘and.’\ninput MembershipCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `arrivalDate` field.\n  arrivalDate: Datetime\n\n  # Checks for equality with the object’s `attendance` field.\n  attendance: String\n\n  # Checks for equality with the object’s `attending` field.\n  attending: Boolean\n\n  # Checks for equality with the object’s `departureDate` field.\n  departureDate: Datetime\n\n  # Checks for equality with the object’s `hotelRoomId` field.\n  hotelRoomId: Int\n\n  # Checks for equality with the object’s `interestLevel` field.\n  interestLevel: String\n\n  # Checks for equality with the object’s `message` field.\n  message: String\n\n  # Checks for equality with the object’s `roomPreferenceAndNotes` field.\n  roomPreferenceAndNotes: String\n\n  # Checks for equality with the object’s `roomingPreferences` field.\n  roomingPreferences: String\n\n  # Checks for equality with the object’s `roomingWith` field.\n  roomingWith: String\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `volunteer` field.\n  volunteer: Boolean\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n\n  # Checks for equality with the object’s `offerSubsidy` field.\n  offerSubsidy: Boolean\n\n  # Checks for equality with the object’s `requestOldPrice` field.\n  requestOldPrice: Boolean\n\n  # Checks for equality with the object’s `amountOwed` field.\n  amountOwed: Float\n\n  # Checks for equality with the object’s `amountPaid` field.\n  amountPaid: Float\n}\n\n# A filter to be used against `Membership` object types. All fields are combined with a logical ‘and.’\ninput MembershipFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `arrivalDate` field.\n  arrivalDate: DatetimeFilter\n\n  # Filter by the object’s `attendance` field.\n  attendance: StringFilter\n\n  # Filter by the object’s `attending` field.\n  attending: BooleanFilter\n\n  # Filter by the object’s `departureDate` field.\n  departureDate: DatetimeFilter\n\n  # Filter by the object’s `hotelRoomId` field.\n  hotelRoomId: IntFilter\n\n  # Filter by the object’s `interestLevel` field.\n  interestLevel: StringFilter\n\n  # Filter by the object’s `message` field.\n  message: StringFilter\n\n  # Filter by the object’s `roomPreferenceAndNotes` field.\n  roomPreferenceAndNotes: StringFilter\n\n  # Filter by the object’s `roomingPreferences` field.\n  roomingPreferences: StringFilter\n\n  # Filter by the object’s `roomingWith` field.\n  roomingWith: StringFilter\n\n  # Filter by the object’s `userId` field.\n  userId: IntFilter\n\n  # Filter by the object’s `volunteer` field.\n  volunteer: BooleanFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Filter by the object’s `offerSubsidy` field.\n  offerSubsidy: BooleanFilter\n\n  # Filter by the object’s `requestOldPrice` field.\n  requestOldPrice: BooleanFilter\n\n  # Filter by the object’s `amountOwed` field.\n  amountOwed: FloatFilter\n\n  # Filter by the object’s `amountPaid` field.\n  amountPaid: FloatFilter\n\n  # Checks for all expressions in this list.\n  and: [MembershipFilter!]\n\n  # Checks for any expressions in this list.\n  or: [MembershipFilter!]\n\n  # Negates the expression.\n  not: MembershipFilter\n}\n\n# An input for mutations affecting `Membership`\ninput MembershipInput {\n  id: Int\n  arrivalDate: Datetime!\n  attendance: String!\n  attending: Boolean!\n  departureDate: Datetime!\n  hotelRoomId: Int!\n  interestLevel: String!\n  message: String!\n  roomPreferenceAndNotes: String!\n  roomingPreferences: String!\n  roomingWith: String!\n  userId: Int!\n  volunteer: Boolean!\n  year: Int!\n  offerSubsidy: Boolean!\n  requestOldPrice: Boolean!\n  amountOwed: Float!\n  amountPaid: Float!\n}\n\n# Represents an update to a `Membership`. Fields that are set will be updated.\ninput MembershipPatch {\n  id: Int\n  arrivalDate: Datetime\n  attendance: String\n  attending: Boolean\n  departureDate: Datetime\n  hotelRoomId: Int\n  interestLevel: String\n  message: String\n  roomPreferenceAndNotes: String\n  roomingPreferences: String\n  roomingWith: String\n  userId: Int\n  volunteer: Boolean\n  year: Int\n  offerSubsidy: Boolean\n  requestOldPrice: Boolean\n  amountOwed: Float\n  amountPaid: Float\n}\n\n# A connection to a list of `Membership` values.\ntype MembershipsConnection {\n  # A list of `Membership` objects.\n  nodes: [Membership]!\n\n  # A list of edges which contains the `Membership` and cursor to aid in pagination.\n  edges: [MembershipsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Membership` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Membership` edge in the connection.\ntype MembershipsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Membership` at the end of the edge.\n  node: Membership\n}\n\n# Methods to use when ordering `Membership`.\nenum MembershipsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  ARRIVAL_DATE_ASC\n  ARRIVAL_DATE_DESC\n  ATTENDANCE_ASC\n  ATTENDANCE_DESC\n  ATTENDING_ASC\n  ATTENDING_DESC\n  DEPARTURE_DATE_ASC\n  DEPARTURE_DATE_DESC\n  HOTEL_ROOM_ID_ASC\n  HOTEL_ROOM_ID_DESC\n  INTEREST_LEVEL_ASC\n  INTEREST_LEVEL_DESC\n  MESSAGE_ASC\n  MESSAGE_DESC\n  ROOM_PREFERENCE_AND_NOTES_ASC\n  ROOM_PREFERENCE_AND_NOTES_DESC\n  ROOMING_PREFERENCES_ASC\n  ROOMING_PREFERENCES_DESC\n  ROOMING_WITH_ASC\n  ROOMING_WITH_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  VOLUNTEER_ASC\n  VOLUNTEER_DESC\n  YEAR_ASC\n  YEAR_DESC\n  OFFER_SUBSIDY_ASC\n  OFFER_SUBSIDY_DESC\n  REQUEST_OLD_PRICE_ASC\n  REQUEST_OLD_PRICE_DESC\n  AMOUNT_OWED_ASC\n  AMOUNT_OWED_DESC\n  AMOUNT_PAID_ASC\n  AMOUNT_PAID_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_DESC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_ASC\n  HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_DESC\n  USER_BY_USER_ID__ID_ASC\n  USER_BY_USER_ID__ID_DESC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC\n  USER_BY_USER_ID__ENABLED_ASC\n  USER_BY_USER_ID__ENABLED_DESC\n  USER_BY_USER_ID__PASSWORD_ASC\n  USER_BY_USER_ID__PASSWORD_DESC\n  USER_BY_USER_ID__PROFILE_ID_ASC\n  USER_BY_USER_ID__PROFILE_ID_DESC\n  USER_BY_USER_ID__USERNAME_ASC\n  USER_BY_USER_ID__USERNAME_DESC\n  GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_ASC\n  GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_DESC\n  GAME_CHOICES_BY_MEMBER_ID__COUNT_ASC\n  GAME_CHOICES_BY_MEMBER_ID__COUNT_DESC\n  GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_ASC\n  GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_DESC\n  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_MEMBER_ID__COUNT_ASC\n  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_MEMBER_ID__COUNT_DESC\n}\n\n# The root mutation type which contains root level fields which mutate data.\ntype Mutation {\n  # Creates a single `Game`.\n  createGame(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateGameInput!\n  ): CreateGamePayload\n\n  # Creates a single `GameAssignment`.\n  createGameAssignment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateGameAssignmentInput!\n  ): CreateGameAssignmentPayload\n\n  # Creates a single `GameChoice`.\n  createGameChoice(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateGameChoiceInput!\n  ): CreateGameChoicePayload\n\n  # Creates a single `GameSubmission`.\n  createGameSubmission(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateGameSubmissionInput!\n  ): CreateGameSubmissionPayload\n\n  # Creates a single `HotelRoom`.\n  createHotelRoom(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateHotelRoomInput!\n  ): CreateHotelRoomPayload\n\n  # Creates a single `HotelRoomDetail`.\n  createHotelRoomDetail(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateHotelRoomDetailInput!\n  ): CreateHotelRoomDetailPayload\n\n  # Creates a single `Lookup`.\n  createLookup(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateLookupInput!\n  ): CreateLookupPayload\n\n  # Creates a single `LookupValue`.\n  createLookupValue(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateLookupValueInput!\n  ): CreateLookupValuePayload\n\n  # Creates a single `MemberHotelRoomAssignment`.\n  createMemberHotelRoomAssignment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateMemberHotelRoomAssignmentInput!\n  ): CreateMemberHotelRoomAssignmentPayload\n\n  # Creates a single `Membership`.\n  createMembership(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateMembershipInput!\n  ): CreateMembershipPayload\n\n  # Creates a single `Profile`.\n  createProfile(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateProfileInput!\n  ): CreateProfilePayload\n\n  # Creates a single `RegistrationCode`.\n  createRegistrationCode(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateRegistrationCodeInput!\n  ): CreateRegistrationCodePayload\n\n  # Creates a single `Role`.\n  createRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateRoleInput!\n  ): CreateRolePayload\n\n  # Creates a single `Room`.\n  createRoom(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateRoomInput!\n  ): CreateRoomPayload\n\n  # Creates a single `Setting`.\n  createSetting(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateSettingInput!\n  ): CreateSettingPayload\n\n  # Creates a single `ShirtOrder`.\n  createShirtOrder(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateShirtOrderInput!\n  ): CreateShirtOrderPayload\n\n  # Creates a single `ShirtOrderItem`.\n  createShirtOrderItem(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateShirtOrderItemInput!\n  ): CreateShirtOrderItemPayload\n\n  # Creates a single `Slot`.\n  createSlot(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateSlotInput!\n  ): CreateSlotPayload\n\n  # Creates a single `Token`.\n  createToken(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateTokenInput!\n  ): CreateTokenPayload\n\n  # Creates a single `User`.\n  createUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateUserInput!\n  ): CreateUserPayload\n\n  # Creates a single `UserRole`.\n  createUserRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: CreateUserRoleInput!\n  ): CreateUserRolePayload\n\n  # Updates a single `Game` using its globally unique id and a patch.\n  updateGameByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameByNodeIdInput!\n  ): UpdateGamePayload\n\n  # Updates a single `Game` using a unique key and a patch.\n  updateGame(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameInput!\n  ): UpdateGamePayload\n\n  # Updates a single `GameAssignment` using its globally unique id and a patch.\n  updateGameAssignmentByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameAssignmentByNodeIdInput!\n  ): UpdateGameAssignmentPayload\n\n  # Updates a single `GameAssignment` using a unique key and a patch.\n  updateGameAssignment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameAssignmentInput!\n  ): UpdateGameAssignmentPayload\n\n  # Updates a single `GameChoice` using its globally unique id and a patch.\n  updateGameChoiceByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameChoiceByNodeIdInput!\n  ): UpdateGameChoicePayload\n\n  # Updates a single `GameChoice` using a unique key and a patch.\n  updateGameChoice(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameChoiceInput!\n  ): UpdateGameChoicePayload\n\n  # Updates a single `GameSubmission` using its globally unique id and a patch.\n  updateGameSubmissionByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameSubmissionByNodeIdInput!\n  ): UpdateGameSubmissionPayload\n\n  # Updates a single `GameSubmission` using a unique key and a patch.\n  updateGameSubmission(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateGameSubmissionInput!\n  ): UpdateGameSubmissionPayload\n\n  # Updates a single `HotelRoom` using its globally unique id and a patch.\n  updateHotelRoomByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateHotelRoomByNodeIdInput!\n  ): UpdateHotelRoomPayload\n\n  # Updates a single `HotelRoom` using a unique key and a patch.\n  updateHotelRoom(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateHotelRoomInput!\n  ): UpdateHotelRoomPayload\n\n  # Updates a single `HotelRoomDetail` using its globally unique id and a patch.\n  updateHotelRoomDetailByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateHotelRoomDetailByNodeIdInput!\n  ): UpdateHotelRoomDetailPayload\n\n  # Updates a single `HotelRoomDetail` using a unique key and a patch.\n  updateHotelRoomDetail(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateHotelRoomDetailInput!\n  ): UpdateHotelRoomDetailPayload\n\n  # Updates a single `Lookup` using its globally unique id and a patch.\n  updateLookupByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateLookupByNodeIdInput!\n  ): UpdateLookupPayload\n\n  # Updates a single `Lookup` using a unique key and a patch.\n  updateLookup(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateLookupInput!\n  ): UpdateLookupPayload\n\n  # Updates a single `Lookup` using a unique key and a patch.\n  updateLookupByRealm(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateLookupByRealmInput!\n  ): UpdateLookupPayload\n\n  # Updates a single `LookupValue` using its globally unique id and a patch.\n  updateLookupValueByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateLookupValueByNodeIdInput!\n  ): UpdateLookupValuePayload\n\n  # Updates a single `LookupValue` using a unique key and a patch.\n  updateLookupValue(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateLookupValueInput!\n  ): UpdateLookupValuePayload\n\n  # Updates a single `LookupValue` using a unique key and a patch.\n  updateLookupValueByLookupIdAndCode(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateLookupValueByLookupIdAndCodeInput!\n  ): UpdateLookupValuePayload\n\n  # Updates a single `MemberHotelRoomAssignment` using its globally unique id and a patch.\n  updateMemberHotelRoomAssignmentByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateMemberHotelRoomAssignmentByNodeIdInput!\n  ): UpdateMemberHotelRoomAssignmentPayload\n\n  # Updates a single `MemberHotelRoomAssignment` using a unique key and a patch.\n  updateMemberHotelRoomAssignment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateMemberHotelRoomAssignmentInput!\n  ): UpdateMemberHotelRoomAssignmentPayload\n\n  # Updates a single `Membership` using its globally unique id and a patch.\n  updateMembershipByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateMembershipByNodeIdInput!\n  ): UpdateMembershipPayload\n\n  # Updates a single `Membership` using a unique key and a patch.\n  updateMembership(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateMembershipInput!\n  ): UpdateMembershipPayload\n\n  # Updates a single `Profile` using its globally unique id and a patch.\n  updateProfileByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateProfileByNodeIdInput!\n  ): UpdateProfilePayload\n\n  # Updates a single `Profile` using a unique key and a patch.\n  updateProfile(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateProfileInput!\n  ): UpdateProfilePayload\n\n  # Updates a single `Profile` using a unique key and a patch.\n  updateProfileByEmail(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateProfileByEmailInput!\n  ): UpdateProfilePayload\n\n  # Updates a single `RegistrationCode` using its globally unique id and a patch.\n  updateRegistrationCodeByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRegistrationCodeByNodeIdInput!\n  ): UpdateRegistrationCodePayload\n\n  # Updates a single `RegistrationCode` using a unique key and a patch.\n  updateRegistrationCode(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRegistrationCodeInput!\n  ): UpdateRegistrationCodePayload\n\n  # Updates a single `Role` using its globally unique id and a patch.\n  updateRoleByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoleByNodeIdInput!\n  ): UpdateRolePayload\n\n  # Updates a single `Role` using a unique key and a patch.\n  updateRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoleInput!\n  ): UpdateRolePayload\n\n  # Updates a single `Role` using a unique key and a patch.\n  updateRoleByAuthority(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoleByAuthorityInput!\n  ): UpdateRolePayload\n\n  # Updates a single `Room` using its globally unique id and a patch.\n  updateRoomByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoomByNodeIdInput!\n  ): UpdateRoomPayload\n\n  # Updates a single `Room` using a unique key and a patch.\n  updateRoom(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateRoomInput!\n  ): UpdateRoomPayload\n\n  # Updates a single `Setting` using its globally unique id and a patch.\n  updateSettingByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateSettingByNodeIdInput!\n  ): UpdateSettingPayload\n\n  # Updates a single `Setting` using a unique key and a patch.\n  updateSetting(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateSettingInput!\n  ): UpdateSettingPayload\n\n  # Updates a single `ShirtOrder` using its globally unique id and a patch.\n  updateShirtOrderByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateShirtOrderByNodeIdInput!\n  ): UpdateShirtOrderPayload\n\n  # Updates a single `ShirtOrder` using a unique key and a patch.\n  updateShirtOrder(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateShirtOrderInput!\n  ): UpdateShirtOrderPayload\n\n  # Updates a single `ShirtOrderItem` using its globally unique id and a patch.\n  updateShirtOrderItemByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateShirtOrderItemByNodeIdInput!\n  ): UpdateShirtOrderItemPayload\n\n  # Updates a single `ShirtOrderItem` using a unique key and a patch.\n  updateShirtOrderItem(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateShirtOrderItemInput!\n  ): UpdateShirtOrderItemPayload\n\n  # Updates a single `Slot` using its globally unique id and a patch.\n  updateSlotByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateSlotByNodeIdInput!\n  ): UpdateSlotPayload\n\n  # Updates a single `Slot` using a unique key and a patch.\n  updateSlot(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateSlotInput!\n  ): UpdateSlotPayload\n\n  # Updates a single `Token` using its globally unique id and a patch.\n  updateTokenByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateTokenByNodeIdInput!\n  ): UpdateTokenPayload\n\n  # Updates a single `Token` using a unique key and a patch.\n  updateToken(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateTokenInput!\n  ): UpdateTokenPayload\n\n  # Updates a single `User` using its globally unique id and a patch.\n  updateUserByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserByNodeIdInput!\n  ): UpdateUserPayload\n\n  # Updates a single `User` using a unique key and a patch.\n  updateUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserInput!\n  ): UpdateUserPayload\n\n  # Updates a single `User` using a unique key and a patch.\n  updateUserByUsername(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserByUsernameInput!\n  ): UpdateUserPayload\n\n  # Updates a single `UserRole` using its globally unique id and a patch.\n  updateUserRoleByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserRoleByNodeIdInput!\n  ): UpdateUserRolePayload\n\n  # Updates a single `UserRole` using a unique key and a patch.\n  updateUserRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: UpdateUserRoleInput!\n  ): UpdateUserRolePayload\n\n  # Deletes a single `Game` using its globally unique id.\n  deleteGameByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameByNodeIdInput!\n  ): DeleteGamePayload\n\n  # Deletes a single `Game` using a unique key.\n  deleteGame(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameInput!\n  ): DeleteGamePayload\n\n  # Deletes a single `GameAssignment` using its globally unique id.\n  deleteGameAssignmentByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameAssignmentByNodeIdInput!\n  ): DeleteGameAssignmentPayload\n\n  # Deletes a single `GameAssignment` using a unique key.\n  deleteGameAssignment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameAssignmentInput!\n  ): DeleteGameAssignmentPayload\n\n  # Deletes a single `GameChoice` using its globally unique id.\n  deleteGameChoiceByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameChoiceByNodeIdInput!\n  ): DeleteGameChoicePayload\n\n  # Deletes a single `GameChoice` using a unique key.\n  deleteGameChoice(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameChoiceInput!\n  ): DeleteGameChoicePayload\n\n  # Deletes a single `GameSubmission` using its globally unique id.\n  deleteGameSubmissionByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameSubmissionByNodeIdInput!\n  ): DeleteGameSubmissionPayload\n\n  # Deletes a single `GameSubmission` using a unique key.\n  deleteGameSubmission(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteGameSubmissionInput!\n  ): DeleteGameSubmissionPayload\n\n  # Deletes a single `HotelRoom` using its globally unique id.\n  deleteHotelRoomByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteHotelRoomByNodeIdInput!\n  ): DeleteHotelRoomPayload\n\n  # Deletes a single `HotelRoom` using a unique key.\n  deleteHotelRoom(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteHotelRoomInput!\n  ): DeleteHotelRoomPayload\n\n  # Deletes a single `HotelRoomDetail` using its globally unique id.\n  deleteHotelRoomDetailByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteHotelRoomDetailByNodeIdInput!\n  ): DeleteHotelRoomDetailPayload\n\n  # Deletes a single `HotelRoomDetail` using a unique key.\n  deleteHotelRoomDetail(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteHotelRoomDetailInput!\n  ): DeleteHotelRoomDetailPayload\n\n  # Deletes a single `Lookup` using its globally unique id.\n  deleteLookupByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteLookupByNodeIdInput!\n  ): DeleteLookupPayload\n\n  # Deletes a single `Lookup` using a unique key.\n  deleteLookup(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteLookupInput!\n  ): DeleteLookupPayload\n\n  # Deletes a single `Lookup` using a unique key.\n  deleteLookupByRealm(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteLookupByRealmInput!\n  ): DeleteLookupPayload\n\n  # Deletes a single `LookupValue` using its globally unique id.\n  deleteLookupValueByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteLookupValueByNodeIdInput!\n  ): DeleteLookupValuePayload\n\n  # Deletes a single `LookupValue` using a unique key.\n  deleteLookupValue(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteLookupValueInput!\n  ): DeleteLookupValuePayload\n\n  # Deletes a single `LookupValue` using a unique key.\n  deleteLookupValueByLookupIdAndCode(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteLookupValueByLookupIdAndCodeInput!\n  ): DeleteLookupValuePayload\n\n  # Deletes a single `MemberHotelRoomAssignment` using its globally unique id.\n  deleteMemberHotelRoomAssignmentByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteMemberHotelRoomAssignmentByNodeIdInput!\n  ): DeleteMemberHotelRoomAssignmentPayload\n\n  # Deletes a single `MemberHotelRoomAssignment` using a unique key.\n  deleteMemberHotelRoomAssignment(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteMemberHotelRoomAssignmentInput!\n  ): DeleteMemberHotelRoomAssignmentPayload\n\n  # Deletes a single `Membership` using its globally unique id.\n  deleteMembershipByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteMembershipByNodeIdInput!\n  ): DeleteMembershipPayload\n\n  # Deletes a single `Membership` using a unique key.\n  deleteMembership(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteMembershipInput!\n  ): DeleteMembershipPayload\n\n  # Deletes a single `Profile` using its globally unique id.\n  deleteProfileByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteProfileByNodeIdInput!\n  ): DeleteProfilePayload\n\n  # Deletes a single `Profile` using a unique key.\n  deleteProfile(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteProfileInput!\n  ): DeleteProfilePayload\n\n  # Deletes a single `Profile` using a unique key.\n  deleteProfileByEmail(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteProfileByEmailInput!\n  ): DeleteProfilePayload\n\n  # Deletes a single `RegistrationCode` using its globally unique id.\n  deleteRegistrationCodeByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRegistrationCodeByNodeIdInput!\n  ): DeleteRegistrationCodePayload\n\n  # Deletes a single `RegistrationCode` using a unique key.\n  deleteRegistrationCode(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRegistrationCodeInput!\n  ): DeleteRegistrationCodePayload\n\n  # Deletes a single `Role` using its globally unique id.\n  deleteRoleByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoleByNodeIdInput!\n  ): DeleteRolePayload\n\n  # Deletes a single `Role` using a unique key.\n  deleteRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoleInput!\n  ): DeleteRolePayload\n\n  # Deletes a single `Role` using a unique key.\n  deleteRoleByAuthority(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoleByAuthorityInput!\n  ): DeleteRolePayload\n\n  # Deletes a single `Room` using its globally unique id.\n  deleteRoomByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoomByNodeIdInput!\n  ): DeleteRoomPayload\n\n  # Deletes a single `Room` using a unique key.\n  deleteRoom(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteRoomInput!\n  ): DeleteRoomPayload\n\n  # Deletes a single `Setting` using its globally unique id.\n  deleteSettingByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteSettingByNodeIdInput!\n  ): DeleteSettingPayload\n\n  # Deletes a single `Setting` using a unique key.\n  deleteSetting(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteSettingInput!\n  ): DeleteSettingPayload\n\n  # Deletes a single `ShirtOrder` using its globally unique id.\n  deleteShirtOrderByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteShirtOrderByNodeIdInput!\n  ): DeleteShirtOrderPayload\n\n  # Deletes a single `ShirtOrder` using a unique key.\n  deleteShirtOrder(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteShirtOrderInput!\n  ): DeleteShirtOrderPayload\n\n  # Deletes a single `ShirtOrderItem` using its globally unique id.\n  deleteShirtOrderItemByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteShirtOrderItemByNodeIdInput!\n  ): DeleteShirtOrderItemPayload\n\n  # Deletes a single `ShirtOrderItem` using a unique key.\n  deleteShirtOrderItem(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteShirtOrderItemInput!\n  ): DeleteShirtOrderItemPayload\n\n  # Deletes a single `Slot` using its globally unique id.\n  deleteSlotByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteSlotByNodeIdInput!\n  ): DeleteSlotPayload\n\n  # Deletes a single `Slot` using a unique key.\n  deleteSlot(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteSlotInput!\n  ): DeleteSlotPayload\n\n  # Deletes a single `Token` using its globally unique id.\n  deleteTokenByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteTokenByNodeIdInput!\n  ): DeleteTokenPayload\n\n  # Deletes a single `Token` using a unique key.\n  deleteToken(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteTokenInput!\n  ): DeleteTokenPayload\n\n  # Deletes a single `User` using its globally unique id.\n  deleteUserByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserByNodeIdInput!\n  ): DeleteUserPayload\n\n  # Deletes a single `User` using a unique key.\n  deleteUser(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserInput!\n  ): DeleteUserPayload\n\n  # Deletes a single `User` using a unique key.\n  deleteUserByUsername(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserByUsernameInput!\n  ): DeleteUserPayload\n\n  # Deletes a single `UserRole` using its globally unique id.\n  deleteUserRoleByNodeId(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserRoleByNodeIdInput!\n  ): DeleteUserRolePayload\n\n  # Deletes a single `UserRole` using a unique key.\n  deleteUserRole(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: DeleteUserRoleInput!\n  ): DeleteUserRolePayload\n  fTruncateTables(\n    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.\n    input: FTruncateTablesInput!\n  ): FTruncateTablesPayload\n}\n\n# An object with a globally unique `ID`.\ninterface Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n}\n\n# Information about pagination in a connection.\ntype PageInfo {\n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean!\n\n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean!\n\n  # When paginating backwards, the cursor to continue.\n  startCursor: Cursor\n\n  # When paginating forwards, the cursor to continue.\n  endCursor: Cursor\n}\n\ntype Profile implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  email: String!\n  fullName: String!\n  phoneNumber: String\n  snailMailAddress: String\n\n  # Reads and enables pagination through a set of `User`.\n  users(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `User`.\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: UserFilter\n  ): UsersConnection!\n}\n\n# A condition to be used against `Profile` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput ProfileCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `email` field.\n  email: String\n\n  # Checks for equality with the object’s `fullName` field.\n  fullName: String\n\n  # Checks for equality with the object’s `phoneNumber` field.\n  phoneNumber: String\n\n  # Checks for equality with the object’s `snailMailAddress` field.\n  snailMailAddress: String\n}\n\n# A filter to be used against `Profile` object types. All fields are combined with a logical ‘and.’\ninput ProfileFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `email` field.\n  email: StringFilter\n\n  # Filter by the object’s `fullName` field.\n  fullName: StringFilter\n\n  # Filter by the object’s `phoneNumber` field.\n  phoneNumber: StringFilter\n\n  # Filter by the object’s `snailMailAddress` field.\n  snailMailAddress: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [ProfileFilter!]\n\n  # Checks for any expressions in this list.\n  or: [ProfileFilter!]\n\n  # Negates the expression.\n  not: ProfileFilter\n}\n\n# An input for mutations affecting `Profile`\ninput ProfileInput {\n  id: Int\n  email: String!\n  fullName: String!\n  phoneNumber: String\n  snailMailAddress: String\n}\n\n# Represents an update to a `Profile`. Fields that are set will be updated.\ninput ProfilePatch {\n  id: Int\n  email: String\n  fullName: String\n  phoneNumber: String\n  snailMailAddress: String\n}\n\n# A connection to a list of `Profile` values.\ntype ProfilesConnection {\n  # A list of `Profile` objects.\n  nodes: [Profile]!\n\n  # A list of edges which contains the `Profile` and cursor to aid in pagination.\n  edges: [ProfilesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Profile` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Profile` edge in the connection.\ntype ProfilesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Profile` at the end of the edge.\n  node: Profile\n}\n\n# Methods to use when ordering `Profile`.\nenum ProfilesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  EMAIL_ASC\n  EMAIL_DESC\n  FULL_NAME_ASC\n  FULL_NAME_DESC\n  PHONE_NUMBER_ASC\n  PHONE_NUMBER_DESC\n  SNAIL_MAIL_ADDRESS_ASC\n  SNAIL_MAIL_ADDRESS_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  USERS_BY_PROFILE_ID__COUNT_ASC\n  USERS_BY_PROFILE_ID__COUNT_DESC\n}\n\n# The root query type which gives access points into the data universe.\ntype Query implements Node {\n  # Exposes the root query type nested one level down. This is helpful for Relay 1\n  # which can only query top level fields if they are in a particular form.\n  query: Query!\n\n  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.\n  nodeId: ID!\n\n  # Fetches an object given its globally unique `ID`.\n  node(\n    # The globally unique `ID`.\n    nodeId: ID!\n  ): Node\n\n  # Reads and enables pagination through a set of `Game`.\n  games(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameFilter\n  ): GamesConnection\n\n  # Reads and enables pagination through a set of `GameAssignment`.\n  gameAssignments(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameAssignment`.\n    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameAssignmentCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameAssignmentFilter\n  ): GameAssignmentsConnection\n\n  # Reads and enables pagination through a set of `GameChoice`.\n  gameChoices(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameChoiceCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameChoiceFilter\n  ): GameChoicesConnection\n\n  # Reads and enables pagination through a set of `GameSubmission`.\n  gameSubmissions(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameSubmission`.\n    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameSubmissionCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameSubmissionFilter\n  ): GameSubmissionsConnection\n\n  # Reads and enables pagination through a set of `HotelRoom`.\n  hotelRooms(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `HotelRoom`.\n    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: HotelRoomCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: HotelRoomFilter\n  ): HotelRoomsConnection\n\n  # Reads and enables pagination through a set of `HotelRoomDetail`.\n  hotelRoomDetails(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `HotelRoomDetail`.\n    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: HotelRoomDetailCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: HotelRoomDetailFilter\n  ): HotelRoomDetailsConnection\n\n  # Reads and enables pagination through a set of `Lookup`.\n  lookups(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Lookup`.\n    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: LookupCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: LookupFilter\n  ): LookupsConnection\n\n  # Reads and enables pagination through a set of `LookupValue`.\n  lookupValues(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `LookupValue`.\n    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: LookupValueCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: LookupValueFilter\n  ): LookupValuesConnection\n\n  # Reads and enables pagination through a set of `MemberHotelRoomAssignment`.\n  memberHotelRoomAssignments(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `MemberHotelRoomAssignment`.\n    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: MemberHotelRoomAssignmentCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: MemberHotelRoomAssignmentFilter\n  ): MemberHotelRoomAssignmentsConnection\n\n  # Reads and enables pagination through a set of `Membership`.\n  memberships(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Membership`.\n    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: MembershipCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: MembershipFilter\n  ): MembershipsConnection\n\n  # Reads and enables pagination through a set of `Profile`.\n  profiles(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Profile`.\n    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: ProfileCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: ProfileFilter\n  ): ProfilesConnection\n\n  # Reads and enables pagination through a set of `RegistrationCode`.\n  registrationCodes(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `RegistrationCode`.\n    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: RegistrationCodeCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: RegistrationCodeFilter\n  ): RegistrationCodesConnection\n\n  # Reads and enables pagination through a set of `Role`.\n  roles(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: RoleCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: RoleFilter\n  ): RolesConnection\n\n  # Reads and enables pagination through a set of `Room`.\n  rooms(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Room`.\n    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: RoomCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: RoomFilter\n  ): RoomsConnection\n\n  # Reads and enables pagination through a set of `Setting`.\n  settings(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Setting`.\n    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: SettingCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: SettingFilter\n  ): SettingsConnection\n\n  # Reads and enables pagination through a set of `ShirtOrder`.\n  shirtOrders(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `ShirtOrder`.\n    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: ShirtOrderCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: ShirtOrderFilter\n  ): ShirtOrdersConnection\n\n  # Reads and enables pagination through a set of `ShirtOrderItem`.\n  shirtOrderItems(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `ShirtOrderItem`.\n    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: ShirtOrderItemCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: ShirtOrderItemFilter\n  ): ShirtOrderItemsConnection\n\n  # Reads and enables pagination through a set of `Slot`.\n  slots(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Slot`.\n    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: SlotCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: SlotFilter\n  ): SlotsConnection\n\n  # Reads and enables pagination through a set of `Token`.\n  tokens(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Token`.\n    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: TokenCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: TokenFilter\n  ): TokensConnection\n\n  # Reads and enables pagination through a set of `User`.\n  users(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `User`.\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: UserFilter\n  ): UsersConnection\n\n  # Reads and enables pagination through a set of `UserRole`.\n  userRoles(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `UserRole`.\n    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserRoleCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: UserRoleFilter\n  ): UserRolesConnection\n  game(id: Int!): Game\n  gameAssignment(memberId: Int!, gameId: Int!, gm: Int!): GameAssignment\n  gameChoice(id: Int!): GameChoice\n  gameSubmission(id: Int!): GameSubmission\n  hotelRoom(id: Int!): HotelRoom\n  hotelRoomDetail(id: BigInt!): HotelRoomDetail\n  lookup(id: Int!): Lookup\n  lookupByRealm(realm: String!): Lookup\n  lookupValue(id: Int!): LookupValue\n  lookupValueByLookupIdAndCode(lookupId: Int!, code: String!): LookupValue\n  memberHotelRoomAssignment(memberId: BigInt!, hotelRoomId: BigInt!): MemberHotelRoomAssignment\n  membership(id: Int!): Membership\n  profile(id: Int!): Profile\n  profileByEmail(email: String!): Profile\n  registrationCode(id: Int!): RegistrationCode\n  role(id: Int!): Role\n  roleByAuthority(authority: String!): Role\n  room(id: Int!): Room\n  setting(id: Int!): Setting\n  shirtOrder(id: Int!): ShirtOrder\n  shirtOrderItem(id: Int!): ShirtOrderItem\n  slot(id: Int!): Slot\n  token(id: Int!): Token\n  user(id: Int!): User\n  userByUsername(username: String!): User\n  userRole(roleId: Int!, userId: Int!): UserRole\n\n  # Reads a single `Game` using its globally unique `ID`.\n  gameByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Game`.\n    nodeId: ID!\n  ): Game\n\n  # Reads a single `GameAssignment` using its globally unique `ID`.\n  gameAssignmentByNodeId(\n    # The globally unique `ID` to be used in selecting a single `GameAssignment`.\n    nodeId: ID!\n  ): GameAssignment\n\n  # Reads a single `GameChoice` using its globally unique `ID`.\n  gameChoiceByNodeId(\n    # The globally unique `ID` to be used in selecting a single `GameChoice`.\n    nodeId: ID!\n  ): GameChoice\n\n  # Reads a single `GameSubmission` using its globally unique `ID`.\n  gameSubmissionByNodeId(\n    # The globally unique `ID` to be used in selecting a single `GameSubmission`.\n    nodeId: ID!\n  ): GameSubmission\n\n  # Reads a single `HotelRoom` using its globally unique `ID`.\n  hotelRoomByNodeId(\n    # The globally unique `ID` to be used in selecting a single `HotelRoom`.\n    nodeId: ID!\n  ): HotelRoom\n\n  # Reads a single `HotelRoomDetail` using its globally unique `ID`.\n  hotelRoomDetailByNodeId(\n    # The globally unique `ID` to be used in selecting a single `HotelRoomDetail`.\n    nodeId: ID!\n  ): HotelRoomDetail\n\n  # Reads a single `Lookup` using its globally unique `ID`.\n  lookupByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Lookup`.\n    nodeId: ID!\n  ): Lookup\n\n  # Reads a single `LookupValue` using its globally unique `ID`.\n  lookupValueByNodeId(\n    # The globally unique `ID` to be used in selecting a single `LookupValue`.\n    nodeId: ID!\n  ): LookupValue\n\n  # Reads a single `MemberHotelRoomAssignment` using its globally unique `ID`.\n  memberHotelRoomAssignmentByNodeId(\n    # The globally unique `ID` to be used in selecting a single `MemberHotelRoomAssignment`.\n    nodeId: ID!\n  ): MemberHotelRoomAssignment\n\n  # Reads a single `Membership` using its globally unique `ID`.\n  membershipByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Membership`.\n    nodeId: ID!\n  ): Membership\n\n  # Reads a single `Profile` using its globally unique `ID`.\n  profileByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Profile`.\n    nodeId: ID!\n  ): Profile\n\n  # Reads a single `RegistrationCode` using its globally unique `ID`.\n  registrationCodeByNodeId(\n    # The globally unique `ID` to be used in selecting a single `RegistrationCode`.\n    nodeId: ID!\n  ): RegistrationCode\n\n  # Reads a single `Role` using its globally unique `ID`.\n  roleByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Role`.\n    nodeId: ID!\n  ): Role\n\n  # Reads a single `Room` using its globally unique `ID`.\n  roomByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Room`.\n    nodeId: ID!\n  ): Room\n\n  # Reads a single `Setting` using its globally unique `ID`.\n  settingByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Setting`.\n    nodeId: ID!\n  ): Setting\n\n  # Reads a single `ShirtOrder` using its globally unique `ID`.\n  shirtOrderByNodeId(\n    # The globally unique `ID` to be used in selecting a single `ShirtOrder`.\n    nodeId: ID!\n  ): ShirtOrder\n\n  # Reads a single `ShirtOrderItem` using its globally unique `ID`.\n  shirtOrderItemByNodeId(\n    # The globally unique `ID` to be used in selecting a single `ShirtOrderItem`.\n    nodeId: ID!\n  ): ShirtOrderItem\n\n  # Reads a single `Slot` using its globally unique `ID`.\n  slotByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Slot`.\n    nodeId: ID!\n  ): Slot\n\n  # Reads a single `Token` using its globally unique `ID`.\n  tokenByNodeId(\n    # The globally unique `ID` to be used in selecting a single `Token`.\n    nodeId: ID!\n  ): Token\n\n  # Reads a single `User` using its globally unique `ID`.\n  userByNodeId(\n    # The globally unique `ID` to be used in selecting a single `User`.\n    nodeId: ID!\n  ): User\n\n  # Reads a single `UserRole` using its globally unique `ID`.\n  userRoleByNodeId(\n    # The globally unique `ID` to be used in selecting a single `UserRole`.\n    nodeId: ID!\n  ): UserRole\n}\n\ntype RegistrationCode implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  token: String!\n  username: String!\n}\n\n# A condition to be used against `RegistrationCode` object types. All fields are\n# tested for equality and combined with a logical ‘and.’\ninput RegistrationCodeCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `token` field.\n  token: String\n\n  # Checks for equality with the object’s `username` field.\n  username: String\n}\n\n# A filter to be used against `RegistrationCode` object types. All fields are combined with a logical ‘and.’\ninput RegistrationCodeFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `token` field.\n  token: StringFilter\n\n  # Filter by the object’s `username` field.\n  username: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [RegistrationCodeFilter!]\n\n  # Checks for any expressions in this list.\n  or: [RegistrationCodeFilter!]\n\n  # Negates the expression.\n  not: RegistrationCodeFilter\n}\n\n# An input for mutations affecting `RegistrationCode`\ninput RegistrationCodeInput {\n  id: Int\n  token: String!\n  username: String!\n}\n\n# Represents an update to a `RegistrationCode`. Fields that are set will be updated.\ninput RegistrationCodePatch {\n  id: Int\n  token: String\n  username: String\n}\n\n# A connection to a list of `RegistrationCode` values.\ntype RegistrationCodesConnection {\n  # A list of `RegistrationCode` objects.\n  nodes: [RegistrationCode]!\n\n  # A list of edges which contains the `RegistrationCode` and cursor to aid in pagination.\n  edges: [RegistrationCodesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `RegistrationCode` you could get from the connection.\n  totalCount: Int\n}\n\n# A `RegistrationCode` edge in the connection.\ntype RegistrationCodesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `RegistrationCode` at the end of the edge.\n  node: RegistrationCode\n}\n\n# Methods to use when ordering `RegistrationCode`.\nenum RegistrationCodesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  TOKEN_ASC\n  TOKEN_DESC\n  USERNAME_ASC\n  USERNAME_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n}\n\ntype Role implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  authority: String!\n\n  # Reads and enables pagination through a set of `UserRole`.\n  userRoles(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `UserRole`.\n    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserRoleCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: UserRoleFilter\n  ): UserRolesConnection!\n}\n\n# A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput RoleCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `authority` field.\n  authority: String\n}\n\n# A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’\ninput RoleFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `authority` field.\n  authority: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [RoleFilter!]\n\n  # Checks for any expressions in this list.\n  or: [RoleFilter!]\n\n  # Negates the expression.\n  not: RoleFilter\n}\n\n# An input for mutations affecting `Role`\ninput RoleInput {\n  id: Int\n  authority: String!\n}\n\n# Represents an update to a `Role`. Fields that are set will be updated.\ninput RolePatch {\n  id: Int\n  authority: String\n}\n\n# A connection to a list of `Role` values.\ntype RolesConnection {\n  # A list of `Role` objects.\n  nodes: [Role]!\n\n  # A list of edges which contains the `Role` and cursor to aid in pagination.\n  edges: [RolesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Role` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Role` edge in the connection.\ntype RolesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Role` at the end of the edge.\n  node: Role\n}\n\n# Methods to use when ordering `Role`.\nenum RolesOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  AUTHORITY_ASC\n  AUTHORITY_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  USER_ROLES_BY_ROLE_ID__COUNT_ASC\n  USER_ROLES_BY_ROLE_ID__COUNT_DESC\n}\n\ntype Room implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  description: String!\n  size: Int!\n  type: String!\n  updated: Boolean!\n\n  # Reads and enables pagination through a set of `Game`.\n  games(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameFilter\n  ): GamesConnection!\n}\n\n# A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput RoomCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `description` field.\n  description: String\n\n  # Checks for equality with the object’s `size` field.\n  size: Int\n\n  # Checks for equality with the object’s `type` field.\n  type: String\n\n  # Checks for equality with the object’s `updated` field.\n  updated: Boolean\n}\n\n# A filter to be used against `Room` object types. All fields are combined with a logical ‘and.’\ninput RoomFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `description` field.\n  description: StringFilter\n\n  # Filter by the object’s `size` field.\n  size: IntFilter\n\n  # Filter by the object’s `type` field.\n  type: StringFilter\n\n  # Filter by the object’s `updated` field.\n  updated: BooleanFilter\n\n  # Checks for all expressions in this list.\n  and: [RoomFilter!]\n\n  # Checks for any expressions in this list.\n  or: [RoomFilter!]\n\n  # Negates the expression.\n  not: RoomFilter\n}\n\n# An input for mutations affecting `Room`\ninput RoomInput {\n  id: Int\n  description: String!\n  size: Int!\n  type: String!\n  updated: Boolean!\n}\n\n# Represents an update to a `Room`. Fields that are set will be updated.\ninput RoomPatch {\n  id: Int\n  description: String\n  size: Int\n  type: String\n  updated: Boolean\n}\n\n# A connection to a list of `Room` values.\ntype RoomsConnection {\n  # A list of `Room` objects.\n  nodes: [Room]!\n\n  # A list of edges which contains the `Room` and cursor to aid in pagination.\n  edges: [RoomsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Room` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Room` edge in the connection.\ntype RoomsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Room` at the end of the edge.\n  node: Room\n}\n\n# Methods to use when ordering `Room`.\nenum RoomsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  DESCRIPTION_ASC\n  DESCRIPTION_DESC\n  SIZE_ASC\n  SIZE_DESC\n  TYPE_ASC\n  TYPE_DESC\n  UPDATED_ASC\n  UPDATED_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  GAMES_BY_ROOM_ID__COUNT_ASC\n  GAMES_BY_ROOM_ID__COUNT_DESC\n}\n\ntype Setting implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  code: String!\n  type: String!\n  value: String!\n}\n\n# A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput SettingCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `code` field.\n  code: String\n\n  # Checks for equality with the object’s `type` field.\n  type: String\n\n  # Checks for equality with the object’s `value` field.\n  value: String\n}\n\n# A filter to be used against `Setting` object types. All fields are combined with a logical ‘and.’\ninput SettingFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `code` field.\n  code: StringFilter\n\n  # Filter by the object’s `type` field.\n  type: StringFilter\n\n  # Filter by the object’s `value` field.\n  value: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [SettingFilter!]\n\n  # Checks for any expressions in this list.\n  or: [SettingFilter!]\n\n  # Negates the expression.\n  not: SettingFilter\n}\n\n# An input for mutations affecting `Setting`\ninput SettingInput {\n  id: Int\n  code: String!\n  type: String!\n  value: String!\n}\n\n# Represents an update to a `Setting`. Fields that are set will be updated.\ninput SettingPatch {\n  id: Int\n  code: String\n  type: String\n  value: String\n}\n\n# A connection to a list of `Setting` values.\ntype SettingsConnection {\n  # A list of `Setting` objects.\n  nodes: [Setting]!\n\n  # A list of edges which contains the `Setting` and cursor to aid in pagination.\n  edges: [SettingsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Setting` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Setting` edge in the connection.\ntype SettingsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Setting` at the end of the edge.\n  node: Setting\n}\n\n# Methods to use when ordering `Setting`.\nenum SettingsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  CODE_ASC\n  CODE_DESC\n  TYPE_ASC\n  TYPE_DESC\n  VALUE_ASC\n  VALUE_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n}\n\ntype ShirtOrder implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  deliveryMethod: String!\n  message: String!\n  userId: Int!\n  year: Int!\n\n  # Reads a single `User` that is related to this `ShirtOrder`.\n  user: User\n\n  # Reads and enables pagination through a set of `ShirtOrderItem`.\n  shirtOrderItemsByOrderId(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `ShirtOrderItem`.\n    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: ShirtOrderItemCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: ShirtOrderItemFilter\n  ): ShirtOrderItemsConnection!\n}\n\n# A condition to be used against `ShirtOrder` object types. All fields are tested\n# for equality and combined with a logical ‘and.’\ninput ShirtOrderCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `deliveryMethod` field.\n  deliveryMethod: String\n\n  # Checks for equality with the object’s `message` field.\n  message: String\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `year` field.\n  year: Int\n}\n\n# A filter to be used against `ShirtOrder` object types. All fields are combined with a logical ‘and.’\ninput ShirtOrderFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `deliveryMethod` field.\n  deliveryMethod: StringFilter\n\n  # Filter by the object’s `message` field.\n  message: StringFilter\n\n  # Filter by the object’s `userId` field.\n  userId: IntFilter\n\n  # Filter by the object’s `year` field.\n  year: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [ShirtOrderFilter!]\n\n  # Checks for any expressions in this list.\n  or: [ShirtOrderFilter!]\n\n  # Negates the expression.\n  not: ShirtOrderFilter\n}\n\n# An input for mutations affecting `ShirtOrder`\ninput ShirtOrderInput {\n  id: Int\n  deliveryMethod: String!\n  message: String!\n  userId: Int!\n  year: Int!\n}\n\ntype ShirtOrderItem implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  orderId: Int!\n  quantity: Int!\n  size: String!\n  style: String!\n  itemsIdx: Int\n\n  # Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`.\n  order: ShirtOrder\n}\n\n# A condition to be used against `ShirtOrderItem` object types. All fields are\n# tested for equality and combined with a logical ‘and.’\ninput ShirtOrderItemCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `orderId` field.\n  orderId: Int\n\n  # Checks for equality with the object’s `quantity` field.\n  quantity: Int\n\n  # Checks for equality with the object’s `size` field.\n  size: String\n\n  # Checks for equality with the object’s `style` field.\n  style: String\n\n  # Checks for equality with the object’s `itemsIdx` field.\n  itemsIdx: Int\n}\n\n# A filter to be used against `ShirtOrderItem` object types. All fields are combined with a logical ‘and.’\ninput ShirtOrderItemFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `orderId` field.\n  orderId: IntFilter\n\n  # Filter by the object’s `quantity` field.\n  quantity: IntFilter\n\n  # Filter by the object’s `size` field.\n  size: StringFilter\n\n  # Filter by the object’s `style` field.\n  style: StringFilter\n\n  # Filter by the object’s `itemsIdx` field.\n  itemsIdx: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [ShirtOrderItemFilter!]\n\n  # Checks for any expressions in this list.\n  or: [ShirtOrderItemFilter!]\n\n  # Negates the expression.\n  not: ShirtOrderItemFilter\n}\n\n# An input for mutations affecting `ShirtOrderItem`\ninput ShirtOrderItemInput {\n  id: Int\n  orderId: Int!\n  quantity: Int!\n  size: String!\n  style: String!\n  itemsIdx: Int\n}\n\n# Represents an update to a `ShirtOrderItem`. Fields that are set will be updated.\ninput ShirtOrderItemPatch {\n  id: Int\n  orderId: Int\n  quantity: Int\n  size: String\n  style: String\n  itemsIdx: Int\n}\n\n# A connection to a list of `ShirtOrderItem` values.\ntype ShirtOrderItemsConnection {\n  # A list of `ShirtOrderItem` objects.\n  nodes: [ShirtOrderItem]!\n\n  # A list of edges which contains the `ShirtOrderItem` and cursor to aid in pagination.\n  edges: [ShirtOrderItemsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `ShirtOrderItem` you could get from the connection.\n  totalCount: Int\n}\n\n# A `ShirtOrderItem` edge in the connection.\ntype ShirtOrderItemsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `ShirtOrderItem` at the end of the edge.\n  node: ShirtOrderItem\n}\n\n# Methods to use when ordering `ShirtOrderItem`.\nenum ShirtOrderItemsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  ORDER_ID_ASC\n  ORDER_ID_DESC\n  QUANTITY_ASC\n  QUANTITY_DESC\n  SIZE_ASC\n  SIZE_DESC\n  STYLE_ASC\n  STYLE_DESC\n  ITEMS_IDX_ASC\n  ITEMS_IDX_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  SHIRT_ORDER_BY_ORDER_ID__ID_ASC\n  SHIRT_ORDER_BY_ORDER_ID__ID_DESC\n  SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_ASC\n  SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_DESC\n  SHIRT_ORDER_BY_ORDER_ID__MESSAGE_ASC\n  SHIRT_ORDER_BY_ORDER_ID__MESSAGE_DESC\n  SHIRT_ORDER_BY_ORDER_ID__USER_ID_ASC\n  SHIRT_ORDER_BY_ORDER_ID__USER_ID_DESC\n  SHIRT_ORDER_BY_ORDER_ID__YEAR_ASC\n  SHIRT_ORDER_BY_ORDER_ID__YEAR_DESC\n}\n\n# Represents an update to a `ShirtOrder`. Fields that are set will be updated.\ninput ShirtOrderPatch {\n  id: Int\n  deliveryMethod: String\n  message: String\n  userId: Int\n  year: Int\n}\n\n# A connection to a list of `ShirtOrder` values.\ntype ShirtOrdersConnection {\n  # A list of `ShirtOrder` objects.\n  nodes: [ShirtOrder]!\n\n  # A list of edges which contains the `ShirtOrder` and cursor to aid in pagination.\n  edges: [ShirtOrdersEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `ShirtOrder` you could get from the connection.\n  totalCount: Int\n}\n\n# A `ShirtOrder` edge in the connection.\ntype ShirtOrdersEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `ShirtOrder` at the end of the edge.\n  node: ShirtOrder\n}\n\n# Methods to use when ordering `ShirtOrder`.\nenum ShirtOrdersOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  DELIVERY_METHOD_ASC\n  DELIVERY_METHOD_DESC\n  MESSAGE_ASC\n  MESSAGE_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  YEAR_ASC\n  YEAR_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  USER_BY_USER_ID__ID_ASC\n  USER_BY_USER_ID__ID_DESC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC\n  USER_BY_USER_ID__ENABLED_ASC\n  USER_BY_USER_ID__ENABLED_DESC\n  USER_BY_USER_ID__PASSWORD_ASC\n  USER_BY_USER_ID__PASSWORD_DESC\n  USER_BY_USER_ID__PROFILE_ID_ASC\n  USER_BY_USER_ID__PROFILE_ID_DESC\n  USER_BY_USER_ID__USERNAME_ASC\n  USER_BY_USER_ID__USERNAME_DESC\n  SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_ASC\n  SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_DESC\n}\n\ntype Slot implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  slot: Int!\n  day: String!\n  formattedDate: String!\n  length: String!\n  time: String!\n\n  # Reads and enables pagination through a set of `Game`.\n  games(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameFilter\n  ): GamesConnection!\n\n  # Reads and enables pagination through a set of `GameChoice`.\n  gameChoices(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameChoiceCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameChoiceFilter\n  ): GameChoicesConnection!\n}\n\n# A condition to be used against `Slot` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput SlotCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `slot` field.\n  slot: Int\n\n  # Checks for equality with the object’s `day` field.\n  day: String\n\n  # Checks for equality with the object’s `formattedDate` field.\n  formattedDate: String\n\n  # Checks for equality with the object’s `length` field.\n  length: String\n\n  # Checks for equality with the object’s `time` field.\n  time: String\n}\n\n# A filter to be used against `Slot` object types. All fields are combined with a logical ‘and.’\ninput SlotFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `slot` field.\n  slot: IntFilter\n\n  # Filter by the object’s `day` field.\n  day: StringFilter\n\n  # Filter by the object’s `formattedDate` field.\n  formattedDate: StringFilter\n\n  # Filter by the object’s `length` field.\n  length: StringFilter\n\n  # Filter by the object’s `time` field.\n  time: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [SlotFilter!]\n\n  # Checks for any expressions in this list.\n  or: [SlotFilter!]\n\n  # Negates the expression.\n  not: SlotFilter\n}\n\n# An input for mutations affecting `Slot`\ninput SlotInput {\n  id: Int\n  slot: Int!\n  day: String!\n  formattedDate: String!\n  length: String!\n  time: String!\n}\n\n# Represents an update to a `Slot`. Fields that are set will be updated.\ninput SlotPatch {\n  id: Int\n  slot: Int\n  day: String\n  formattedDate: String\n  length: String\n  time: String\n}\n\n# A connection to a list of `Slot` values.\ntype SlotsConnection {\n  # A list of `Slot` objects.\n  nodes: [Slot]!\n\n  # A list of edges which contains the `Slot` and cursor to aid in pagination.\n  edges: [SlotsEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Slot` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Slot` edge in the connection.\ntype SlotsEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Slot` at the end of the edge.\n  node: Slot\n}\n\n# Methods to use when ordering `Slot`.\nenum SlotsOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  SLOT_ASC\n  SLOT_DESC\n  DAY_ASC\n  DAY_DESC\n  FORMATTED_DATE_ASC\n  FORMATTED_DATE_DESC\n  LENGTH_ASC\n  LENGTH_DESC\n  TIME_ASC\n  TIME_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  GAMES_BY_SLOT_ID__COUNT_ASC\n  GAMES_BY_SLOT_ID__COUNT_DESC\n  GAME_CHOICES_BY_SLOT_ID__COUNT_ASC\n  GAME_CHOICES_BY_SLOT_ID__COUNT_DESC\n}\n\n# A filter to be used against String fields. All fields are combined with a logical ‘and.’\ninput StringFilter {\n  # Is null (if `true` is specified) or is not null (if `false` is specified).\n  isNull: Boolean\n\n  # Equal to the specified value.\n  equalTo: String\n\n  # Not equal to the specified value.\n  notEqualTo: String\n\n  # Not equal to the specified value, treating null like an ordinary value.\n  distinctFrom: String\n\n  # Equal to the specified value, treating null like an ordinary value.\n  notDistinctFrom: String\n\n  # Included in the specified list.\n  in: [String!]\n\n  # Not included in the specified list.\n  notIn: [String!]\n\n  # Less than the specified value.\n  lessThan: String\n\n  # Less than or equal to the specified value.\n  lessThanOrEqualTo: String\n\n  # Greater than the specified value.\n  greaterThan: String\n\n  # Greater than or equal to the specified value.\n  greaterThanOrEqualTo: String\n\n  # Contains the specified string (case-sensitive).\n  includes: String\n\n  # Does not contain the specified string (case-sensitive).\n  notIncludes: String\n\n  # Contains the specified string (case-insensitive).\n  includesInsensitive: String\n\n  # Does not contain the specified string (case-insensitive).\n  notIncludesInsensitive: String\n\n  # Starts with the specified string (case-sensitive).\n  startsWith: String\n\n  # Does not start with the specified string (case-sensitive).\n  notStartsWith: String\n\n  # Starts with the specified string (case-insensitive).\n  startsWithInsensitive: String\n\n  # Does not start with the specified string (case-insensitive).\n  notStartsWithInsensitive: String\n\n  # Ends with the specified string (case-sensitive).\n  endsWith: String\n\n  # Does not end with the specified string (case-sensitive).\n  notEndsWith: String\n\n  # Ends with the specified string (case-insensitive).\n  endsWithInsensitive: String\n\n  # Does not end with the specified string (case-insensitive).\n  notEndsWithInsensitive: String\n\n  # Matches the specified pattern (case-sensitive). An underscore (_) matches any\n  # single character; a percent sign (%) matches any sequence of zero or more characters.\n  like: String\n\n  # Does not match the specified pattern (case-sensitive). An underscore (_)\n  # matches any single character; a percent sign (%) matches any sequence of zero\n  # or more characters.\n  notLike: String\n\n  # Matches the specified pattern (case-insensitive). An underscore (_) matches\n  # any single character; a percent sign (%) matches any sequence of zero or more characters.\n  likeInsensitive: String\n\n  # Does not match the specified pattern (case-insensitive). An underscore (_)\n  # matches any single character; a percent sign (%) matches any sequence of zero\n  # or more characters.\n  notLikeInsensitive: String\n\n  # Matches the specified pattern using the SQL standard's definition of a regular expression.\n  similarTo: String\n\n  # Does not match the specified pattern using the SQL standard's definition of a regular expression.\n  notSimilarTo: String\n}\n\ntype Token implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  userId: Int!\n  cuid: String\n  active: Boolean\n  lastUsed: Datetime\n\n  # Reads a single `User` that is related to this `Token`.\n  user: User\n}\n\n# A condition to be used against `Token` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput TokenCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n\n  # Checks for equality with the object’s `cuid` field.\n  cuid: String\n\n  # Checks for equality with the object’s `active` field.\n  active: Boolean\n\n  # Checks for equality with the object’s `lastUsed` field.\n  lastUsed: Datetime\n}\n\n# A filter to be used against `Token` object types. All fields are combined with a logical ‘and.’\ninput TokenFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `userId` field.\n  userId: IntFilter\n\n  # Filter by the object’s `cuid` field.\n  cuid: StringFilter\n\n  # Filter by the object’s `active` field.\n  active: BooleanFilter\n\n  # Filter by the object’s `lastUsed` field.\n  lastUsed: DatetimeFilter\n\n  # Checks for all expressions in this list.\n  and: [TokenFilter!]\n\n  # Checks for any expressions in this list.\n  or: [TokenFilter!]\n\n  # Negates the expression.\n  not: TokenFilter\n}\n\n# An input for mutations affecting `Token`\ninput TokenInput {\n  id: Int\n  userId: Int!\n  cuid: String\n  active: Boolean\n  lastUsed: Datetime\n}\n\n# Represents an update to a `Token`. Fields that are set will be updated.\ninput TokenPatch {\n  id: Int\n  userId: Int\n  cuid: String\n  active: Boolean\n  lastUsed: Datetime\n}\n\n# A connection to a list of `Token` values.\ntype TokensConnection {\n  # A list of `Token` objects.\n  nodes: [Token]!\n\n  # A list of edges which contains the `Token` and cursor to aid in pagination.\n  edges: [TokensEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `Token` you could get from the connection.\n  totalCount: Int\n}\n\n# A `Token` edge in the connection.\ntype TokensEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `Token` at the end of the edge.\n  node: Token\n}\n\n# Methods to use when ordering `Token`.\nenum TokensOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  CUID_ASC\n  CUID_DESC\n  ACTIVE_ASC\n  ACTIVE_DESC\n  LAST_USED_ASC\n  LAST_USED_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  USER_BY_USER_ID__ID_ASC\n  USER_BY_USER_ID__ID_DESC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC\n  USER_BY_USER_ID__ENABLED_ASC\n  USER_BY_USER_ID__ENABLED_DESC\n  USER_BY_USER_ID__PASSWORD_ASC\n  USER_BY_USER_ID__PASSWORD_DESC\n  USER_BY_USER_ID__PROFILE_ID_ASC\n  USER_BY_USER_ID__PROFILE_ID_DESC\n  USER_BY_USER_ID__USERNAME_ASC\n  USER_BY_USER_ID__USERNAME_DESC\n}\n\n# All input for the `updateGameAssignmentByNodeId` mutation.\ninput UpdateGameAssignmentByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `GameAssignment` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `GameAssignment` being updated.\n  patch: GameAssignmentPatch!\n}\n\n# All input for the `updateGameAssignment` mutation.\ninput UpdateGameAssignmentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `GameAssignment` being updated.\n  patch: GameAssignmentPatch!\n  memberId: Int!\n  gameId: Int!\n  gm: Int!\n}\n\n# The output of our update `GameAssignment` mutation.\ntype UpdateGameAssignmentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameAssignment` that was updated by this mutation.\n  gameAssignment: GameAssignment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `GameAssignment`.\n  member: Membership\n\n  # Reads a single `Game` that is related to this `GameAssignment`.\n  game: Game\n\n  # An edge for our `GameAssignment`. May be used by Relay 1.\n  gameAssignmentEdge(\n    # The method to use when ordering `GameAssignment`.\n    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameAssignmentsEdge\n}\n\n# All input for the `updateGameByNodeId` mutation.\ninput UpdateGameByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Game` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Game` being updated.\n  patch: GamePatch!\n}\n\n# All input for the `updateGameChoiceByNodeId` mutation.\ninput UpdateGameChoiceByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `GameChoice` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `GameChoice` being updated.\n  patch: GameChoicePatch!\n}\n\n# All input for the `updateGameChoice` mutation.\ninput UpdateGameChoiceInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `GameChoice` being updated.\n  patch: GameChoicePatch!\n  id: Int!\n}\n\n# The output of our update `GameChoice` mutation.\ntype UpdateGameChoicePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameChoice` that was updated by this mutation.\n  gameChoice: GameChoice\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Game` that is related to this `GameChoice`.\n  game: Game\n\n  # Reads a single `Membership` that is related to this `GameChoice`.\n  member: Membership\n\n  # Reads a single `Slot` that is related to this `GameChoice`.\n  slot: Slot\n\n  # An edge for our `GameChoice`. May be used by Relay 1.\n  gameChoiceEdge(\n    # The method to use when ordering `GameChoice`.\n    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameChoicesEdge\n}\n\n# All input for the `updateGame` mutation.\ninput UpdateGameInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Game` being updated.\n  patch: GamePatch!\n  id: Int!\n}\n\n# The output of our update `Game` mutation.\ntype UpdateGamePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Game` that was updated by this mutation.\n  game: Game\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Room` that is related to this `Game`.\n  room: Room\n\n  # Reads a single `Slot` that is related to this `Game`.\n  slot: Slot\n\n  # Reads a single `User` that is related to this `Game`.\n  author: User\n\n  # An edge for our `Game`. May be used by Relay 1.\n  gameEdge(\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GamesEdge\n}\n\n# All input for the `updateGameSubmissionByNodeId` mutation.\ninput UpdateGameSubmissionByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `GameSubmission` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `GameSubmission` being updated.\n  patch: GameSubmissionPatch!\n}\n\n# All input for the `updateGameSubmission` mutation.\ninput UpdateGameSubmissionInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `GameSubmission` being updated.\n  patch: GameSubmissionPatch!\n  id: Int!\n}\n\n# The output of our update `GameSubmission` mutation.\ntype UpdateGameSubmissionPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `GameSubmission` that was updated by this mutation.\n  gameSubmission: GameSubmission\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `GameSubmission`.\n  member: Membership\n\n  # An edge for our `GameSubmission`. May be used by Relay 1.\n  gameSubmissionEdge(\n    # The method to use when ordering `GameSubmission`.\n    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): GameSubmissionsEdge\n}\n\n# All input for the `updateHotelRoomByNodeId` mutation.\ninput UpdateHotelRoomByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `HotelRoom` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `HotelRoom` being updated.\n  patch: HotelRoomPatch!\n}\n\n# All input for the `updateHotelRoomDetailByNodeId` mutation.\ninput UpdateHotelRoomDetailByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `HotelRoomDetail` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `HotelRoomDetail` being updated.\n  patch: HotelRoomDetailPatch!\n}\n\n# All input for the `updateHotelRoomDetail` mutation.\ninput UpdateHotelRoomDetailInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `HotelRoomDetail` being updated.\n  patch: HotelRoomDetailPatch!\n  id: BigInt!\n}\n\n# The output of our update `HotelRoomDetail` mutation.\ntype UpdateHotelRoomDetailPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `HotelRoomDetail` that was updated by this mutation.\n  hotelRoomDetail: HotelRoomDetail\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `HotelRoomDetail`. May be used by Relay 1.\n  hotelRoomDetailEdge(\n    # The method to use when ordering `HotelRoomDetail`.\n    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): HotelRoomDetailsEdge\n}\n\n# All input for the `updateHotelRoom` mutation.\ninput UpdateHotelRoomInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `HotelRoom` being updated.\n  patch: HotelRoomPatch!\n  id: Int!\n}\n\n# The output of our update `HotelRoom` mutation.\ntype UpdateHotelRoomPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `HotelRoom` that was updated by this mutation.\n  hotelRoom: HotelRoom\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `HotelRoom`. May be used by Relay 1.\n  hotelRoomEdge(\n    # The method to use when ordering `HotelRoom`.\n    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): HotelRoomsEdge\n}\n\n# All input for the `updateLookupByNodeId` mutation.\ninput UpdateLookupByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Lookup` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Lookup` being updated.\n  patch: LookupPatch!\n}\n\n# All input for the `updateLookupByRealm` mutation.\ninput UpdateLookupByRealmInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Lookup` being updated.\n  patch: LookupPatch!\n  realm: String!\n}\n\n# All input for the `updateLookup` mutation.\ninput UpdateLookupInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Lookup` being updated.\n  patch: LookupPatch!\n  id: Int!\n}\n\n# The output of our update `Lookup` mutation.\ntype UpdateLookupPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Lookup` that was updated by this mutation.\n  lookup: Lookup\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Lookup`. May be used by Relay 1.\n  lookupEdge(\n    # The method to use when ordering `Lookup`.\n    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): LookupsEdge\n}\n\n# All input for the `updateLookupValueByLookupIdAndCode` mutation.\ninput UpdateLookupValueByLookupIdAndCodeInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `LookupValue` being updated.\n  patch: LookupValuePatch!\n  lookupId: Int!\n  code: String!\n}\n\n# All input for the `updateLookupValueByNodeId` mutation.\ninput UpdateLookupValueByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `LookupValue` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `LookupValue` being updated.\n  patch: LookupValuePatch!\n}\n\n# All input for the `updateLookupValue` mutation.\ninput UpdateLookupValueInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `LookupValue` being updated.\n  patch: LookupValuePatch!\n  id: Int!\n}\n\n# The output of our update `LookupValue` mutation.\ntype UpdateLookupValuePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `LookupValue` that was updated by this mutation.\n  lookupValue: LookupValue\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Lookup` that is related to this `LookupValue`.\n  lookup: Lookup\n\n  # An edge for our `LookupValue`. May be used by Relay 1.\n  lookupValueEdge(\n    # The method to use when ordering `LookupValue`.\n    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): LookupValuesEdge\n}\n\n# All input for the `updateMemberHotelRoomAssignmentByNodeId` mutation.\ninput UpdateMemberHotelRoomAssignmentByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `MemberHotelRoomAssignment` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `MemberHotelRoomAssignment` being updated.\n  patch: MemberHotelRoomAssignmentPatch!\n}\n\n# All input for the `updateMemberHotelRoomAssignment` mutation.\ninput UpdateMemberHotelRoomAssignmentInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `MemberHotelRoomAssignment` being updated.\n  patch: MemberHotelRoomAssignmentPatch!\n  memberId: BigInt!\n  hotelRoomId: BigInt!\n}\n\n# The output of our update `MemberHotelRoomAssignment` mutation.\ntype UpdateMemberHotelRoomAssignmentPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `MemberHotelRoomAssignment` that was updated by this mutation.\n  memberHotelRoomAssignment: MemberHotelRoomAssignment\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`.\n  member: Membership\n\n  # Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`.\n  hotelRoom: HotelRoomDetail\n\n  # An edge for our `MemberHotelRoomAssignment`. May be used by Relay 1.\n  memberHotelRoomAssignmentEdge(\n    # The method to use when ordering `MemberHotelRoomAssignment`.\n    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): MemberHotelRoomAssignmentsEdge\n}\n\n# All input for the `updateMembershipByNodeId` mutation.\ninput UpdateMembershipByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Membership` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Membership` being updated.\n  patch: MembershipPatch!\n}\n\n# All input for the `updateMembership` mutation.\ninput UpdateMembershipInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Membership` being updated.\n  patch: MembershipPatch!\n  id: Int!\n}\n\n# The output of our update `Membership` mutation.\ntype UpdateMembershipPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Membership` that was updated by this mutation.\n  membership: Membership\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `HotelRoom` that is related to this `Membership`.\n  hotelRoom: HotelRoom\n\n  # Reads a single `User` that is related to this `Membership`.\n  user: User\n\n  # An edge for our `Membership`. May be used by Relay 1.\n  membershipEdge(\n    # The method to use when ordering `Membership`.\n    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): MembershipsEdge\n}\n\n# All input for the `updateProfileByEmail` mutation.\ninput UpdateProfileByEmailInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Profile` being updated.\n  patch: ProfilePatch!\n  email: String!\n}\n\n# All input for the `updateProfileByNodeId` mutation.\ninput UpdateProfileByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Profile` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Profile` being updated.\n  patch: ProfilePatch!\n}\n\n# All input for the `updateProfile` mutation.\ninput UpdateProfileInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Profile` being updated.\n  patch: ProfilePatch!\n  id: Int!\n}\n\n# The output of our update `Profile` mutation.\ntype UpdateProfilePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Profile` that was updated by this mutation.\n  profile: Profile\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Profile`. May be used by Relay 1.\n  profileEdge(\n    # The method to use when ordering `Profile`.\n    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ProfilesEdge\n}\n\n# All input for the `updateRegistrationCodeByNodeId` mutation.\ninput UpdateRegistrationCodeByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `RegistrationCode` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `RegistrationCode` being updated.\n  patch: RegistrationCodePatch!\n}\n\n# All input for the `updateRegistrationCode` mutation.\ninput UpdateRegistrationCodeInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `RegistrationCode` being updated.\n  patch: RegistrationCodePatch!\n  id: Int!\n}\n\n# The output of our update `RegistrationCode` mutation.\ntype UpdateRegistrationCodePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `RegistrationCode` that was updated by this mutation.\n  registrationCode: RegistrationCode\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `RegistrationCode`. May be used by Relay 1.\n  registrationCodeEdge(\n    # The method to use when ordering `RegistrationCode`.\n    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RegistrationCodesEdge\n}\n\n# All input for the `updateRoleByAuthority` mutation.\ninput UpdateRoleByAuthorityInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Role` being updated.\n  patch: RolePatch!\n  authority: String!\n}\n\n# All input for the `updateRoleByNodeId` mutation.\ninput UpdateRoleByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Role` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Role` being updated.\n  patch: RolePatch!\n}\n\n# All input for the `updateRole` mutation.\ninput UpdateRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Role` being updated.\n  patch: RolePatch!\n  id: Int!\n}\n\n# The output of our update `Role` mutation.\ntype UpdateRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Role` that was updated by this mutation.\n  role: Role\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Role`. May be used by Relay 1.\n  roleEdge(\n    # The method to use when ordering `Role`.\n    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RolesEdge\n}\n\n# All input for the `updateRoomByNodeId` mutation.\ninput UpdateRoomByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Room` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Room` being updated.\n  patch: RoomPatch!\n}\n\n# All input for the `updateRoom` mutation.\ninput UpdateRoomInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Room` being updated.\n  patch: RoomPatch!\n  id: Int!\n}\n\n# The output of our update `Room` mutation.\ntype UpdateRoomPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Room` that was updated by this mutation.\n  room: Room\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Room`. May be used by Relay 1.\n  roomEdge(\n    # The method to use when ordering `Room`.\n    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): RoomsEdge\n}\n\n# All input for the `updateSettingByNodeId` mutation.\ninput UpdateSettingByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Setting` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Setting` being updated.\n  patch: SettingPatch!\n}\n\n# All input for the `updateSetting` mutation.\ninput UpdateSettingInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Setting` being updated.\n  patch: SettingPatch!\n  id: Int!\n}\n\n# The output of our update `Setting` mutation.\ntype UpdateSettingPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Setting` that was updated by this mutation.\n  setting: Setting\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Setting`. May be used by Relay 1.\n  settingEdge(\n    # The method to use when ordering `Setting`.\n    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): SettingsEdge\n}\n\n# All input for the `updateShirtOrderByNodeId` mutation.\ninput UpdateShirtOrderByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `ShirtOrder` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `ShirtOrder` being updated.\n  patch: ShirtOrderPatch!\n}\n\n# All input for the `updateShirtOrder` mutation.\ninput UpdateShirtOrderInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `ShirtOrder` being updated.\n  patch: ShirtOrderPatch!\n  id: Int!\n}\n\n# All input for the `updateShirtOrderItemByNodeId` mutation.\ninput UpdateShirtOrderItemByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `ShirtOrderItem` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `ShirtOrderItem` being updated.\n  patch: ShirtOrderItemPatch!\n}\n\n# All input for the `updateShirtOrderItem` mutation.\ninput UpdateShirtOrderItemInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `ShirtOrderItem` being updated.\n  patch: ShirtOrderItemPatch!\n  id: Int!\n}\n\n# The output of our update `ShirtOrderItem` mutation.\ntype UpdateShirtOrderItemPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `ShirtOrderItem` that was updated by this mutation.\n  shirtOrderItem: ShirtOrderItem\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`.\n  order: ShirtOrder\n\n  # An edge for our `ShirtOrderItem`. May be used by Relay 1.\n  shirtOrderItemEdge(\n    # The method to use when ordering `ShirtOrderItem`.\n    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ShirtOrderItemsEdge\n}\n\n# The output of our update `ShirtOrder` mutation.\ntype UpdateShirtOrderPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `ShirtOrder` that was updated by this mutation.\n  shirtOrder: ShirtOrder\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `User` that is related to this `ShirtOrder`.\n  user: User\n\n  # An edge for our `ShirtOrder`. May be used by Relay 1.\n  shirtOrderEdge(\n    # The method to use when ordering `ShirtOrder`.\n    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]\n  ): ShirtOrdersEdge\n}\n\n# All input for the `updateSlotByNodeId` mutation.\ninput UpdateSlotByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Slot` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Slot` being updated.\n  patch: SlotPatch!\n}\n\n# All input for the `updateSlot` mutation.\ninput UpdateSlotInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Slot` being updated.\n  patch: SlotPatch!\n  id: Int!\n}\n\n# The output of our update `Slot` mutation.\ntype UpdateSlotPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Slot` that was updated by this mutation.\n  slot: Slot\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # An edge for our `Slot`. May be used by Relay 1.\n  slotEdge(\n    # The method to use when ordering `Slot`.\n    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]\n  ): SlotsEdge\n}\n\n# All input for the `updateTokenByNodeId` mutation.\ninput UpdateTokenByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `Token` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `Token` being updated.\n  patch: TokenPatch!\n}\n\n# All input for the `updateToken` mutation.\ninput UpdateTokenInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `Token` being updated.\n  patch: TokenPatch!\n  id: Int!\n}\n\n# The output of our update `Token` mutation.\ntype UpdateTokenPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `Token` that was updated by this mutation.\n  token: Token\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `User` that is related to this `Token`.\n  user: User\n\n  # An edge for our `Token`. May be used by Relay 1.\n  tokenEdge(\n    # The method to use when ordering `Token`.\n    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]\n  ): TokensEdge\n}\n\n# All input for the `updateUserByNodeId` mutation.\ninput UpdateUserByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `User` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `User` being updated.\n  patch: UserPatch!\n}\n\n# All input for the `updateUserByUsername` mutation.\ninput UpdateUserByUsernameInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `User` being updated.\n  patch: UserPatch!\n  username: String!\n}\n\n# All input for the `updateUser` mutation.\ninput UpdateUserInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `User` being updated.\n  patch: UserPatch!\n  id: Int!\n}\n\n# The output of our update `User` mutation.\ntype UpdateUserPayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `User` that was updated by this mutation.\n  user: User\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Profile` that is related to this `User`.\n  profile: Profile\n\n  # An edge for our `User`. May be used by Relay 1.\n  userEdge(\n    # The method to use when ordering `User`.\n    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]\n  ): UsersEdge\n}\n\n# All input for the `updateUserRoleByNodeId` mutation.\ninput UpdateUserRoleByNodeIdInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # The globally unique `ID` which will identify a single `UserRole` to be updated.\n  nodeId: ID!\n\n  # An object where the defined keys will be set on the `UserRole` being updated.\n  patch: UserRolePatch!\n}\n\n# All input for the `updateUserRole` mutation.\ninput UpdateUserRoleInput {\n  # An arbitrary string value with no semantic meaning. Will be included in the\n  # payload verbatim. May be used to track mutations by the client.\n  clientMutationId: String\n\n  # An object where the defined keys will be set on the `UserRole` being updated.\n  patch: UserRolePatch!\n  roleId: Int!\n  userId: Int!\n}\n\n# The output of our update `UserRole` mutation.\ntype UpdateUserRolePayload {\n  # The exact same `clientMutationId` that was provided in the mutation input,\n  # unchanged and unused. May be used by a client to track mutations.\n  clientMutationId: String\n\n  # The `UserRole` that was updated by this mutation.\n  userRole: UserRole\n\n  # Our root query field type. Allows us to run any query from our mutation payload.\n  query: Query\n\n  # Reads a single `Role` that is related to this `UserRole`.\n  role: Role\n\n  # Reads a single `User` that is related to this `UserRole`.\n  user: User\n\n  # An edge for our `UserRole`. May be used by Relay 1.\n  userRoleEdge(\n    # The method to use when ordering `UserRole`.\n    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]\n  ): UserRolesEdge\n}\n\ntype User implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  id: Int!\n  accountLocked: Boolean!\n  enabled: Boolean!\n  password: String!\n  profileId: Int!\n  username: String!\n\n  # Reads a single `Profile` that is related to this `User`.\n  profile: Profile\n\n  # Reads and enables pagination through a set of `Game`.\n  authoredGames(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Game`.\n    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: GameCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: GameFilter\n  ): GamesConnection!\n\n  # Reads and enables pagination through a set of `Membership`.\n  memberships(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Membership`.\n    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: MembershipCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: MembershipFilter\n  ): MembershipsConnection!\n\n  # Reads and enables pagination through a set of `ShirtOrder`.\n  shirtOrders(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `ShirtOrder`.\n    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: ShirtOrderCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: ShirtOrderFilter\n  ): ShirtOrdersConnection!\n\n  # Reads and enables pagination through a set of `UserRole`.\n  userRoles(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `UserRole`.\n    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: UserRoleCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: UserRoleFilter\n  ): UserRolesConnection!\n\n  # Reads and enables pagination through a set of `Token`.\n  tokens(\n    # Only read the first `n` values of the set.\n    first: Int\n\n    # Only read the last `n` values of the set.\n    last: Int\n\n    # Skip the first `n` values from our `after` cursor, an alternative to cursor\n    # based pagination. May not be used with `last`.\n    offset: Int\n\n    # Read all values in the set before (above) this cursor.\n    before: Cursor\n\n    # Read all values in the set after (below) this cursor.\n    after: Cursor\n\n    # The method to use when ordering `Token`.\n    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]\n\n    # A condition to be used in determining which values should be returned by the collection.\n    condition: TokenCondition\n\n    # A filter to be used in determining which values should be returned by the collection.\n    filter: TokenFilter\n  ): TokensConnection!\n}\n\n# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’\ninput UserCondition {\n  # Checks for equality with the object’s `id` field.\n  id: Int\n\n  # Checks for equality with the object’s `accountLocked` field.\n  accountLocked: Boolean\n\n  # Checks for equality with the object’s `enabled` field.\n  enabled: Boolean\n\n  # Checks for equality with the object’s `password` field.\n  password: String\n\n  # Checks for equality with the object’s `profileId` field.\n  profileId: Int\n\n  # Checks for equality with the object’s `username` field.\n  username: String\n}\n\n# A filter to be used against `User` object types. All fields are combined with a logical ‘and.’\ninput UserFilter {\n  # Filter by the object’s `id` field.\n  id: IntFilter\n\n  # Filter by the object’s `accountLocked` field.\n  accountLocked: BooleanFilter\n\n  # Filter by the object’s `enabled` field.\n  enabled: BooleanFilter\n\n  # Filter by the object’s `password` field.\n  password: StringFilter\n\n  # Filter by the object’s `profileId` field.\n  profileId: IntFilter\n\n  # Filter by the object’s `username` field.\n  username: StringFilter\n\n  # Checks for all expressions in this list.\n  and: [UserFilter!]\n\n  # Checks for any expressions in this list.\n  or: [UserFilter!]\n\n  # Negates the expression.\n  not: UserFilter\n}\n\n# An input for mutations affecting `User`\ninput UserInput {\n  id: Int\n  accountLocked: Boolean!\n  enabled: Boolean!\n  password: String!\n  profileId: Int!\n  username: String!\n}\n\n# Represents an update to a `User`. Fields that are set will be updated.\ninput UserPatch {\n  id: Int\n  accountLocked: Boolean\n  enabled: Boolean\n  password: String\n  profileId: Int\n  username: String\n}\n\ntype UserRole implements Node {\n  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.\n  nodeId: ID!\n  roleId: Int!\n  userId: Int!\n\n  # Reads a single `Role` that is related to this `UserRole`.\n  role: Role\n\n  # Reads a single `User` that is related to this `UserRole`.\n  user: User\n}\n\n# A condition to be used against `UserRole` object types. All fields are tested\n# for equality and combined with a logical ‘and.’\ninput UserRoleCondition {\n  # Checks for equality with the object’s `roleId` field.\n  roleId: Int\n\n  # Checks for equality with the object’s `userId` field.\n  userId: Int\n}\n\n# A filter to be used against `UserRole` object types. All fields are combined with a logical ‘and.’\ninput UserRoleFilter {\n  # Filter by the object’s `roleId` field.\n  roleId: IntFilter\n\n  # Filter by the object’s `userId` field.\n  userId: IntFilter\n\n  # Checks for all expressions in this list.\n  and: [UserRoleFilter!]\n\n  # Checks for any expressions in this list.\n  or: [UserRoleFilter!]\n\n  # Negates the expression.\n  not: UserRoleFilter\n}\n\n# An input for mutations affecting `UserRole`\ninput UserRoleInput {\n  roleId: Int!\n  userId: Int!\n}\n\n# Represents an update to a `UserRole`. Fields that are set will be updated.\ninput UserRolePatch {\n  roleId: Int\n  userId: Int\n}\n\n# A connection to a list of `UserRole` values.\ntype UserRolesConnection {\n  # A list of `UserRole` objects.\n  nodes: [UserRole]!\n\n  # A list of edges which contains the `UserRole` and cursor to aid in pagination.\n  edges: [UserRolesEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `UserRole` you could get from the connection.\n  totalCount: Int\n}\n\n# A `UserRole` edge in the connection.\ntype UserRolesEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `UserRole` at the end of the edge.\n  node: UserRole\n}\n\n# Methods to use when ordering `UserRole`.\nenum UserRolesOrderBy {\n  NATURAL\n  ROLE_ID_ASC\n  ROLE_ID_DESC\n  USER_ID_ASC\n  USER_ID_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  ROLE_BY_ROLE_ID__ID_ASC\n  ROLE_BY_ROLE_ID__ID_DESC\n  ROLE_BY_ROLE_ID__AUTHORITY_ASC\n  ROLE_BY_ROLE_ID__AUTHORITY_DESC\n  USER_BY_USER_ID__ID_ASC\n  USER_BY_USER_ID__ID_DESC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC\n  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC\n  USER_BY_USER_ID__ENABLED_ASC\n  USER_BY_USER_ID__ENABLED_DESC\n  USER_BY_USER_ID__PASSWORD_ASC\n  USER_BY_USER_ID__PASSWORD_DESC\n  USER_BY_USER_ID__PROFILE_ID_ASC\n  USER_BY_USER_ID__PROFILE_ID_DESC\n  USER_BY_USER_ID__USERNAME_ASC\n  USER_BY_USER_ID__USERNAME_DESC\n}\n\n# A connection to a list of `User` values.\ntype UsersConnection {\n  # A list of `User` objects.\n  nodes: [User]!\n\n  # A list of edges which contains the `User` and cursor to aid in pagination.\n  edges: [UsersEdge!]!\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n\n  # The count of *all* `User` you could get from the connection.\n  totalCount: Int\n}\n\n# A `User` edge in the connection.\ntype UsersEdge {\n  # A cursor for use in pagination.\n  cursor: Cursor\n\n  # The `User` at the end of the edge.\n  node: User\n}\n\n# Methods to use when ordering `User`.\nenum UsersOrderBy {\n  NATURAL\n  ID_ASC\n  ID_DESC\n  ACCOUNT_LOCKED_ASC\n  ACCOUNT_LOCKED_DESC\n  ENABLED_ASC\n  ENABLED_DESC\n  PASSWORD_ASC\n  PASSWORD_DESC\n  PROFILE_ID_ASC\n  PROFILE_ID_DESC\n  USERNAME_ASC\n  USERNAME_DESC\n  PRIMARY_KEY_ASC\n  PRIMARY_KEY_DESC\n  PROFILE_BY_PROFILE_ID__ID_ASC\n  PROFILE_BY_PROFILE_ID__ID_DESC\n  PROFILE_BY_PROFILE_ID__EMAIL_ASC\n  PROFILE_BY_PROFILE_ID__EMAIL_DESC\n  PROFILE_BY_PROFILE_ID__FULL_NAME_ASC\n  PROFILE_BY_PROFILE_ID__FULL_NAME_DESC\n  PROFILE_BY_PROFILE_ID__PHONE_NUMBER_ASC\n  PROFILE_BY_PROFILE_ID__PHONE_NUMBER_DESC\n  PROFILE_BY_PROFILE_ID__SNAIL_MAIL_ADDRESS_ASC\n  PROFILE_BY_PROFILE_ID__SNAIL_MAIL_ADDRESS_DESC\n  GAMES_BY_AUTHOR_ID__COUNT_ASC\n  GAMES_BY_AUTHOR_ID__COUNT_DESC\n  MEMBERSHIPS_BY_USER_ID__COUNT_ASC\n  MEMBERSHIPS_BY_USER_ID__COUNT_DESC\n  SHIRT_ORDERS_BY_USER_ID__COUNT_ASC\n  SHIRT_ORDERS_BY_USER_ID__COUNT_DESC\n  USER_ROLES_BY_USER_ID__COUNT_ASC\n  USER_ROLES_BY_USER_ID__COUNT_DESC\n  TOKENS_BY_USER_ID__COUNT_ASC\n  TOKENS_BY_USER_ID__COUNT_DESC\n}\n\n",
      "containsQueryType": true,
      "validSchema": true,
      "contentDuplicate": false,
      "numObjectTypes": 130,
      "containsCycle": true,
      "numDefinitions": 363
    }
  ],
  "metrics": {
    "created_at": "2019-01-02T19:28:21Z",
    "updated_at": "2019-06-06T04:08:09Z",
    "pushed_at": "2019-06-06T04:08:07Z",
    "issues": 0,
    "watchers": 1,
    "fork_count": 0,
    "has_wiki_enabled": true,
    "license": "mit",
    "pull_requests": 0,
    "pull_requests_open": 0,
    "pull_requests_closed": 0,
    "pull_requests_merged": 0,
    "releases": 0,
    "stargazers": 0
  }
}